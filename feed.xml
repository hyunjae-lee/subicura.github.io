<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subicura's Blog</title>
    <description>서비큐라 기술 블로그
</description>
    <link>https://subicura.com/</link>
    <atom:link href="https://subicura.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 10 May 2018 14:30:37 +0900</pubDate>
    <lastBuildDate>Thu, 10 May 2018 14:30:37 +0900</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>크롬 개발자 도구를 이용한 자바스크립트 디버깅</title>
        <description>&lt;p&gt;자바스크립트 디버깅 어떻게 하시나요? 과거의 저를 포함하여 많은 웹 프론트엔드 개발자들이 소스 사이사이에 &lt;code class=&quot;highlighter-rouge&quot;&gt;alert()&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;를 사용하여 상태를 출력하고 변수를 모니터링 합니다. 이러한 &lt;del&gt;노가다식&lt;/del&gt; 디버깅 방식이 널리 퍼진 이유는 자바스크립트의 역사와 관련이 있는데 IE&lt;sup&gt;Internet Explorer&lt;/sup&gt;가 인기 있던 시절 IE는 제대로 된 디버그 도구를 제공하지 않았고 로그도 출력할 수 없었기 때문에 어쩔 수 없이 경고창을 사용했습니다. HTML에 스크립트 코드를 입력하는 인라인 방식이 널리 쓰였고 모듈화는 자바스크립트랑 거리가 먼 이야기였습니다.&lt;/p&gt;

&lt;p&gt;척박한 개발환경에서 등장한 Firefox의  &lt;a href=&quot;https://getfirebug.com/&quot;&gt;Firebug&lt;/a&gt; 플러그인은 엄청나게 인기를 끌었고 후에 등장하는 브라우저의 개발자 도구에 많은 영향을 끼쳤습니다. 최근에는 크롬, 파이어폭스, 사파리, IE 등 대부분 브라우저에서 강력한 개발자 도구를 기본으로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;웹 브라우저에 내장된 개발자 도구는 웹이라는 특성에 맞게 로그나 라인 중단점&lt;sup&gt;Breakpoint&lt;/sup&gt;을 이용한 디버깅뿐 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;click&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt; 이벤트를 체크 할 수 있고 특정 DOM 객체의 class가 변경되는지 감시하다가 변경되는 순간 변경을 유발한 소스에 자동으로 중단점을 걸 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/code_chrome_devtools.gif&quot; alt=&quot;Visual Studio Code + Chrome Devtools 조합&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글에선 디버깅이란 무엇인지 간단하게 살펴보고 크롬 개발자 도구의 실용적이고 강력한 기능을 3가지 예제와 함께 소개합니다. 그리고 Visual Studio Code(VSCode)와 크롬 브라우저를 연동하는 방법도 알아보겠습니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;디버깅이란&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/google-debug-doodle.gif&quot; alt=&quot;Grace Hopper's 107th Birthday - 나방(버그) 디테일에 주목&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그란 프로그램 내의 결함이나 문제점을 이야기하는 것으로 프로그래밍 언어 COBOL의 개발을 주도한 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%8A%A4_%ED%98%B8%ED%8D%BC&quot;&gt;그레이스 호퍼&lt;/a&gt;가 1945년 Mark II의 오작동 원인을 찾다가 컴퓨터에 나방이 껴있는 걸 발견한 것을 최초의 버그라고 기록하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/bug.png&quot; alt=&quot;역사적인 버그 발견 기록&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그를 해결하는 것을 디버깅&lt;sup&gt;debugging&lt;/sup&gt;이라고 하고 주요 전략으로 인터렉티브 디버깅, 컨트롤 분석, 유닛 테스트, 통합 테스트, 로그 파일 분석, 모니터링, 메모리 덤프, 프로파일링등이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Debugging tactics can involve interactive debugging, control flow analysis, unit testing, integration testing, log file analysis, monitoring at the application or system level, memory dumps, and profiling.
- from wikipedia&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기선 인터렉티브 디버깅 전략에 대해 알아봅니다.&lt;/p&gt;

&lt;p&gt;디버깅을 하기 위해서는 도구가 필요한데 특정 기기/프로그램의 경우 특별한 하드웨어가 필요한 때도 있지만, 웹 어플리케이션은 크롬 개발자 도구와 같이 브라우저에 내장된 무료 소프트웨어를 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/Xbox-Debug-Console-Set.jpg&quot; alt=&quot;Xbox Debug Kit&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;devtools&quot;&gt;크롬 개발자 도구 (DevTools)&lt;/h2&gt;

&lt;p&gt;크롬 개발자 도구는 크롬 브라우저에 내장된 개발 관련 도구입니다. 웹 어플리케이션을 개발하고 수정/최적화하는데 필요한 다양한 기능을 제공합니다. 자바스크립트 디버깅뿐 아니라 모바일 기기 시뮬레이터, 네트워크 분석, 최적화에 대해 검사도 해줍니다. 전체 기능은 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/&quot;&gt;공식 홈페이지&lt;/a&gt;에서 확인하세요.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;개발자 도구 열기&lt;/h3&gt;

&lt;p&gt;개발자 도구를 여는 방법은 여러 가지가 있습니다. 단축키를 외우는 걸 추천합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크롬 브라우저 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;More Tools（도구 더보기）&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Developer Tools（개발자 도구）&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;페이지 빈공간에 오른쪽 버튼 누르고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Inspect(검사)&lt;/code&gt; 선택&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; 또는 Windows - &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; 또는 Windows - &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; (Console 패널)&lt;/li&gt;
  &lt;li&gt;MacOS - &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 또는 Windows - &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; (Elements 패널)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;주요 패널 소개&lt;/h3&gt;

&lt;p&gt;디버깅할 때 자주 사용하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Elements&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Console&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Sources&lt;/code&gt; 패널을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Element&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-elements.png&quot; alt=&quot;Elements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주로 디자인을 수정하는 용도로 사용하는 패널입니다. DOM을 확인하고 CSS style을 수정합니다. 특정 DOM의 변화에 중단점을 걸 수 있는 기능이 &lt;del&gt;숨겨져&lt;/del&gt; 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Console&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-console.png&quot; alt=&quot;Console&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로그를 확인하고 스크립트 명령어를 입력하는 패널입니다. 중단점을 건 시점의 변수를 확인할 수 있고 값을 평가하거나 수정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sources&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-sources-edit.png&quot; alt=&quot;Elements&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트 디버깅의 가장 핵심적인 영역입니다. 왼쪽에 파일 관리창과 가운데 소스 에디터, 오른쪽에 디버깅관련 정보창이 있습니다. 창의 크기에 따라 화면 레이아웃이 적절하게 바뀌고 토글 버튼을 누르면 세부창을 열었다 닫았다 할 수 있습니다. 디버깅 정보창 위에 중단점 컨트롤을 이용하여 한땀한땀 코드를 디버깅합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;본격 자바스크립트 디버깅&lt;/h2&gt;

&lt;p&gt;예제 소스는 총 3가지 프로젝트(디렉토리)로 구성되어 있고 &lt;a href=&quot;https://github.com/subicura/javascript-debugging-example&quot;&gt;https://github.com/subicura/javascript-debugging-example&lt;/a&gt; 에서 다운로드 할 수 있습니다. &lt;del&gt;좋아요 클릭좀&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js 8.x&lt;/a&gt;를 설치하고 소스를 다운로드 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm start&lt;/code&gt; 명령어를 입력하면 3000번 포트로 웹서버가 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/example-index.png&quot; alt=&quot;예제 화면&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Basic&lt;/strong&gt; 라이브러리를 사용하지 않은 순수 자바스크립트(&lt;a href=&quot;http://vanilla-js.com/&quot;&gt;Vanilla JS&lt;/a&gt;) 사용 예제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;jQuery&lt;/strong&gt; jQuery 라이브러리 사용 예제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React&lt;/strong&gt; React + Redux TODO app 예제&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-example&quot;&gt;Basic Example&lt;/h3&gt;

&lt;p&gt;아무런 라이브러리를 사용하지 않고 순수 자바스크립트로 작성한 매우 간단한 웹 어플리케이션입니다. 버그를 찾고 한땀한땀 디버깅하는 일련의 흐름을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 버그 찾기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹서버를 실행하고 크롬 브라우저로 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/vanilla.html&lt;/code&gt;에 접속한 후 이름과 내용을 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-sample.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내용이 위에 나오고 이름이 밑에 나오는 걸 기대했는데 결과를 보니 이름과 내용이 반대로 출력되었습니다. 이 버그를 수정해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 중단점 걸기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 실행하는 도중에 일시 정지하고 해당 시점의 변수값을 확인하기 위해 중단점을 걸어보겠습니다. 소스가 익숙하고 어떤 함수가 문제인지 안다면 바로 해당 라인에 중단점을 걸 수 있지만 여기서는 소스가 복잡해서 어디에 중단점을 걸어야 할지 모른다고 가정하고 다른 방식으로 접근해보겠습니다.&lt;/p&gt;

&lt;p&gt;개발자 도구는 특정 라인이 아닌 글로벌한 이벤트에 대해 중단점을 만들 수 있는데 이름과 내용을 입력하고 폼 전송을 하는 순간을 체크하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt; 이벤트에 중단점을 생성할 수 있습니다. 이제 submit 관련 이벤트가 발생하면 해당 소스에서 멈출 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-submit-breakpoint.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;⌥&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt; 또는  &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;Shift&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;I&lt;/code&gt;를 입력해서 개발자 도구를 엽니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sources&lt;/code&gt;탭을 선택합니다.&lt;/li&gt;
  &lt;li&gt;디버깅 정보 창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Event Listener Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Control&lt;/code&gt;&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;을 체크합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이벤트 중단점을 체크했으면 다시 화면으로 돌아와서 이름과 내용을 입력하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Submit&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-submit-debug-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt;파일의 &lt;code class=&quot;highlighter-rouge&quot;&gt;14line&lt;/code&gt;에 소스가 중단되었습니다. 🙀 어떤 파일의 어떤 함수를 수정해야 할지 몰랐지만, submit 이벤트가 발생한다고 추측하고 접근해서 찾았습니다. &lt;del&gt;만세&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 단계별(step) 코드 실행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;코드를 한줄 한줄 단계별로 실행하면서 스크립트가 어떻게 실행되는지, 변수가 어떻게 저장되어 있는지 확인해 보겠습니다. 디버깅 정보창 위에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Step over next function call&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/step-over.png&quot; width=&quot;20&quot; /&gt;을 클릭하여 한 줄씩 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-step-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디버깅 정보창의 Scope 섹션과 소스의 변수명 근처에서 현재 시점의 변수값을 확인할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;변수는 정상적으로 할당된 것 같으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;updatePost&lt;/code&gt; 함수를 살펴봐야겠습니다. updatePost를 호출하는 라인에 디버깅이 멈춰있을 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;Step into next function call&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/step-into.png&quot; width=&quot;10&quot; /&gt;을 클릭해서 updatePost 함수로 이동합니다.&lt;/p&gt;

&lt;p&gt;updatePost함수를 한 줄씩 실행해보니 postHtml에 이름과 메시지가 반대로 들어간 것을 알 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;9line&lt;/code&gt;까지 진행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 콘솔창에서 테스트하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;콘솔탭을 선택하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;postHtml&lt;/code&gt;을 입력하면 디버깅이 진행 중인 시점의 postHtml 변수값이 출력됩니다. 여기서 변수에 새로운 값을 할당하면 진행 중인 변수의 값이 변하게 됩니다. 원래 있던 값을 복사하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;copy(postHtml)&lt;/code&gt; 명령어를 입력합니다. 마치 텍스트를 드래그하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl(⌘)&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 한 것처럼 메모리에 내용이 복사됩니다. 다시 내용을 붙여넣고 이름과 내용을 바꿔줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-console.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sources&lt;/code&gt;탭으로 돌아와서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Resume script execution&lt;/code&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/resume-script-execution.png&quot; width=&quot;14&quot; /&gt;를 클릭하고 디버깅을 끝까지 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-fix.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에 내용이 나오고 밑에 이름이 나오네요. 이름과 내용이 정상적으로 바뀌어서 출력되었습니다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 소스 수정하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Sources창의 에디터에서 코드를 수정합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;post.name&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;post.message&lt;/code&gt;를 바꿔주면 됩니다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Deactivate breakpoints&lt;/code&gt; &lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/deactivate-breakpoints-button.png&quot; width=&quot;15&quot; /&gt; 버튼을 클릭해서 활성화되어 있는 중단점을 비활성화하고 다시 메시지를 입력해 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-source-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;짜잔!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/message-fix-bug.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그를 고쳤습니다. 이제 문제없이 동작하네요! &lt;del&gt;풀리퀘고고&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;방금 살펴본 방식은 수정한 내용을 임시로 저장한다는 점에 유의하세요. 새로 고침을 하면 수정전 소스로 원복됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;크롬 개발자 도구의 워크플레이스&lt;sup&gt;workspace&lt;/sup&gt;기능을 사용하면 수정한 내용을 로컬 소스에 바로 반영할 수 있습니다. 개발자 도구의 에디터도 문법 하이라이팅&lt;sup&gt;Syntax Highlighting&lt;/sup&gt;을 지원하고 자동완성 기능&lt;sup&gt;Auto Completion&lt;/sup&gt;을 제공하지만, 아직 다른 전용 에디터보다는 기능이 부족합니다. 따라서 뒤에 설명할 VSCode와 연동해서 사용하는 걸 추천하지만 간단하게 워크플레이스 기능을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Workspace 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Workspace는 개발 중인 소스 파일을 개발자 도구에 등록하고 브라우저에서 바라보는 네트워크 상의 파일을 연결하여 수정을 편하게 해주는 기능입니다.&lt;/p&gt;

&lt;p&gt;예를 들면, &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/js/vanilla-script.js&lt;/code&gt; 라는 네트워크상의 파일을 로컬의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/subicura/Workspace/js/vanilla-script.js&lt;/code&gt; 와 연결할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Workspace에 폴더를 등록하기 위해 개발자 도구의 Sources탭을 선택합니다. 그리고 왼쪽 파일 네비게이션 창에서 Filesystem 탭을 누르고 &lt;code class=&quot;highlighter-rouge&quot;&gt;+ Add folder to workspace&lt;/code&gt;를 누르거나 소스 폴더를 드래그해서 추가해줍니다. 그러면 접근 권한을 묻는 창이 뜨고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Allow&lt;/code&gt;를 선택해줍니다. 마지막으로 화면을 새로고침하면 맵핑된 파일 아이콘에 연결되었다는 의미의 동그라미가 표시됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-workspace.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;단지 폴더만 추가했을 뿐인데 개발자 도구가 똘똘하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;vanilla.html&lt;/code&gt; 파일과 &lt;code class=&quot;highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt; 파일을 맵핑 하였습니다. 동일한 파일명이 여러 개 있어 자동으로 맵핑 되지 않으면 Network의 파일에서 오른쪽 버튼을 누르고 따로 맵핑해주면 됩니다. 잘 안된다면 캐시를 비활성화하고 새로고침해 보세요.&lt;/p&gt;

&lt;p&gt;이제 개발자 도구 에디터에서 소스를 수정하면 로컬 개발환경의 소스 파일도 수정됩니다. 새로고침해도 문제없네요!&lt;/p&gt;

&lt;h3 id=&quot;jquery-example&quot;&gt;jQuery Example&lt;/h3&gt;

&lt;p&gt;Basic 예제에서 자바스크립트 디버깅의 가장 기본적인 작업 흐름을 살펴보았습니다. 이번에는 좀더 현실적으로 jQuery라이브러리를 사용한 웹 어플리케이션을 다양한 방법으로 디버깅해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-example.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹서버를 실행하고 크롬 브라우저로 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/jquery.html&lt;/code&gt;에 접속합니다. Github ID를 입력하면 정보를 보여주는 웹 어플리케이션입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Blackboxing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Basic 예제에서는 라이브러리를 사용하지 않았기 때문에 submit 이벤트를 검사할 때 정상적으로 소스에 중단점이 걸린 것을 확인했습니다. jQuery같은 라이브러리를 쓰면 상황이 좀 달라지는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(element).click()&lt;/code&gt;과 같은 코드는 이벤트 생성을 jQuery 라이브러리에 위임하고 실제로  &lt;code class=&quot;highlighter-rouge&quot;&gt;jquery.js&lt;/code&gt; 파일에서 이벤트가 발생합니다.&lt;/p&gt;

&lt;p&gt;테스트를 위해 Event Listener중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;click&lt;/code&gt;이벤트에 중단점을 생성합니다. 디버깅 정보 창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Event Listener Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Mouse&lt;/code&gt;&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;click&lt;/code&gt;을 체크하면 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch Avatar&lt;/code&gt;를 클릭해볼까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-click.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예상대로(?) jquery 파일에 중단점이 걸렸습니다. minified되어 알아볼 수 없는 코드가 보이고 Scope의 변수 또한 아무 의미가 없어 보입니다. minified된 코드를 좀 더 이쁘게 바꿔보겠습니다. 에디터 왼쪽 하단에 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt; 버튼을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-pretty-code.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭔가 한 줄로 복잡했던 소스가 좀 이뻐지긴 했지만.. 큰 도움이 되지 않습니다. 역시 디버깅은 console.log 밖에 없을까요? &lt;del&gt;안돼&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;개발자 도구에선 이렇게 무의미한 파일을 제외하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Blackboxing&lt;/code&gt;이라는 옵션을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-blackboxing-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발자 도구의 설정을 누르고 왼쪽 메뉴에서 Blackboxing을 선택한 다음 Add pattern..을 클릭하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;/.*jquery.*\.js$&lt;/code&gt; 패턴을 등록합니다. jquery라는 글자가 들어간 js 파일을 제외합니다.&lt;/p&gt;

&lt;p&gt;새로고침을 하고 다시 클릭해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-jq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jquery파일이 제외되어 &lt;code class=&quot;highlighter-rouge&quot;&gt;jq-script.js&lt;/code&gt;파일에 정상적으로 중단점이 걸렸습니다. 이러한 방식으로 react, vue 라이브러리 파일등을 Blackboxing에 등록해서 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fetch Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이번에는 click 이벤트가 아닌 &lt;code class=&quot;highlighter-rouge&quot;&gt;github.com에 네트워크 요청이 있을 때&lt;/code&gt; 중단점을 걸어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-fetch-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디버깅 정보 창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;XHR/fetch Breakpoints&lt;/code&gt;섹션을 열고 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 버튼을 누른 다음에 &lt;code class=&quot;highlighter-rouge&quot;&gt;github&lt;/code&gt;을 입력합니다. Github ID 입력창에 ID를 입력하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch Avatar&lt;/code&gt;를 클릭하면 github이 들어간 주소에 네트워크 요청이 있는 코드에서 중단점이 생성됩니다. 이제 네트워크 요청을 하는 코드가 어디 있는지 고민하지 않아도 되겠죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Column Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fetch함수를 자세히 보면 한 줄로 길게 연결(chain)되어 있는걸 알 수 있습니다. 어떤 응답 데이터가 오는지 궁금한데… 한 줄 내 중간중간열에 중단점을 생성할 수도 있을까요? 일단 디버깅할 라인에 중단점을 체크하면 연결된 함수에 다시 중단점을 걸 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-inline-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;47line&lt;/code&gt;에 중단점을 생성하고 updateGithub 함수 앞에 또 중단점을 생성했습니다. Github ID를 입력하고 Fetch를 하면 중간 중단점에 디버깅이 멈추고 해당 시점의 data 변수값도 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM change Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 DOM이 변경되었을 때 중단점을 생성해보겠습니다. 지금 보는 웹 어플리케이션은 Github의 사용자 정보를 조회하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;라는 ID를 가진 div에 정보를 출력합니다. result div에 중단점을 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Elements&lt;/code&gt;탭을 누르고 &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; div를 찾은 다음 오른쪽 버튼을 누르면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Break on&lt;/code&gt;메뉴와  &lt;code class=&quot;highlighter-rouge&quot;&gt;subtree modifications&lt;/code&gt; 항목이 보입니다. 해당 DOM의 하위에 값이 변경되면 멈추겠다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-dom-break-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DOM 왼쪽에 동그라미 표시가 된 게 보이시죠? 이제 다시 테스트를 해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/jquery-dom-breakpoint-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터를 요청하고 화면에 그리는 순간 중단점에 걸립니다. 이제 에디터 전체검색창에 DOM ID를 입력하고 검색결과의 홍수 속에서 원하는 소스를 일일이 찾아보지 않아도 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;react-example&quot;&gt;React Example&lt;/h3&gt;

&lt;p&gt;마지막 예제는 webpack을 이용하여 소스를 번들링한 최신 트랜드를 반영한 예제입니다. 이전까지 예제는 소스 파일과 브라우저에서 보이는 소스 파일이 정확하게 일치했지만 webpack을 사용하면 소스 파일을 bundle.js라는 하나의 파일로 묶기 때문에 소스가 일치하지 않습니다. 이런 경우에도 디버깅이 가능할까요?&lt;/p&gt;

&lt;p&gt;브라우저에서  &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/react.html&lt;/code&gt;에 접속합니다. 개발자 도구를 열고 Sources탭의 파일 네비게이션 창을 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/react-sources-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static/js/bundle.js&lt;/code&gt; 파일외에 webpack으로 번들링 된 소스 파일 목록이 보입니다.  &lt;code class=&quot;highlighter-rouge&quot;&gt;src/reducers/todos.js&lt;/code&gt;파일의 switch문에 중단점을 걸고 새로운 할 일을 등록하면 정확하게 중단점에 멈추는 걸 확인할 수 있습니다. 어떻게 된걸까요? 정답은 source map입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;source map&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle.js&lt;/code&gt; 파일의 최하단을 보면 소스맵과 관련된 주석이 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;//# sourceMappingURL=bundle.js.map&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000/static/js/bundle.js.map&lt;/code&gt;를 주소창에 입력하면 뭔가 복잡한 파일이 나타납니다. 😱 간략하게 표현하면 다음과 같은 구조로 되어 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;out.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sourceRoot&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sources&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bar.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;names&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;maps&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fun&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mappings&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;AAgBC,SAAQ,CAAEA&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;source map&lt;/code&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;소스맵은 합쳐지거나 minified된 파일과 원본 파일을 연결하기 위해 어떤 소스의 몇번째 줄 몇번째 열이 어떤 소스의 몇번째 줄 몇번째 열과 일치하는지 알려주는 역할을 합니다. &lt;del&gt;너와 나의 연결고리&lt;/del&gt; React와 관련된 파일은 엄청나게 많기 때문에 소스맵파일도 엄청나게 클 수밖에 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소스맵에 대해 더 자세히 알고 싶다면 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;Introduction to JavaScript Source Maps - HTML5 Rocks&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;webpack은 소스맵을 생성할 수 있는 옵션(&lt;code class=&quot;highlighter-rouge&quot;&gt;devtool&lt;/code&gt;)이 있어서 설정만으로 손쉽게(?) 사용할 수 있습니다. 이러한 방식은 typescript로 작성한 코드에서도 잘 동작합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conditional Breakpoint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Redux에서 reducer는 다양한 action을 처리하는 곳 입니다. 추가/수정/삭제에 대한 action이 들어올 수 있는데 삭제 action만 중단점을 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtool-conditional.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조금 전 생성한 중단점에 오른쪽 버튼을 누르면 중단점을 수정할 수 있고 조건절에 &lt;code class=&quot;highlighter-rouge&quot;&gt;action.type == 'DELETE_TODO'&lt;/code&gt; 를 입력합니다. 새로운 할일을 등록하면 중단이 안되지만 삭제를 하면 중단점에 걸립니다. 이렇게 중단점에 조건을 걸면 조건에 맞는 요청만 체크할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Store as Global Variable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 특정 React Component에 존재하는 멤버(지역) 변수를 콘솔창에서 자유롭게 테스트하는 방법을 알아봅니다. 자바스크립트가 모듈화 되면서 콘솔에서 내부에 존재하는 변수에 접근하기 어려워졌지만 다 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;개발자 도구에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;src/components/Header.js&lt;/code&gt;파일을 열고 &lt;code class=&quot;highlighter-rouge&quot;&gt;handleSave&lt;/code&gt;에 중단점을 만듭니다. 중단점에 걸리면 Scope의 Closure (Header) 섹션에서  &lt;code class=&quot;highlighter-rouge&quot;&gt;_this&lt;/code&gt; 변수를 오른쪽 버튼 클릭하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Store as global variable&lt;/code&gt;을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/devtools-global.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;콘솔창을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp1&lt;/code&gt;이라는 변수가 생성된 것을 알 수 있고 이제 자유롭게 사용할 수 있습니다. 중단점을 제거하고 코드로 할 일을 생성해 보겠습니다. 콘솔에 &lt;code class=&quot;highlighter-rouge&quot;&gt;temp1.props.addTodo(&quot;Hello world&quot;)&lt;/code&gt;를 입력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/react-console.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 새로운 할 일이 추가되었습니다. 이제 콘솔에서 자유롭게 테스트하세요!&lt;/p&gt;

&lt;h2 id=&quot;visual-studio-code&quot;&gt;Visual Studio Code&lt;/h2&gt;

&lt;p&gt;지금까지 개발자 도구의 다양한 디버깅 기능을 살펴보았습니다. 내장된 에디터도 간단하게 사용하기엔 좋지만, 아직 기능이 많이 부족해 보입니다.  코드 작성은 VSCode에서, 중단점 및 테스트는 크롬 브라우저에서 테스트할 수 있게 설정해보겠습니다.&lt;/p&gt;

&lt;p&gt;VSCode를 실행하고 다운받은 소스 디렉토리를 엽니다.&lt;/p&gt;

&lt;h3 id=&quot;chrome--&quot;&gt;chrome 확장기능 소개&lt;/h3&gt;

&lt;p&gt;크롬 브라우저와 연동하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Debugger for Chrome&lt;/code&gt; 확장기능을 설치해야 합니다. VSCode의 확장 탭에서 chrome을 검색하고 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/debugger-for-chrome-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되면 디버그 포트를 오픈한 크롬을 실행할 수 있게 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vscode/launch.json&lt;/code&gt; 파일을 작성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Launch Js Debug Example&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;chrome&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;http://localhost:3000/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;webRoot&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pathMapping&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/src&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;js/vanilla-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/public/js/vanilla-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;js/jq-script.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;${workspaceFolder}/public/js/jq-script.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;skipFiles&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;node_modules/*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;react-dom*.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jquery-3.3.1.min.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;disableNetworkCache&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;설정 파일을 보면 대략 어떤 내용인지 유추할 수 있어 자세히 설명하지 않습니다. 옵션에 대한 설명은 &lt;a href=&quot;https://github.com/Microsoft/vscode-chrome-debug&quot;&gt;GitHub - Microsoft/vscode-chrome-debug: Debug your JavaScript code running in Google Chrome from VS Code.&lt;/a&gt; 여기서 확인할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;vscode-debugger&quot;&gt;VSCode Debugger&lt;/h3&gt;

&lt;p&gt;설정 파일을 저장하면 디버깅 모드의 실행 목록에 자동으로 추가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/vscode-debug-edit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;플레이 버튼처럼 생긴 &lt;code class=&quot;highlighter-rouge&quot;&gt;Start Debugging&lt;/code&gt;버튼을 클릭하면 깨끗한 프로필의 크롬 브라우저가 실행됩니다. 디버깅 준비가 완료되었으니 테스트로 &lt;code class=&quot;highlighter-rouge&quot;&gt;vanilla-script.js&lt;/code&gt; 파일을 열고 updatePost 함수에 중단점을 설정해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2018-02-14-javascript-debugging/vscode-debugger.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내용을 입력하면 크롬 브라우저와 VSCode 동시에 중단점이 걸리는 걸 볼 수 있습니다. 개발자 도구처럼 한줄한줄 실행할 수도 있고 콘솔을 사용할 수도 있습니다. 개발자 도구와 VSCode가 동기화돼서 움직이기 때문에 개발자 도구에 중단점을 생성해도 VSCode에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 VSCode를 사용하면서 크롬 개발자 도구의 강력한 부가 기능도 같이 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;그래서&lt;/h2&gt;
&lt;p&gt;자바스크립트 디버깅에 대한 자료를 찾아보면서 이렇게 개발자 도구가 좋아졌나 하고 많이 놀랐습니다. 크롬 브라우저는 6주에 한 번씩 새로운 버전을 &lt;a href=&quot;https://www.chromium.org/chrome-release-channels&quot;&gt;릴리즈&lt;/a&gt;하는데 매번 새로운 기능을 추가하고 있습니다. &lt;a href=&quot;https://www.youtube.com/playlist?list=PLNYkxOF6rcIBDSojZWBv4QJNoT4GNYzQD&quot;&gt;공식 Youtube 채널&lt;/a&gt;에서 새 릴리즈에 대한 내용을 짧게 요약해주니 관심 있으면 구독하는 걸 추천합니다.&lt;/p&gt;

&lt;p&gt;Visual Studio Code 또한 굉장히 빠르게 업데이트되고 있습니다.(매달 &lt;a href=&quot;https://code.visualstudio.com/updates&quot;&gt;릴리즈&lt;/a&gt;) Node.js와의 궁합도 좋아 서버를 node로 작성한 경우 서버와 클라이언트를 동시에 스무스하게 디버깅하고 작업할 수 있습니다. 특히 터치바가 장착된 맥북 프로를 사용한다면 디버깅 모드에서 컨트롤이 이쁘게 터치바에 표시되는 걸 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt;는 여전히 쓸만하지만 다른 여러 가지 방법을 익혀둔다면 디버깅을 더 효율적으로 할 수 있습니다. 그리고 잘 모듈화된 소스, 이해하기 쉽게 지어진 변수명 or 함수명이 더해지면 더더더욱 효과적일거라 생각합니다. 자바스크립트를 이용한 프레임워크는 더욱 복잡해지고 유지보수는 더 어려워집니다. 오늘도 디버깅하느라 고생하는 많은 개발자에 도움이 되길 바랍니다.&lt;/p&gt;

&lt;p&gt;개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Feb 2018 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2018/02/14/javascript-debugging.html</link>
        <guid isPermaLink="true">https://subicura.com/2018/02/14/javascript-debugging.html</guid>
        
        <category>Chrome</category>
        
        <category>Devtools</category>
        
        <category>javascript</category>
        
        <category>debug</category>
        
        <category>node</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>본격 macOS에 개발 환경 구축하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/terminal-neofetch.png&quot; alt=&quot;iTerm2 + snazzy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;개발 관련 스터디 모임이나 컨퍼런스에서 발표를 듣다 보면 발표 주제와 별도로 예제 화면이나 라이브 코딩에서 사용하는 개발 도구에 관심이 가는 경우가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;같은 macOS를 사용하는데 터미널이 왜 다르게 생긴 거지? vi 에디터에 원래 저런 기능이 있었어? 뭐가 저렇게 막 글자가 자동완성되는 거지? 저건 무슨 테마지?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개인적인 경험으로도 어디서 발표를 할 때 주제와 상관없이 “아까 그거 무슨 프로그램이에요?”, “어떻게 셋팅한 거에요?” 와 같은 질문을 받은 적이 있고 다른 분들 화면을 보고 쉬는 시간에 조용히 가서 “아까 그거 어떻게 하신건지..” 하고 물어본 경우도 많습니다.&lt;/p&gt;

&lt;p&gt;개발 환경 설정은 실제적인 개발과 상관이 없고 &lt;del&gt;해도 그만 안 해도 그만&lt;/del&gt; 개발자들의 개인 취향에 영향을 많이 받기 때문에 처음부터 차근차근 설정하는 법을 알려주는 문서가 잘 없고 여기저기 작은 단위로 소개하거나 모임 같은 곳에서 입에서 입으로 전해지고 있습니다.&lt;/p&gt;

&lt;p&gt;이 글은 macOS에서 터미널을 자주 사용하는 개발자를 대상으로 심플하고 깔끔한 테마 위주의 개발 환경을 설정하는 방법을 소개합니다. 이 글을 보고 하나하나 설정하면 어디 가서 발표할 때 고오오급 개발자처럼 보이는 효과가 있으며 개발 생산성이 조금은 높아질 거라고 생각합니다.&lt;/p&gt;

&lt;p&gt;최종 설정이 완료된 화면을 살펴보고 어떻게 설정하는지 알아봅니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/terminal-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;키보드 기호 설명&lt;/h2&gt;

&lt;p&gt;단축키 입력과 관련해서 기호를 사용합니다. 잘 기억해 둡니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기호&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;⌘&lt;/td&gt;
      &lt;td&gt;Command&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⌥&lt;/td&gt;
      &lt;td&gt;Option&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⌃&lt;/td&gt;
      &lt;td&gt;Control&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⇧&lt;/td&gt;
      &lt;td&gt;Shift&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;동시 입력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;,&lt;/td&gt;
      &lt;td&gt;키를 떼고 다시 입력함&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;예) &lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt; 는 control키를 누른 상태에서 b를 누르고 control키와 b에서 모두 손을 뗀 다음에 c를 입력하라는 의미입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;시스템 설정&lt;/h2&gt;

&lt;p&gt;본격적인 개발환경 설정에 앞서 몇 가지 유용한 시스템 설정을 확인해봅니다. macOS High Sierra를 기준으로 하였으나 다른 버전도 비슷비슷할 것으로 보입니다. 반드시 동일하게 설정할 필요는 없으며 보고 괜찮다 싶은 항목만 적용하면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;system-preferences&quot;&gt;System Preferences&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/system-preferences.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;상단 메뉴의 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;/code&gt; 로고를 누르고 &lt;code class=&quot;highlighter-rouge&quot;&gt;System Preferences...&lt;/code&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;미션 컨트롤 창 순서 고정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mission Control&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Automatically rearrange Spaces based on most recent use&lt;/code&gt;: 체크 안함&lt;/li&gt;
  &lt;li&gt;미션 컨트롤 창 순서가 기본적으로 최근 사용 순으로 설정되어 있어 의도하지 않게 순서가 변경되는 것을 막음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;언어 설정 영어 우선순위로 변경&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Language &amp;amp; Region&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferred languages&lt;/code&gt;: English &amp;gt; 한국어 (드래그로 순서 조정)&lt;/li&gt;
  &lt;li&gt;간혹 locale 설정 때문에 오류가 발생하는 걸 방지해주고 영어 오류 메시지가 구글검색이 잘됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;패스워드 즉시 설정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Require password&lt;/code&gt;: immediately&lt;/li&gt;
  &lt;li&gt;잠자기 모드나 화면 보호기가 켜지면 즉시 패스워드 입력을 활성화하여 보안을 최대한 안전하게 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;분실대비 패스워드 메시지 설정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show a message when the screen is locked&lt;/code&gt;: 전화번호 / 이름&lt;/li&gt;
  &lt;li&gt;혹시 분실했을 경우를 대비하여 전화번호, 이름 등을 알려줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;디스크 암호화&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;FileVault&lt;/code&gt;: Turn On FileVault&lt;/li&gt;
  &lt;li&gt;분실 시 복구 불가능하게 디스크를 암호화&lt;/li&gt;
  &lt;li&gt;파일 읽기/쓰기 퍼포먼스가 걱정되지만 최신 CPU와 SSD에서는 거의 성능 차이가 없다고 함&lt;del&gt;믿고쓰자&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;모든 텍스트 자동 변경 옵션 끄기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Keyboard&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt;: 모든 자동 변경 옵션 끄기&lt;/li&gt;
  &lt;li&gt;입력한 단어를 컴퓨터 마음대로 바꾸는 걸 방지&lt;/li&gt;
  &lt;li&gt;특히 Use smart quotes and dashes는 코드 복사하다가 따옴표가 바뀌면서 고생이 시작됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;클릭은 터치로&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Trackpad&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Point &amp;amp; Click&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Tab to click&lt;/code&gt;: 체크함&lt;/li&gt;
  &lt;li&gt;트랙패드 클릭 시 꾸욱 누를 필요 없이 톡톡 터치로 클릭해서 손의 피로를 줄임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;드래그는 세손가락으로&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Accessibility&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Mouse &amp;amp; Trackpad&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Trackpad options...&lt;/code&gt;:  Enable dragging - three finger drag&lt;/li&gt;
  &lt;li&gt;창 또는 아이콘을 이동할 때 트랙패드를 누른 상태로 이동할 필요 없이 세 손가락으로 드래그 할 수 있음&lt;/li&gt;
  &lt;li&gt;이건 해봐야 감이 오는데 몰랐다면 신세계가 열림&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;finder-preference&quot;&gt;Finder Preference&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2017-11-22-mac-os-development-environment-setup/finder-preferences.png&quot; style=&quot;width: 450px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Finder&lt;/code&gt;를 실행하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;Finder&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences...&lt;/code&gt;)를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파인더 기본 폴더 설정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;General&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;New Finder windows show&lt;/code&gt;: subicura (home folder)&lt;/li&gt;
  &lt;li&gt;파인더 최초 실행 시 버벅임이 없도록 기본 폴더를 홈 폴더로 설정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;파일 확장자 보여주기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show all filename extensions&lt;/code&gt;: 체크함&lt;/li&gt;
  &lt;li&gt;모든 파일의 확장자를 보여줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;download-folder-option&quot;&gt;Download Folder Option&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/article_images/2017-11-22-mac-os-development-environment-setup/download-option.png&quot; style=&quot;width: 250px&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Downloads&lt;/code&gt; 폴더로 이동하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show View Options&lt;/code&gt;)를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;날짜그룹 + 이름 정렬&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Arrange By&lt;/code&gt;:Date added, &lt;code class=&quot;highlighter-rouge&quot;&gt;Sort By&lt;/code&gt;:Name&lt;/li&gt;
  &lt;li&gt;파일 목록을 보여줄 때 날짜별로 그룹화 하고 그룹 내에서 이름으로 다시 정렬&lt;/li&gt;
  &lt;li&gt;다운로드 폴더 특성상 최근에 받은 파일들을 찾는 경우가 많으므로 유용함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;필수 프로그램&lt;/h2&gt;

&lt;p&gt;시스템 설정을 완료했으니 개발 환경 구축을 위한 필수 프로그램을 설치합니다.&lt;/p&gt;

&lt;h3 id=&quot;xcode&quot;&gt;Xcode&lt;/h3&gt;

&lt;p&gt;macOS에는 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;와 같은 컴파일 도구가 설치되어 있지 않기 때문에 명령어 도구&lt;sub&gt;Command Line Tools&lt;/sub&gt;를 설치해야 합니다. 예전에는 Xcode를 전체 설치하고 추가로 명령어 도구를 설치해야 했으나 Xcode용량이 꽤 크고 모든 사람이 IDE가 필요한 게 아니기 때문에 명령어 도구만 따로 설치할 수 있게 변경되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;xcode-select --install&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;확인&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# gcc test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gcc
clang: error: no input files&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;homebrew&quot;&gt;homebrew&lt;/h3&gt;

&lt;p&gt;brew&lt;sub&gt;homebrew&lt;/sub&gt;는 각종 커맨드라인 프로그램(요즘은 GUI도..)을 손쉽게 설치해주는 맥용 패키지 매니저입니다. 리눅스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt&lt;/code&gt;나  &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;과 비슷하며 brew외에 &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; 라는 패키지 메니저가 있는데 몇몇 단점으로 요즘은 거의 brew를 사용하는 추세입니다. 다양한 프로그램을 복잡한 빌드과정 없이 손쉽게 설치할 수 있고 업데이트, 관리도 간단하므로 안쓸 이유가 없는 필수 프로그램입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;그냥 홈페이지 가서 다운로드 하고 설치하는 게 편한데..&lt;/code&gt;라고 하는분들이 있는데 나중에 업데이트나 삭제를 생각해보면 글쎄요.. brew 쓰세요!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;/usr/bin/ruby -e &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;확인&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# brew test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;brew doctor
Your system is ready to brew.&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;Homebrew 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://docs.brew.sh/Manpage.html&quot;&gt;brew 명령어&lt;/a&gt; / &lt;a href=&quot;http://formulae.brew.sh/&quot;&gt;brew 패키지 검색&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;git&quot;&gt;git&lt;/h3&gt;

&lt;p&gt;버전 관리 도구로 유명한 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;입니다. 다들 아시죠? macOS에 기본으로 설치되어 있지만 최신 버전이 아니므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;를 이용해서 업데이트 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;git-lfs&lt;/code&gt; 는 Git Large File Storage로 용량이 큰 바이너리 파일을 git으로 관리할 때 유용합니다. git 설치할 때 같이 설치합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install git git-lfs&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;git 설치가 완료되었으면 개인정보를 설정하고 맥에서 한글 파일명을 정상적으로 처리하기 위해 추가 옵션을 설정합니다. &lt;del&gt;망할 한글처리&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설정&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;git config --global user.name &lt;span class=&quot;s2&quot;&gt;&quot;Your Name&quot;&lt;/span&gt;
git config --global user.email &lt;span class=&quot;s2&quot;&gt;&quot;you@your-domain.com&quot;&lt;/span&gt;
git config --global core.precomposeunicode &lt;span class=&quot;nb&quot;&gt;true
&lt;/span&gt;git config --global core.quotepath &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;Git LFS 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;터미널 설정&lt;/h2&gt;

&lt;p&gt;시스템 설정도 하고 필수 프로그램도 설치했으니 본격적으로 터미널을 설정해 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;iterm2&quot;&gt;iTerm2&lt;/h3&gt;

&lt;p&gt;macOS에 기본으로 설치되어 있는 Terminal 앱 대신 iTerm2를 터미널 앱으로 사용합니다. iTerm2는 기본 앱에 없는 &lt;a href=&quot;https://www.iterm2.com/features.html&quot;&gt;다양한 기능&lt;/a&gt;이 있고 손쉽게 테마를 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;brew로 설치 하거나 &lt;a href=&quot;https://www.iterm2.com/downloads.html&quot;&gt;여기&lt;/a&gt;서 다운로드 합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew cask install iterm2&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;테마선택&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/snazzy-theme.png&quot; alt=&quot;snazzy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치를 완료했으면 &lt;a href=&quot;https://github.com/sindresorhus/iterm2-snazzy/raw/master/Snazzy.itermcolors&quot;&gt;Snazzy.itermcolors&lt;/a&gt; 파일을 오른쪽 버튼 누르고 다운 받거나 &lt;a href=&quot;http://iterm2colorschemes.com/&quot;&gt;여러 개의 테마&lt;/a&gt;를 둘러보고 맘에드는것을 고릅니다. 다운받은 파일을 더블클릭하면 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;iTerm Color Preset&lt;/code&gt;에 추가됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;iTerm을 실행하고 설정(&lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;)창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; 항목을 선택하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Colors&lt;/code&gt;탭을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm-preferences.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오른쪽 하단에  &lt;code class=&quot;highlighter-rouge&quot;&gt;Color presets...&lt;/code&gt; 선택 박스를 클릭하면 조금전에 추가한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Snazzy&lt;/code&gt; preset을 선택할 수 있습니다.&lt;/p&gt;

&lt;p&gt;음.. 그런데 테마를 바꿔도 그다지 달라지는 건 없어보입니다.. &lt;del&gt;이게 무슨 소리요?!&lt;/del&gt; 제대로 색을 활용하려면 쉘&lt;sub&gt;shell&lt;/sub&gt; 설정을 해야합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;추가설정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타이틀바 배경색 어둡게 변경
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Theme&lt;/code&gt;: Dark&lt;/li&gt;
      &lt;li&gt;High Sierra에서는 &lt;a href=&quot;https://gitlab.com/gnachman/iterm2/issues/4080&quot;&gt;현재&lt;/a&gt; Light/Dark 테마만 선택할 수 있으며 임의의 색은 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스크롤바 감추기
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Hide scrollbars&lt;/code&gt;: 체크함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타이틀바 밑에 1px 라인 제거
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Appearance&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Show line under title bar when the tab bar is not visible&lt;/code&gt;: 체크 안함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마진 수정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Height of top and bottom margins in terminal panes&lt;/code&gt;: 10&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Width of left and right margins in terminal panes&lt;/code&gt;: 12&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.iterm2.com&quot;&gt;iTerm2 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://www.iterm2.com/downloads.html&quot;&gt;iTerm2 다운로드&lt;/a&gt; / &lt;a href=&quot;https://github.com/sindresorhus/iterm2-snazzy&quot;&gt;snazzy github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;zsh-with-oh-my-zsh&quot;&gt;zsh with oh-my-zsh&lt;/h3&gt;

&lt;p&gt;iTerm2도 설치하고 테마도 설치했으니 쉘을 바꿀 차례입니다.&lt;/p&gt;

&lt;p&gt;macOS는 기본으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_(Unix_shell)&quot;&gt;Bash(Bourne-again) shell&lt;/a&gt;을 사용하고 있습니다. bash외에 csh, ksh, sh, tcsh, zsh등을 내장하고 있는데 최근 대새는 단연 zsh입니다. zsh에 설정 관리 프레임워크인 oh-my-zsh을 사용하여 이쁜 테마를 적용하고 여러 가지 플러그인을 설치해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;zsh을 최신 버전으로 업데이트하고 &lt;a href=&quot;https://github.com/zsh-users/zsh-completions&quot;&gt;zsh-completions&lt;/a&gt;도 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install zsh zsh-completions&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;그리고 zsh의 설정을 관리해주는 oh-my-zsh을 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sh -c &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치스크립트를 실행하면 관련 파일을 설치하고 패스워드를 물어봅니다. 계정의 패스워드를 입력하면 기본쉘을 자동으로 bash에서 zsh로 변경해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;플러그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oh-my-zsh의 가장 강력한 점은 플러그인입니다. &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins&quot;&gt;기본 플러그인&lt;/a&gt;외에 명령어 하이라이팅 플러그인 &lt;a href=&quot;https://github.com/zsh-users/zsh-syntax-highlighting&quot;&gt;zsh-syntax-highlighting&lt;/a&gt;과 자동완성 플러그인 &lt;a href=&quot;https://github.com/zsh-users/zsh-autosuggestions&quot;&gt;zsh-autosuggestions&lt;/a&gt;을 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# zsh-syntax-highlighting&lt;/span&gt;
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ZSH_CUSTOM&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;~/.oh-my-zsh/custom&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;/plugins/zsh-syntax-highlighting

&lt;span class=&quot;c&quot;&gt;# zsh-autosuggestions&lt;/span&gt;
git clone git://github.com/zsh-users/zsh-autosuggestions &lt;span class=&quot;nv&quot;&gt;$ZSH_CUSTOM&lt;/span&gt;/plugins/zsh-autosuggestions&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;플러그인을 설치하면 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 설정을 해야합니다. 파일을 열고 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt;항목에 플러그인을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  git
  zsh-syntax-highlighting
  zsh-autosuggestions
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설정 파일을 수정했으면 터미널을 재시작하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt; 명령어를 실행하여 설정을 다시 불러와야 합니다. 이제 명령어를 입력할 때 존재하지 않는 명령어는 빨간색으로 뜨고 한번 입력했던 명령어를 회색으로 표현해주는 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;oh-my-zsh의 기본 테마인 &lt;code class=&quot;highlighter-rouge&quot;&gt;robbyrussell&lt;/code&gt;도 깔끔하지만, 이 외에 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Themes&quot;&gt;다양한 테마&lt;/a&gt;가 존재합니다. 테마를 바꾸는 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZSH_THEME=&quot;robbyrussell&quot;&lt;/code&gt; 부분을 원하는 테마로 수정하면 됩니다.&lt;/p&gt;

&lt;p&gt;여기서는 이쁘고 단순하고 빠른 &lt;a href=&quot;https://github.com/sindresorhus/pure&quot;&gt;pure&lt;/a&gt; prompt를 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install nodejs &lt;span class=&quot;c&quot;&gt;# nodejs가 설치되어 있다면 skip&lt;/span&gt;
npm install --global pure-prompt&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치를 완료했으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;파일에 다음항목을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;autoload -U promptinit; promptinit
prompt pure&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 zsh 기본 설정이 끝났습니다!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;oh-my-zsh 팁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;zsh과 oh-my-zsh의 조합으로 강력한 쉘을 사용할 수 있게 되었습니다. 여기서 모든 기능을 설명할 순 없지만 자주 사용하는 몇 가지 팁을 소개합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;명령어가 기억나지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;tab&lt;/code&gt;을 누르세요&lt;/li&gt;
  &lt;li&gt;cd ../.. 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;....&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.....&lt;/code&gt;, …&lt;/li&gt;
  &lt;li&gt;단축명령어 - &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; =&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;gst&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; =&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;gl&lt;/code&gt; 등등 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugin:git&quot;&gt;다양한 단축명령어&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/zsh-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;팁이 맘에 든다면 &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins&quot;&gt;다른 플러그인&lt;/a&gt;도 구경하세요. 어마어마한 양의 플러그인이 준비되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://github.com/sindresorhus/pure&quot;&gt;pure github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;커맨드라인 애플리케이션&lt;/h2&gt;

&lt;p&gt;이제 터미널이 이뻐졌으니 각종 도구를 설정해봅니다.&lt;/p&gt;

&lt;h3 id=&quot;vim&quot;&gt;vim&lt;/h3&gt;

&lt;p&gt;vim은 기본으로 설치된 터미널용 에디터로 GUI 환경의 에디터를 사용할 수 있는 macOS 환경에서는 일부 &lt;del&gt;고오오급&lt;/del&gt; 개발자를 제외하고는 잘 쓰이지 않습니다. 하지만 터미널 작업을 하다 보면 간단하게 수정할 파일이 있고 git 커밋메시지를 작성할 때 종종 사용하게 됩니다.&lt;/p&gt;

&lt;p&gt;기본으로 설정된 화면은 밋밋하기 그지 없기 때문에 강력한 기능의 플러그인을 설치해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내장된 vim대신 neovim을 설치합니다. neovim은 vim과 차이가 없어 보이는데 24bit True Color를 지원하고 오래된 vim 소스를 처음부터 다시 짜서 소스코드가 줄었다고 합니다. 저 같은 라이트 유저는 차이를 느끼진 못하지만 좋다고 해서 사용하고 있습니다. 그리고 테마에서 사용할 개발용 폰트를 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install neovim
brew tap caskroom/fonts
brew cask install font-hack-nerd-font&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기본 설치가 완료되었으면 터미널 기본 에디터로 vi대신 neovim을 사용하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 다음 항목을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;vimdiff&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nvim -d&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;EDITOR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/bin/nvim&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;플러그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;vim은 강력한 플러그인들이 많이 있는데 설치가 어렵고 어떤 게 좋은지 라이트 유저는 알 수가 없습니다. SpaceVim이라는 프로젝트는 가장 많은 사람들이 사용하는 플러그인을 자동으로 설치해줍니다. 약간 무거운 느낌이 있긴 하지만 설치가 간단하고 화면을 보는 순간 고오오급 개발자의 포스를 만들어주니 바로 설치해봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl -sLf https://spacevim.org/install.sh | bash&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되면 &lt;code class=&quot;highlighter-rouge&quot;&gt;vi&lt;/code&gt;를 실행합니다. 최초 실행 시 mode 설정을 물어보고 (&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;을 누릅니다) 자동으로 플러그인을 설치합니다. 플러그인이 많아서 시간이 꽤 걸립니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테마&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본 테마는 뭔가 칙칙한 느낌이 듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.SpaceVim.d/init.vim&lt;/code&gt; 파일에 Colorscheme 설정을 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;g:spacevim_colorscheme &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'onedark'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설정 파일을 수정하고 다시 시작하면 좀 더 나은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;폰트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;앗, 플러그인을 설치하고 vi를 실행하면 폰트가 깨져서 ?가 보이는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/nvim-question.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iTerm2에 개발 관련 폰트를 모은 NerdFont를 추가로 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/iterm-font.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iTerm을 실행하고 설정(&lt;code class=&quot;highlighter-rouge&quot;&gt;⌘&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;)창에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Profiles&lt;/code&gt; 항목을 선택하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Text&lt;/code&gt;탭을 선택합니다. Font항목에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Use a different font for non-ASCII text&lt;/code&gt;를 체크하고 다른 탭을 살짝 눌렀다 다시 돌아오면 Non-ASCII Font를 설정할 수 있습니다. 거기서 Knack Regular Nerd Font Complete를 선택하면 폰트가 이쁘게 나옵니다.&lt;/p&gt;

&lt;p&gt;이제 설정이 모두 완료되었으니 vim 공부만 하면 됩니다. :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://neovim.io/&quot;&gt;neovim 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://github.com/ryanoasis/nerd-fonts&quot;&gt;Nerd Font github&lt;/a&gt; / &lt;a href=&quot;https://github.com/SpaceVim/SpaceVim&quot;&gt;SpaceVim github&lt;/a&gt; / &lt;a href=&quot;http://spacevim.org/documentation/&quot;&gt;SpaceVim 설정문서&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;fzf&quot;&gt;fzf&lt;/h3&gt;

&lt;p&gt;fzf는 강력하고 엄청나게 빠른 fuzzy finder 도구입니다. 증분 검색을 통하여 원하는 파일이나 히스토리를 쉽고 빠르게 찾을 수 있게 해줍니다. 정확하게 원하는 값을 입력하지 않고 일부만 입력해도 실시간으로 검색 결과를 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/fzf-sample.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install fzf

&lt;span class=&quot;c&quot;&gt;# To install useful key bindings and fuzzy completion:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;brew --prefix&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/opt/fzf/install&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;brew 설치 후 install 명령어를 입력하면 몇 가지를 물어보는데 전부 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;를 누르면 됩니다. 설치가 완료되었으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정말 다양하게 사용할 수 있지만 여기선 가장 기본적인 기능만 살펴봅니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;하위 디렉토리 파일 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;히스토리 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;esc&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;하위 디렉토리 검색 후 이동&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/fzf-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;단축키 입력하고 글자를 몇 개 입력하면 금방 감이 옵니다. 취소는 &lt;code class=&quot;highlighter-rouge&quot;&gt;esc&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;fzf github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;fasd&quot;&gt;fasd&lt;/h3&gt;

&lt;p&gt;fasd는 사용빈도가 높은 파일 또는 디렉토리 검색을 편하게 해서 생산성을 향상시켜주는 도구입니다. 열어본 파일이나 이동한 디렉토리를 기억하고 우선순위를 정해서 빠르게 검색할 수 있게 도와줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install fasd&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  fasd
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;전부 완료되었으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.zshrc&lt;/code&gt;를 입력하여 설정을 다시 불러옵니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어를 사용하기 위해서는 일단 디렉토리를 좀 이동하고 파일도 열어보고 해야 합니다. 어느 정도 히스토리가 쌓이면 명령어를 입력해봅니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;디렉토리 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;파일 or 디렉토리 검색&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;디렉토리를 이동할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;z github&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tab&lt;/code&gt;과 같이 일부 검색어를 입력하고 tab을 눌러서 이동합니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/fasd-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;단순한 기능만큼 굉장히 자주, 유용하게 사용하는 도구입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/clvv/fasd&quot;&gt;fasd github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmux&quot;&gt;tmux&lt;/h3&gt;

&lt;p&gt;tmux는 터미널 멀티플렉서&lt;sub&gt;Terminal MUltipleXer&lt;/sub&gt;라고 합니다. 하나의 화면에서 창을 여러 개 만들 수 있고 가로 분할, 세로 분할 할 수도 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;어, 그거 iTerm에서 그냥 되는데요?&lt;/code&gt;라고 말씀하시면 딱히 할말은 없지만&lt;del&gt;반박 불가&lt;/del&gt;.. 알아두면 원격 리눅스 서버 환경에서 유용하게 쓸 수 있고 무엇보다 꽤나 있어보이는 화면을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install tmux&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin을 추가해줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  tmux
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;테마&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmux 역시 기본 테마는 너무 밋밋하기 때문에 &lt;a href=&quot;https://github.com/gpakosz/.tmux&quot;&gt;잘 만들어 놓은 테마&lt;/a&gt;를 가져다 씁니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/
git clone https://github.com/gpakosz/.tmux.git
ln -s -f .tmux/.tmux.conf
cp .tmux/.tmux.conf.local .&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예전에는 몰랐는데 요즘 tmux는 놀랍게도 마우스를 지원합니다. 터미널인데 마우스가 됩니다! 하단에 윈도우 탭을 누르면 바로바로 이동하고 분할 창&lt;sub&gt;pane&lt;/sub&gt;도 마우스를 누르는 창으로 포커스됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.tmux/.tmux.conf.local&lt;/code&gt;파일을 열고 맨 밑으로 이동해서 주석으로 되어 있는 설정을 해제해 줍니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# increase history size&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; -g &lt;span class=&quot;nb&quot;&gt;history&lt;/span&gt;-limit 10000

&lt;span class=&quot;c&quot;&gt;# start with mouse mode enabled&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; -g mouse on

&lt;span class=&quot;c&quot;&gt;# force Vi mode&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# really you should export VISUAL or EDITOR environment variable, see manual&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; -g status-keys vi
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; -g mode-keys vi&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;사용법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmux는 꽤 사용난이도가 높은 프로그램입니다. 자세한 내용을 여기서 다루기엔 양이 너무 많기 떄문에 따로 공부를 해야하고 여기서는 아주 기본적인 기능 몇 가지만 알아봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;세션&lt;sub&gt;session&lt;/sub&gt;&lt;/strong&gt; tmux가 관리하는 가장 큰 단위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;윈도우&lt;sub&gt;window&lt;/sub&gt;&lt;/strong&gt; 세션안에 존재하는 탭같은 단위&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;팬&lt;sub&gt;pane&lt;/sub&gt;&lt;/strong&gt; 윈도우 안에 가로 세로로 분할한 단위&lt;/li&gt;
&lt;/ul&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령어&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux &lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세션 생성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux attach&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;생성되어 있는 세션에 진입&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux ls&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세션 목록 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단축키&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;새 창 만들기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;tmux 환경에서 나오기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;~&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;해당 창으로 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;세로로 창을 나눔 (좌/우)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;가로로 창을 나눔 (위/아래)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;⌃&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;화살표&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;나뉘어진 창을 좌/우/위/아래로 움직임&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/tmux-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;아주 간단하게 살펴보았지만 사실 스크롤, 복사 등등 알아야 할 게 은근 많습니다. &lt;del&gt;안될꺼야..&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux github&lt;/a&gt; / &lt;a href=&quot;https://github.com/gpakosz/.tmux&quot;&gt;Oh My Tmux!&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmuxinator&quot;&gt;tmuxinator&lt;/h3&gt;

&lt;p&gt;tmux의 쓸모를 한층 더 높여주는 게 tmuxinator입니다. 단축키로 창을 만들고 화면을 분할하는 것을 설정파일로 해줍니다.&lt;/p&gt;

&lt;p&gt;예를 들면, 1번 윈도우는 webpack을 실행하고 2번 윈도우는 rails server를 실행하고 3번 윈도우는 log를 실행하게 설정할 수 있습니다. 요즘 프로젝트는 복잡하게 구성된 경우가 많아서 굉장히 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;tmuxinator는 ruby로 작성된 프로그램입니다. ruby를 최신 버전으로 업데이트하고 tmuxinator를 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;brew install ruby
gem install tmuxinator&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치가 완료되었으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;에 plugin과 alias를 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;plugins&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=(&lt;/span&gt;
  ...
  ...
  tmuxinator
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;alias &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;mux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tmuxinator&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;샘플&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간단하게 샘플을 하나 만들어 봅니다. 블로그를 작성하는 환경을 만드는데 1번창을 두개로 나눠서 위에는 jekyll을 실행하고 아래는 ngrok으로 서버를 외부로 오픈합니다. 2번 창은 post폴더를 vi로 오픈해보겠습니다.&lt;/p&gt;

&lt;p&gt;tmuxinator를 명령어가 너무 길어서 위에 설정에서 mux로 alias를 설정하였습니다. 새로 tmuxinator 프로젝트를 만들어보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;mux new jekyll&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;명령어를 실행하면 간단한 샘플이 포함된 jekyll 프로젝트 설정 파일이 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config/tmuxinator/jekyll.yml&lt;/code&gt; 만들어지고 자동으로 에디터가 열립니다. 설정 파일을 다음과 같이 작성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;s&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;jekyll&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;~/Workspace/github.com/subicura/subicura.github.io&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;windows&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;main-horizontal&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;panes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle exec jekyll serve --incremental&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ngrok http 4000&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;editor&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;vim _posts&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 프로젝트를 시작합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;s&quot;&gt;mux start jekyll&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-11-22-mac-os-development-environment-setup/mux-demo.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;샘플이라 약간 억지가 있어 보이는 구성이지만 스크립트 구성이 엄청나게 편하다는걸 알 수 있습니다. 전체 스크립트를 실행하고 intelliJ와 같은 IDE를 실행하게 구성할 수도 있습니다. 자세한 건 공식 홈페이지를 참고하세요.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmuxinator/tmuxinator&quot;&gt;tmuxinator github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;추천 애플리케이션&lt;/h2&gt;

&lt;p&gt;기본적인 프로그램 외에 사용하면 꽤 쓸만한 프로그램을 소개합니다.&lt;/p&gt;

&lt;h3 id=&quot;docker&quot;&gt;docker&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/docker-for-mac.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;따로 소개할 필요가 없을 정도로 유명한 가상화 프로그램입니다. MySQL, Redis와 같은 데이터베이스나 rails, php 개발환경까지 두루두루 사용하고 있습니다. 하나의 개발 피시에 여러버전의 MySQL이나 Redis를 설치하는 건 쉽지 않은데 docker를 사용하면 쉽고 간단하게 개발환경을 구축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;docker에 대한 자세한 내용은 &lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;여기&lt;/a&gt;서 확인하세요.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker 홈페이지&lt;/a&gt; / &lt;a href=&quot;https://www.docker.com/docker-mac&quot;&gt;Docker for mac download&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tig&quot;&gt;tig&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/tig.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;텍스트모드 git 인터페이스 프로그램입니다. git 자체 기능이 강력하긴 하지만 여러 로그를 편하게 보기는 쉽지 않습니다. tig를 사용하여 화살표 키와 &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;키를 잘 사용하면 쉽게 로그를 볼 수 있고 메인 화면에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;를 누르면 도움말을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jonas/tig&quot;&gt;tig github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;jq&quot;&gt;jq&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-11-22-mac-os-development-environment-setup/jq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JSON 결과를 이쁘게 보여주고 원하는 대로 편집할 수 있는 도구입니다. 간단하게 필터를 적용하여 원하는 항목만 볼 수 있고 특정 결과를 다른 형태로 변경할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stedolan.github.io/jq/&quot;&gt;jq github&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ngrok&quot;&gt;ngrok&lt;/h3&gt;

&lt;p&gt;로컬 서버를 외부로 터널링을 통해 오픈해주는 도구입니다. 보통 로컬에 개발 서버를 띄우면 외부에서 접근하기가 어려운데 ngrok을 이용하여 간단하게 오픈할 수 있습니다. 사용법도 간단합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ngrok.com/&quot;&gt;ngrok 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;asciinema&quot;&gt;asciinema&lt;/h3&gt;

&lt;p&gt;터미널을 &lt;strong&gt;텍스트&lt;/strong&gt;로 녹화하는 프로그램입니다. 영상으로 녹화하는 것보다 용량이 적고 품질도 훌륭한 편입니다. 제 블로그에서 자주 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://asciinema.org/&quot;&gt;asciinema 홈페이지&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;neofetch&quot;&gt;neofetch&lt;/h3&gt;

&lt;p&gt;지금 보고 있는 포스트 첫번째 이미지에서 사용한 프로그램입니다. 간단하게 시스템 상태를 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dylanaraps/neofetch&quot;&gt;neofetch github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;너무 오랫동안 블로깅을 못 하고 있어서 가볍게 &lt;del&gt;급하게&lt;/del&gt; 작성한 포스트입니다. 새로 산 맥북프로를 셋팅하고 설치 프로그램 목록을 정리하던 중에 우연찮게 몇몇 분들한테 터미널 설정에 대한 질문을 받으면서 환경설정에 대한 글을 쓰면 괜찮다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;커맨드라인 애플리케이션은 알면 알수록 새로운 것도 많고 개발자들 취향에 따라 설정이 조금씩 다르므로 가장 무난한 설정을 소개했고 대부분의 커스텀 설정은 수정하지 않았습니다. 설정이 굉장히 다양하므로 각 프로그램이 어떤 설정을 제공하는지는 꼭 한 번씩 보면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;최근 개발 모임이나 세미나에 참석해보면 맥북을 사용하시는 분들이 많고 개발자라면 계속해서 터미널을 사용하므로 아직 제대로 개발 환경을 구축하지 못한 분들에게 많은 도움이 되었으면 좋겠습니다. 그리고 괜찮은 도구 있으면 댓글로 추천해주세요! 더 좋은, 편안한 환경에서 개발하고 싶습니다.&lt;/p&gt;

&lt;p&gt;다른 &lt;del&gt;고오오급&lt;/del&gt;개발자들이 어떤 환경에서 작업하는지 궁금하다면 &lt;a href=&quot;https://usesthis.com&quot;&gt;usesthis.com&lt;/a&gt;에 인터뷰가 있으니 참고하시고 커스텀하게 변경한 환경설정 파일은 Dropbox나 Google Drive 등으로 파일을 링크(&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s&lt;/code&gt;)하여 백업하거나 &lt;a href=&quot;https://dotfiles.github.io/&quot;&gt;dotfiles&lt;/a&gt; 도구를 사용하여 백업하면 나중에 새로운 맥이 생겨도 동일한 환경을 빠르게 설정할 수 있습니다.&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Nov 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/11/22/mac-os-development-environment-setup.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/11/22/mac-os-development-environment-setup.html</guid>
        
        <category>Mac</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Development</category>
        
        <category>Environment</category>
        
        <category>Terminal</category>
        
        <category>zsh</category>
        
        <category>vi</category>
        
        <category>tmux</category>
        
        
        <category>Tool</category>
        
      </item>
    
      <item>
        <title>Docker Swarm을 이용한 쉽고 빠른 분산 서버 관리</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/docker-swarm.png&quot; alt=&quot;docker swarm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제가 일하고 있는 퍼플웍스에서는 여러 대의 서버에 다양한 애플리케이션을 설치하여 사용하고 있습니다. &lt;del&gt;아직도 미완성인&lt;/del&gt; &lt;a href=&quot;http://www.purpleworks.co.kr/&quot;&gt;홈페이지&lt;/a&gt; 를 비롯하여 &lt;a href=&quot;https://ko.wikipedia.org/wiki/LDAP&quot;&gt;LDAP&lt;/a&gt;, &lt;a href=&quot;https://about.gitlab.com/&quot;&gt;Gitlab&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;, &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;Docker Registry&lt;/a&gt;, &lt;a href=&quot;https://sensuapp.org/&quot;&gt;Sensu&lt;/a&gt;, &lt;a href=&quot;http://grafana.org/&quot;&gt;Grafana&lt;/a&gt;, DB와 같은 업무용 프로그램이 여기저기 설치되어 있고 개발 중인 서비스들의 테스트/스테이징 서버도 여러 대 있습니다.&lt;/p&gt;

&lt;p&gt;많은 서비스를 효율적으로 관리하기 위해 서버마다 역할을 부여하였는데 1번 서버는 CI, 2번 서버는 모니터링, 3번 서버는 웹, 4번 서버는 디비, 5번 서버는 큐 이런 식으로 서비스의 종류에 따라 서버를 구분하였습니다. 이런 방식은 효율적이고 정리가 잘된 것처럼 보였지만 서버가 늘어나고 컨테이너가 추가될 때마다 비효율적이라는 걸 알게 되었습니다.&lt;/p&gt;

&lt;p&gt;서버가 역할에 따라 나뉘어 있었기 때문에 특정 서버에 컨테이너가 몰리는 상황이 발생했고 역할이 모호한 애플리케이션의 경우는 어디에 설치할지 고민되고 설치하고도 찝찝한 경우가 많았습니다. 리소스가 여유 있는 서버로 컨테이너를 옮기고 싶어도 다른 컨테이너와 의존성이 있어 쉽게 못 옮기는 경우도 있고 IP, Port와 같은 설정 파일을 수정하는 것도 문제였습니다. 컨테이너는 굉장히 유연하여 확장이나 이동이 쉬운데 그런 장점을 거의 못 살리고 있었습니다.&lt;/p&gt;

&lt;p&gt;도커덕분에 애플리케이션 설치 자체가 굉장히 편해져 이런 작업은 사소해 보일 수 있지만, 인간의 욕심은 끝이 없고 더욱 격렬하게 아무것도 안 하고 싶기 때문에 컨테이너를 실행할 서버를 고르는 것부터 정보를 관리하는 것까지 모든 과정을 자동화하면 좋겠다는 생각을 했습니다.&lt;/p&gt;

&lt;p&gt;다행히 비슷한 고민을 미리한 고오급 개발자들이 있었고 이러한 작업을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Orchestration_(computing)&quot;&gt;오케스트레이션&lt;/a&gt;&lt;sub&gt;Orchestration&lt;/sub&gt;이라고 합니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;subserver-orchestrationsub&quot;&gt;서버 오케스트레이션 &lt;sub&gt;server orchestration&lt;/sub&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/container-orchestration.png&quot; alt=&quot;container orchestration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버 오케스트레이션이라는 용어는 모호한 의미를 가지고 있습니다. 간단하게 정의하면 &lt;strong&gt;여러 대의 서버와 여러 개의 서비스를 편리하게 관리해주는 작업&lt;/strong&gt;이라고 할 수 있고 실제로는 스케줄링&lt;sub&gt;scheduling&lt;/sub&gt;, 클러스터링&lt;sub&gt;clustering&lt;/sub&gt;, 서비스 디스커버리&lt;sub&gt;service discovery&lt;/sub&gt;, 로깅&lt;sub&gt;logging&lt;/sub&gt;, 모니터링&lt;sub&gt;monitoring&lt;/sub&gt; 같은 일을 합니다.&lt;/p&gt;

&lt;p&gt;그냥 여러 대의 서버를 편하게 관리하고 싶을 뿐인데 새로운 용어가 많이 등장합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄링&lt;/strong&gt;: 컨테이너를 적당한 서버에 배포해 주는 작업입니다. 툴에 따라서 지원하는 전략이 조금씩 다른데 여러 대의 서버 중 가장 할일 없는 서버에 배포하거나 그냥 차례대로 배포 또는 아예 랜덤하게 배포할 수도 있습니다. 컨테이너 개수를 여러 개로 늘리면 적당히 나눠서 배포하고 서버가 죽으면 실행 중이던 컨테이너를 다른 서버에 띄워주기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;클러스터링&lt;/strong&gt;: 여러 개의 서버를 하나의 서버처럼 사용할 수 있습니다. 클러스터에 새로운 서버를 추가할 수도 있고 제거할 수도 있습니다. 작게는 몇 개 안 되는 서버부터 많게는 수천 대의 서버를 하나의 클러스터로 만들 수 있습니다. 여기저기 흩어져 있는 컨테이너도 가상 네트워크를 이용하여 마치 같은 서버에 있는 것처럼 쉽게 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 디스커버리&lt;/strong&gt;: 말 그대로 서비스를 찾아주는 기능입니다. 클러스터 환경에서 컨테이너는 어느 서버에 생성될지 알 수 없고 다른 서버로 이동할 수도 있습니다. 따라서 컨테이너와 통신을 하기 위해서 어느 서버에서 실행중인지 알아야 하고 컨테이너가 생성되고 중지될 때 어딘가에 IP와 Port같은 정보를 업데이트해줘야 합니다. 키-벨류 스토리지에 정보를 저장할 수도 있고 내부 DNS 서버를 이용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로깅, 모니터링&lt;/strong&gt;: 여러 대의 서버를 관리하는 경우 로그와 서버 상태를 한곳에서 관리하는게 편합니다. 툴에서 직접 지원하는 경우도 있고 따로 프로그램을 설치해야 하는 경우도 있습니다. &lt;a href=&quot;https://www.elastic.co/kr/webinars/introduction-elk-stack&quot;&gt;ELK&lt;/a&gt;와 &lt;a href=&quot;https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;등 다양한 툴이 있습니다.&lt;/p&gt;

&lt;p&gt;오케스트레이션 툴은 서버를 중앙에서 관리하고 많은 것들을 자동화해주기 때문에 여러 대의 서버를 관리한다면 무조건 도입해야 할 굉장히 환상적인 방법이라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만, &lt;strong&gt;이렇게 좋은 게 있는지 알면서도 여러 가지 이유로 도입하기 어려운 게 현실&lt;/strong&gt;입니다. &lt;del&gt;시무룩&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;가장 큰 이유는 설치와 관리가 어렵다는 건데 보통 오케스트레이션 툴들은 수백-수천-수만 대의 엄청나게 많은 서버를 관리하기 위한 목적으로 만들어졌습니다. 기본적으로 설치와 관리가 꽤 어려운 편이고 일부 고오오오급 회사들이 아니면 도입하는 비용이 수작업으로 관리하는 비용보다 훨씬 큽니다. 툴에 대해 공부도 많이 해야 하고 뭔가 장애가 생기면 전체 서버에 문제가 생길 수 있어서 도입이 조심스러울 수밖에 없습니다. &lt;del&gt;이거 누가 도입하자고 했어?!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이런 상황에서 등장한 도커 스웜은 오케스트레이션 툴은 관리가 어렵고 사용하기 복잡하다는 편견을 완전히 바꿔놓았습니다. &lt;strong&gt;구축 비용이 거의 들지 않고 관리 또한 쉬우며 다양한 기능을 쉽게 제공하고 가볍게 사용&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;subcontainer-orchestration-toolsub&quot;&gt;컨테이너 오케스트레이션 툴 &lt;sub&gt;Container Orchestration Tool&lt;/sub&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/orchestration-tools.png&quot; alt=&quot;orchestration tools&quot; /&gt;&lt;/p&gt;

&lt;p&gt;본격적인 스웜 설명에 앞서 다른 컨테이너 오케스트레이션 툴에 대해 살펴보겠습니다. 다양한 툴이 다양한 특징을 가지고 만들어졌으니 가볍게 비교해보면 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;fleet-by-coreos&quot;&gt;fleet by CoreOS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/coreos/fleet&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★★★ / 사용법 ★★★★ / 기능 ★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CoreOS(Container OS)에 기본으로 내장되어 있는 &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt;의 cluster 버전&lt;/li&gt;
  &lt;li&gt;스케줄링 외에 특별한 기능이 없어 전체 서버에 무언가(agent류)를 bootstrap 하는 용도에 적당&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mesos-by-apache&quot;&gt;Mesos by Apache&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://mesos.apache.org/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★ / 사용법 ★★★ / 기능 ★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;역사와 전통의 범용적인 클러스터 툴로 Twitter, Airbnb, Apple, Uber등 다양한 곳에서 사용하여 안정성이 검증됨&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;Zookeeper&lt;/a&gt;를 기반으로 여러 대의 서버를 하나의 클러스터로 관리&lt;/li&gt;
  &lt;li&gt;설치와 관리가 어렵고 컨테이너를 사용하기 위해 추가적으로 &lt;a href=&quot;https://github.com/mesosphere/marathon&quot;&gt;Marathon&lt;/a&gt;이라는 프레임워크를 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetes-by-cloud-native-computing-foundation-with-google&quot;&gt;kubernetes by Cloud Native Computing Foundation (with google)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★ / 사용법 ★★★ / 기능 ★★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;15년 동안 쌓인 구글의 노하우로 만든 “Production-Grade Container Orchestration”으로 기능이 매우 매우 훌륭함&lt;/li&gt;
  &lt;li&gt;자체적으로 구축하려면 설치와 관리가 까다롭지만, &lt;a href=&quot;https://cloud.google.com/&quot;&gt;Google Cloud&lt;/a&gt;, &lt;a href=&quot;https://azure.microsoft.com&quot;&gt;Azure&lt;/a&gt;, &lt;a href=&quot;https://coreos.com/tectonic/&quot;&gt;Tectonic&lt;/a&gt;, &lt;a href=&quot;https://www.openshift.com/&quot;&gt;Openshift&lt;/a&gt;같은 플랫폼을 이용하면 조금 편해짐&lt;/li&gt;
  &lt;li&gt;구성 및 개념에 대한 이해가 필요하고 새로운 툴과 사용법을 익히는데 시간이 좀 걸림&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ec2-container-service-ecs-by-aws&quot;&gt;EC2 Container Service (ECS) by AWS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/ecs/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★★★ / 사용법 ★★★★ / 기능 ★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS를 사용 중이라면 쉽게 사용할 수 있고 개념도 간단함&lt;/li&gt;
  &lt;li&gt;기능이 매우 심플하지만 사실 대부분 시스템에서 복잡한 기능은 필요하지 않으므로 단순한 구성이라면 이 이상 편한툴은 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nomad-by-hashicorp&quot;&gt;Nomad by HashiCorp&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nomadproject.io/&quot;&gt;링크&lt;/a&gt; / 설치 및 관리 ★★★ / 사용법 ★★★★ / 기능 ★★★★&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;, &lt;a href=&quot;https://www.consul.io/&quot;&gt;Consul&lt;/a&gt;, &lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;, &lt;a href=&quot;https://www.vaultproject.io/&quot;&gt;Vault&lt;/a&gt;등을 만든 DevOps 장인 &lt;a href=&quot;https://www.hashicorp.com/&quot;&gt;HashiCorp&lt;/a&gt;의 제품&lt;/li&gt;
  &lt;li&gt;같은 회사의 Consul과 Vault를 연동해서 사용할 수 있고 기능은 다양하고 좋지만 반대로 공부할 게 많고 관리가 복잡할 수 있다는 뜻&lt;/li&gt;
  &lt;li&gt;도커외에 rkt, java 애플리케이션을 지원하고 커맨드라인 명령어는 직관적이고 매우 이쁘게 동작함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;그외&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rancher/cattle&quot;&gt;Cattle&lt;/a&gt; by rancher, &lt;a href=&quot;http://cockpit-project.org/&quot;&gt;Cockpit&lt;/a&gt;  by Redhat, &lt;a href=&quot;https://docs.cloudfoundry.org/concepts/diego/diego-architecture.html&quot;&gt;Diego&lt;/a&gt; by Cloud Foundry, &lt;a href=&quot;https://flynn.io/&quot;&gt;Flynn&lt;/a&gt;등등 다양한 툴이 있고 딱히 안 써봐서 정확한 내용을 모르지만 괜찮을 것 같음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;결론&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;적당한 규모(수십 대 이내)에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;swarm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;큰 규모의 클러스터에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;kubernetes&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;AWS에서 단순하게 사용한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECS&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;HashiCorp팬이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Nomad&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;도커 스웜 살펴보기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/swarmnado.gif&quot; alt=&quot;docker swarm mode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 본격적으로 스웜에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;도커 스웜의 등장&lt;/h3&gt;

&lt;p&gt;스웜은 도커와 별도로 개발되었지만 도커 1.12 버전부터 스웜 모드&lt;sub&gt;Swarm mode&lt;/sub&gt;라는 이름으로 합쳐졌습니다. 도커에 모오오오오든게 내장되어 다른 툴을 설치할 필요가 없고 도커 명령어와 compose를 그대로 사용할 수 있어 다른 툴에 비해 압도적으로 쉽고 편리합니다.&lt;/p&gt;

&lt;p&gt;기능이 단순하고 필요한 것만 구현되어 있어 세부적인 컨트롤은 어렵습니다. 갑툭튀한 것 같지만 꽤 오랫동안 개발되었고(2015년 1.0버전) 1,000개 노드에 50,000개 컨테이너도 문제없이 테스트하여 안전성이 검증되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;도커 스웜에서 사용하는 용어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;스웜&lt;sub&gt;swarm&lt;/sub&gt;&lt;/strong&gt;: 직역하면 떼, 군중이라는 뜻을 가지고 있습니다. 도커 1.12버전에서 스웜이 스웜 모드로 바뀌었지만 그냥 스웜이라고도 하는듯 합니다. 스웜 클러스터 자체도 스웜이라고 합니다. (스웜을 만들다. 스웜에 가입하다. = 클러스터를 만들다. 클러스터에 가입하다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드&lt;sub&gt;node&lt;/sub&gt;&lt;/strong&gt;: 스웜 클러스터에 속한 도커 서버의 단위입니다. 보통 한 서버에 하나의 도커데몬만 실행하므로 서버가 곧 노드라고 이해하면 됩니다. 매니저 노드와 워커 노드가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;매니저노드&lt;sub&gt;manager node&lt;/sub&gt;&lt;/strong&gt;: 스웜 클러스터 상태를 관리하는 노드입니다. 매니저 노드는 곧 워커노드가 될 수 있고 스웜 명령어는 매니저 노드에서만 실행됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;워커노드&lt;sub&gt;worker node&lt;/sub&gt;&lt;/strong&gt;: 매니저 노드의 명령을 받아 컨테이너를 생성하고 상태를 체크하는 노드입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스&lt;sub&gt;service&lt;/sub&gt;&lt;/strong&gt;: 기본적인 배포 단위입니다. 하나의 서비스는 하나의 이미지를 기반으로 생성하고 동일한 컨테이너를 한개 이상 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스크&lt;sub&gt;task&lt;/sub&gt;&lt;/strong&gt;: 컨테이너 배포 단위입니다. 하나의 서비스는 여러개의 테스크를 실행할 수 있고 각각의 테스크가 컨테이너를 관리합니다.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;도커 스웜이 제공하는 기능&lt;/h3&gt;

&lt;p&gt;Docker 1.13을 기준으로 어떤 기능을 제공하는지 하나하나 살펴봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄링 &lt;sub&gt;scheduling&lt;/sub&gt;&lt;/strong&gt;: 서비스를 만들면 컨테이너를 워커노드에 배포합니다. 현재는 균등하게 배포&lt;sub&gt;spread&lt;/sub&gt;하는 방식만 지원하며 추후 다른 배포 전략이 추가될 예정입니다.
노드에 라벨을 지정하여 특정 노드에만 배포할 수 있고 모든 서버에 한 대씩 배포하는 기능(Global)도 제공합니다. 서비스별로 CPU, Memory 사용량을 미리 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;고가용성 &lt;sub&gt;High Available&lt;/sub&gt;&lt;/strong&gt;: &lt;a href=&quot;https://raft.github.io/&quot;&gt;Raft 알고리즘&lt;/a&gt;을 이용하여 여러 개의 매니저노드를 운영할 수 있습니다. 3대를 사용하면 1대가 죽어도 클러스터는 정상적으로 동작하며 매니저 노드를 지정하는 방법은 간단하므로 쉽게 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;멀티 호스트 네트워크 &lt;sub&gt;Multi Host Network&lt;/sub&gt;&lt;/strong&gt;: Overlay network로 불리는 SDN(Software defined networks)를 지원하여 여러 노드에 분산된 컨테이너를 하나의 네트워크로 묶을수 있습니다. 컨테이너마다 독립된 IP가 생기고 서로 다른 노드에 있어도 할당된 IP로 통신할 수 있습니다. (호스트 IP를 몰라도 됩니다!)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서비스 디스커버리 &lt;sub&gt;Service Discovery&lt;/sub&gt;&lt;/strong&gt;: 서비스 디스커버리를 위한 자체 DNS 서버를 가지고 있습니다. 컨테이너를 생성하면 서비스명과 동일한 도메인을 등록하고 컨테이너가 멈추면 도메인을 제거합니다. 멀티 호스트 네트워크를 사용하면 여러 노드에 분산된 컨테이너가 같은 네트워크로 묶이므로 서비스 이름으로 바로 접근할 수 있습니다. Consul이나 etcd, zookeeper와 같은 외부 서비스를 사용하지 않고 어떠한 추가 작업도 필요 없습니다. 스웜이 알아서 다 해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순차적 업데이트 &lt;sub&gt;Rolling Update&lt;/sub&gt;&lt;/strong&gt;: 서비스를 새로운 이미지로 업데이트하는 경우 하나 하나 차례대로 업데이트합니다. 동시에 업데이트하는 작업의 개수와 업데이트 간격 시간을 조정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상태 체크 &lt;sub&gt;Health Check&lt;/sub&gt;&lt;/strong&gt;: 서비스가 정상적으로 실행되었는지 확인하기 위해 컨테이너 실행 여부 뿐 특정 쉘 스크립크가 정상으로 실행됐는지 여부를 추가로 체크할 수 있습니다. 컨테이너 실행 여부로만 체크할 경우 아직 서버가 실행 되지 않아 접속시 오류가 날 수 있는 미묘한 타이밍을 잡는데 효과적입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;비밀값 저장 &lt;sub&gt;Secret Management&lt;/sub&gt;&lt;/strong&gt;: 비밀번호를 스웜 어딘가에 생성하고 컨테이너에서 읽을 수 있습니다. 비밀 값을 관리하기 위한 외부 서비스를 설치하지 않고 쉽게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로깅 &lt;sub&gt;Logging&lt;/sub&gt;&lt;/strong&gt;: 같은 노드에서 실행 중인 컨테이너뿐 아니라 다른 노드에서 실행 중인 서비스의 로그를 한곳에서 볼 수 있습니다. 특정 서비스의 로그를 보려면 어느 노드에서 실행 중인지 알필요도 없고 일일이 접속하지 않아도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;모니터링 &lt;sub&gt;Monitoring&lt;/sub&gt;&lt;/strong&gt;: 리소스 모니터링 기능은 제공하지 않습니다. 3rd party 서비스(&lt;a href=&quot;https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;, &lt;a href=&quot;http://grafana.org/&quot;&gt;grafana&lt;/a&gt;)를 사용해야 합니다. 설치는 쉽지만 은근 귀츈…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;크론, 반복작업 &lt;sub&gt;Cron&lt;/sub&gt;&lt;/strong&gt;: 크론, 반복작업도 알아서 구현해야 합니다. 여러 가지 방식으로 해결할 수 있겠지만 직접 제공하지 않아 아쉬운 부분입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;스웜실습&lt;/h2&gt;

&lt;p&gt;본격적으로 스웜 클러스터를 만들고 여러 가지 서비스를 생성해보면서 도커 스웜에 빠져보겠습니다. 전체적인 내용은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;준비&lt;/li&gt;
  &lt;li&gt;스웜 클러스터 만들기&lt;/li&gt;
  &lt;li&gt;기본 웹 애플리케이션 서비스&lt;/li&gt;
  &lt;li&gt;방문자 수 체크 애플리케이션 (with redis)&lt;/li&gt;
  &lt;li&gt;비밀키 조회 애플리케이션&lt;/li&gt;
  &lt;li&gt;Traefik 리버스 프록시 서버&lt;/li&gt;
  &lt;li&gt;스웜 서버 모니터링&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;준비&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;를 이용하여 3개의 &lt;a href=&quot;https://coreos.com/os/docs/latest&quot;&gt;CoreOS(Container Linux)&lt;/a&gt;가상머신을 만듭니다. 각각 1 CPU와 1G Memory를 할당하고 매니저 노드 하나와 워커 노드 2개를 설정하여 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/create-virtual-machine.png&quot; alt=&quot;virtual machines&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;core-01 (manager) / 172.17.8.101 / 1 cpu / 1G memory&lt;/li&gt;
  &lt;li&gt;core-02 (worker) / 172.17.8.102 / 1 cpu / 1G memory&lt;/li&gt;
  &lt;li&gt;core-03 (worker) / 172.17.8.103 / 1 cpu / 1G memory&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vagrant는 VirtualBox, VMWare, Parallels같은 가상머신을 쉽게 만들고 관리해주는 툴입니다. CoreOS는 도커가 내장된 가벼운 OS입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;가상머신을 만드는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;virtual box 설치 &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;다운로드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Vagrant 설치 &lt;a href=&quot;https://www.vagrantup.com/downloads.html&quot;&gt;다운로드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cogitatio/vagrant-hostsupdater&quot;&gt;vagrant-hostsupdater&lt;/a&gt; plugin 설치 
 &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant plugin install vagrant-hostsupdater&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데모 파일 다운로드 &lt;a href=&quot;https://github.com/subicura/docker-swarm-demo&quot;&gt;GitHub - docker swarm demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;가상머신 생성
데모 디렉토리에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant up&lt;/code&gt; 명령어 실행 -&amp;gt; 자동으로 생성!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;가상머신이 정상적으로 생성되었는지 확인하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant status&lt;/code&gt;, 가상머신을 삭제하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant destroy&lt;/code&gt; 를 실행합니다. 가상머신에 접속하는 명령어는  &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant ssh [가상머신이름]&lt;/code&gt;입니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/vagrant-up.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;vagrant up&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;스웜 클러스터 만들기&lt;/h3&gt;

&lt;p&gt;가상머신이 정상적으로 생성되었으면 스웜 클러스터를 만들어보겠습니다. 스웜 클러스터는 매니저 노드를 먼저 만들고 매니저 노드가 생성한 토큰을 가지고 워커 노드에서 매니저 노드로 접속하면 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, &lt;code class=&quot;highlighter-rouge&quot;&gt;core-01&lt;/code&gt;서버를 매니저 노드로 설정합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;swarm init&lt;/code&gt;명령어를 사용합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# vagrant ssh core-01&lt;/span&gt;
docker swarm init --advertise-addr 172.17.8.101&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Swarm initialized: current node &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;gjm2fxwcx29ha4rfzkw3zskvt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; is now a manager.

To add a worker to this swarm, run the following &lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;:

    docker swarm join &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    --token SWMTKN-1-1la23f7y6y8joqxz27hac4j79yffyixcp15tjtlrnei14wwd1t-5tlmx4q9fm46drjzzd95g1l4q &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    172.17.8.101:2377

To add a manager to this swarm, run &lt;span class=&quot;s1&quot;&gt;'docker swarm join-token manager'&lt;/span&gt; and follow the instructions.&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;순식간에 매니저 노드가 생성되었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;swarm init&lt;/code&gt;명령어를 실행하면 친절하게 워커 노드에서 실행할 명령어를 알려줍니다. &lt;del&gt;친절한도커씨&lt;/del&gt; 명령어를 그대로 복사하여 2, 3번 서버에서 각각 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# vagrant ssh core-02&lt;/span&gt;
docker swarm join &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    --token SWMTKN-1-1la23f7y6y8joqxz27hac4j79yffyixcp15tjtlrnei14wwd1t-5tlmx4q9fm46drjzzd95g1l4q &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    172.17.8.101:2377&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;This node joined a swarm as a worker.&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;워커 노드가 정상적으로 만들어졌는지 매니저 노드에서 확인합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker node ls&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
gjm2fxwcx29ha4rfzkw3zskvt &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  core-01   Ready   Active        Leader
mu6l92w2dzjmsbucvar1bl9mg    core-03   Ready   Active
q5pa26ik11g9surws03quvrsk    core-02   Ready   Active&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;명령어 3줄로 클러스터가 생성되었습니다. 도커 외에 아무것도 설치하지 않았고 어떤 agent도 실행하지 않았습니다. 이렇게 쉽게 생성되는 클러스터 보셨나요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;매니저 노드가 관리하는 정보는  &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/swarm&lt;/code&gt;에 저장됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/swarm-cluster.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;init swarm cluster&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-9&quot;&gt;기본 웹 애플리케이션&lt;/h3&gt;

&lt;p&gt;클러스터가 생성되었으니 간단한 웹 애플리케이션 서비스를 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;서비스를 생성하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;service create&lt;/code&gt;명령어를 이용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어와 아주 유사합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name whoami &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -p 4567:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/whoami:1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;beepr6q5kdm724vdvgmb2awxg&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;subicura/whoami:1&lt;/code&gt; 이미지는 서버의 hostname을 출력하는 단순한 웹 애플리케이션입니다. 서비스의 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;whoami&lt;/code&gt; 로 지정했고 4567 포트를 오픈하였습니다.&lt;/p&gt;

&lt;p&gt;서비스가 잘 생성되었는지 &lt;code class=&quot;highlighter-rouge&quot;&gt;service ls&lt;/code&gt;명령어로 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ls&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME    MODE        REPLICAS  IMAGE                               
beepr6q5kdm7  whoami  replicated  0/1       subicura/whoami:1 &lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;whoami&lt;/code&gt;라는 서비스가 보입니다. 아직 컨테이너가 생성되지 않아 REPLICAS 상태가 &lt;code class=&quot;highlighter-rouge&quot;&gt;0/1&lt;/code&gt;입니다. 좀 더 상세한 상태를 확인하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;service ps&lt;/code&gt;명령어를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps whoami&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME      IMAGE              NODE     DESIRED STATE  CURRENT STATE            ERROR  PORTS
wnt5m97ci36t  whoami.1  subicura/whoami:1  core-01  Running        Preparing 7 seconds ago&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;서비스의 상태와 어떤 노드에서 실행 중인지를 상세하게 확인할 수 있습니다. 현재 상태가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Preparing&lt;/code&gt;인걸 보니 이미지를 다운 받는 중인 것 같습니다. 조금만 기다리고 컨테이너가 실행되면 상태가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Running&lt;/code&gt;으로 바뀝니다.&lt;/p&gt;

&lt;p&gt;정상적으로 서비스가 실행되었는지 HTTP 요청으로 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
cfb152786b87&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;와우! 첫번째 서비스를 성공적으로 생성하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;core-01&lt;/code&gt;에서 테스트를 했는데 다른 서버도 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-02:4567
curl core-03:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
cfb152786b87
cfb152786b87&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;분명 컨테이너는  &lt;code class=&quot;highlighter-rouge&quot;&gt;core-01&lt;/code&gt;노드에서 실행중인데 모든 노드에서 정상적으로 응답하고 있습니다. 어떻게 된일일까요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/basic-web-application.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;basic web application&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;ingress-network&quot;&gt;Ingress network&lt;/h3&gt;

&lt;p&gt;도커 스웜은 서비스를 외부에 쉽게 노출하기 위해 모든 노드가 &lt;a href=&quot;https://docs.docker.com/engine/swarm/ingress/&quot;&gt;ingress&lt;/a&gt;라는 가상 네트워크에 속해있습니다. ingress는 routing mesh라는 재미있는 개념을 가지고 있는데 이 개념은 서비스가 포트를 오픈할 경우 모오오든 노드에 포트가 오픈되고 어떤 노드에 요청을 보내도 실행 중인 컨테이너에 자동으로 전달해줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ingress는 (어떤 장소에) 들어감, 입장이라는 뜻을 가지고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/ingress-network.png&quot; alt=&quot;ingress network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 예제에서는 4567 포트를 오픈했기 때문에 3개의 노드 전체에 4567 포트가 오픈되었고 어디에서 테스트를 하든 간에 core-01노드에 실행된 컨테이너로 요청이 전달됩니다. 컨테이너가 여러 개라면 내부 로드밸런서를 이용하여 여러 개의 컨테이너로 분산처리됩니다.&lt;/p&gt;

&lt;p&gt;뭔가 어색한 개념이라고 생각할 수 있지만, 어느 서버에 컨테이너가 실행 중인지 알 필요 없이 외부에서 그 어떤 방법보다 쉽게 접근할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;실제 운영시에는 외부에 nginx 또는 haproxy같은 로드발란서를 두고 전체 스웜 노드를 바라보게 설정할 수 있습니다. &lt;a href=&quot;https://docs.docker.com/engine/swarm/ingress/#/configure-an-external-load-balancer&quot;&gt;관련링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;replication&quot;&gt;서비스 복제 replication&lt;/h3&gt;

&lt;p&gt;앞에서 생성한 웹 애플리케이션에 부하가 발생했다고 가정하고 컨테이너를 5개로 늘려보겠습니다. 노드가 3개인데 컨테이너를 5개로 늘리면 서버 한 개에 2개의 컨테이너가 생성됩니다. 어차피 각각은 독립된 컨테이너이기 때문에 여러 개를 생성해도 상관없고 ingress 네트워크가 알아서 요청을 분산처리해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/replication.png&quot; alt=&quot;service replication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;service scale&lt;/code&gt;명령어를 이용하여 서비스 개수를 늘려보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service scale &lt;span class=&quot;nv&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;whoami scaled to 5 &lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serivice ps&lt;/code&gt;명령어를 이용하여 상태를 확인합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps whoami&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME      IMAGE              NODE     DESIRED STATE  CURRENT STATE            ERROR  PORTS
z5mcfb0lcizi  whoami.1  subicura/whoami:1  core-01  Running        Running 11 minutes ago
nwkduapf1kvk  whoami.2  subicura/whoami:1  core-03  Running        Preparing 4 seconds ago
vhxmipcdht6c  whoami.3  subicura/whoami:1  core-03  Running        Preparing 4 seconds ago
mntns383mnhz  whoami.4  subicura/whoami:1  core-01  Running        Running 4 seconds ago
xga086cubnj3  whoami.5  subicura/whoami:1  core-02  Running        Preparing 4 seconds ago&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;처음 컨테이너를 생성하는 노드에서 이미지를 다운받는동안 Pending인 상태가 보이고 조금 기다리면 모두 실행됩니다. 이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567
curl core-01:4567

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
7590556fb196
7d5e26679eb8
a2c04acee702
88498091561a
e970ff9ed9c6
7590556fb196&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;5개의 컨테이너에 아주 이쁘게 요청이 분산되었습니다. 아무런 설정 없이 ingress 네트워크가 알아서 로드 밸런서 역할을 해주고 있습니다. Nginx나 haproxy같은 설정이 필요 없습니다. 너무 편하지 않나요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/replication.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;replication&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;healthcheck&quot;&gt;HEALTHCHECK&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/healthcheck.png&quot; alt=&quot;container running status&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스웜은 컨테이너가 실행되면 ingress에서 해당 컨테이너로 요청을 보내기 시작하는데 웹 서버가 부팅되는 동안 문제가 있습니다. 바로 위에 시연 리플레이를 보면 curl 테스트를 하는 도중 에러가 발생하는 걸 확인할 수 있습니다. ingress는 컨테이너가 실행되면 요청을 보내기 때문에 문제가 없을거라고 생각할 수 있지만 컨테이너가 실행되고 웹 서버가 완전히 실행되기 전에 요청을 보내면 서버를 찾을 수 없다는 메시지를 볼 수 있고 이러한 문제를 해결하기 위해 좀 더 자세한 상태 체크 방식이 필요하게 되었습니다.&lt;/p&gt;

&lt;p&gt;도커 1.12버전에서  &lt;code class=&quot;highlighter-rouge&quot;&gt;HEALTHCHECK&lt;/code&gt;명령어가 추가되었고 쉘 스크립트를 작성하여 좀 더 정확한 상태를 체크 할 수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM ruby:2.3-alpine
MAINTAINER subicura@subicura.com
COPY Gemfile* /usr/src/app/
WORKDIR /usr/src/app
RUN bundle install
COPY . /usr/src/app
EXPOSE 4567
HEALTHCHECK --interval=10s CMD wget -qO- localhost:4567
CMD bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/57557d89ebc64005988e260515413b2a.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;아주 익숙한 도커파일샘플에 HEALTHCHECK 명령어를 추가했습니다. HEALTHCHECK 부분을 보면 10초마다 wget을 이용하여 4567 포트를 체크하는 걸 볼 수 있습니다. 스크립트(wget)가 0을 리턴하면 정상이라고 판단하고 그때서야 요청을 보내게 됩니다.&lt;/p&gt;

&lt;p&gt;처음 테스트로 생성한 서비스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;subicura/whoami:2&lt;/code&gt;이미지로 업데이트 해보겠습니다. 버전 1과 차이점은 HEALTHCHECK 유무입니다. HEALTHCHECK 옵션이 없다면 업데이트하는 동안 순간적으로 에러가 발생할 수 있는데 그런 문제를 방지해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;service update&lt;/code&gt;명령어를 이용하여 서비스를 업데이트합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service update &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--image subicura/whoami:2 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
whoami&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;whoami scaled to 5&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;service ps&lt;/code&gt;명령어로 업데이트 상태를 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service ps whoami&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;ID            NAME          IMAGE              NODE     DESIRED STATE  CURRENT STATE           ERROR  PORTS
kv2jddl0bsfw  whoami.1      subicura/whoami:2  core-01  Ready          Ready 2 seconds ago
z5mcfb0lcizi   &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt; whoami.1  subicura/whoami:1  core-01  Shutdown       Running 11 seconds ago
nwkduapf1kvk  whoami.2      subicura/whoami:1  core-03  Running        Running 9 minutes ago
vhxmipcdht6c  whoami.3      subicura/whoami:1  core-03  Running        Running 9 minutes ago
mntns383mnhz  whoami.4      subicura/whoami:1  core-01  Running        Running 11 minutes ago
xga086cubnj3  whoami.5      subicura/whoami:1  core-02  Running        Running 9 minutes ago&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;하나씩 하나씩 이쁘게 업데이트되는 과정을 볼 수 있고 접속 테스트를 하면 문제 없이 업데이트되는걸 확인 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/healthcheck.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;service update&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;방문자수 체크 웹 애플리케이션&lt;/h3&gt;

&lt;p&gt;아주아주 간단한 실습에 이어 조금 복잡한 구성을 살펴봅니다. 실제 세상에서는 웹 애플리케이션이 혼자 실행되는 경우가 거의 없죠. redis와 함께 웹 애플리케이션을 실행하고 서버에 접속할 때마다 카운트를 +1 하는 서비스를 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저, 웹 애플리케이션과 redis가 통신할 수 있는 오버레이 네트워크를 만듭니다. 오버레이 네트워크를 사용하면 redis는 외부에 포트를 오픈하지 않아도 되고 웹 애플리케이션과 다른 노드에 있어도 같은 서버에 있는 것처럼 통신할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network.png&quot; alt=&quot;overlay network&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;network create&lt;/code&gt;명령어로 오버레이 네트워크를 생성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network create --attachable &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --driver overlay &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  backend&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;k7ayhk5hqbxnk8zbb959txh6h  &lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;잘 생성되었는지 &lt;code class=&quot;highlighter-rouge&quot;&gt;network ls&lt;/code&gt;명령어로 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network ls&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;NETWORK ID          NAME                DRIVER              SCOPE
k7ayhk5hqbxn        backend             overlay             swarm
c420312e4c9b        bridge              bridge              &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;c3ef285ed639        docker_gwbridge     bridge              &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;244840dc44fd        host                host                &lt;span class=&quot;nb&quot;&gt;local
&lt;/span&gt;4biz947vsmez        ingress             overlay             swarm
f41f0c773519        none                null                &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;backend라는 이름의 오버레이 네트워크가 생성되었습니다. 그 외에 네트워크는 기본으로 생성되는 네트워크들입니다. 이제 redis를 backend네트워크에 생성하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network-redis.png&quot; alt=&quot;redis with overlay network&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  redis&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;cjqrmjqfvj8zyr7k9skih01g4&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--network&lt;/code&gt; 옵션으로 어느 네트워크에 속할지 정의하였습니다. backend 네트워크에 속한 redis 서비스는 외부 네트워크에서는 접근할 수 없고 backend 네트워크 상에서 원래 포트인 6379로 접속할 수 있습니다.&lt;/p&gt;

&lt;p&gt;redis 서비스가 제대로 생성되었다면 telnet명령어로 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run --rm -it &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  alpine &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  telnet redis 6379

&lt;span class=&quot;c&quot;&gt;# test&lt;/span&gt;
KEYS &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
SET hello world
GET hello
DEL hello
QUIT&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;외부 네트워크에서는 redis 서버에 접근할 수 없으므로 접속 테스트용 컨테이너를 생성하였습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;--network&lt;/code&gt;옵션으로 backend 네트워크에 접속하였고 redis 서비스의 이름이 곧 도메인명이므로 바로 접속할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스웜은 서비스가 실행되면 내부 DNS에 자동으로 도메인 정보를 등록합니다. 따로 IP를 관리할 필요 없이 서비스명으로 접근할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 방문자 수를 체크하는 웹 애플리케이션 서비스를 생성해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/overlay-network-redis-counter.png&quot; alt=&quot;web application + redis&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name counter &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --replicas 3 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;REDIS_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -p 4568:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/counter&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;nlq75mhritr3hj4tibm8ka9d8&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;redis 서버와 통신해야 하므로 backend 네트워크를 지정했고 &lt;code class=&quot;highlighter-rouge&quot;&gt;--replicas&lt;/code&gt;옵션을 이용하여 3개를 생성하도록 했습니다. 외부의 4568 포트로 접근할 수 있도록 포트를 오픈 했고 redis 서버의 도메인명을 환경변수로 전달했습니다.&lt;/p&gt;

&lt;p&gt;이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 1
6705a6272a4a &amp;gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 1
6705a6272a4a &amp;gt; 1
92b471d0d741 &amp;gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 2
6705a6272a4a &amp;gt; 1
92b471d0d741 &amp;gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 2
6705a6272a4a &amp;gt; 2
92b471d0d741 &amp;gt; 1

curl core-01:4568

&lt;span class=&quot;c&quot;&gt;#output&lt;/span&gt;
50bec9ce8874 &amp;gt; 2
6705a6272a4a &amp;gt; 2
92b471d0d741 &amp;gt; 2&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;웹 애플리케이션 서버와 redis가 backend오버레이 네트워크를 통해 연결되었고 ingress 네트워크가 3개의 웹 컨테이너에 이쁘게 부하를 분산하였습니다.&lt;/p&gt;

&lt;p&gt;스웜은 서로 통신이 필요한 서비스를 같은 이름의 오버레이 네트워크로 묶고 내부 DNS 서버를 이용하여 접근할 수 있습니다. 여러 개의 네트워크를 쉽게 만들 수 있고 하나의 서비스는 여러 개의 네트워크에 속할 수 있습니다. 모든 것은 스웜이 알아서 하고 관리자는 네트워크와 서비스만 잘 만들면 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;내부 DNS에서 counter의 IP는 10.0.0.4로 3개 컨테이너의 로드 벨런서용 IP를 가리키고 있습니다. 실제 각각의 IP는 tasks.counter의 A Record에 기록되어 있고 10.0.0.5~7을 가지고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/overlay.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;service with overlay&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;비밀키 조회 애플리케이션&lt;/h3&gt;

&lt;p&gt;이번에는 1.13에 추가된 비밀키 관리 기능을 이용해보겠습니다. 먼저 비밀키를 생성합니다. 파일 또는 파이프를 이용한 stdin입력만 가능합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;this is my password!&quot;&lt;/span&gt; | docker secret create my-password -&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;8rsw3eu74xea4q2e8mnhuw6lu&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;my-passsword&lt;/code&gt;라는 이름의 비밀키에 &lt;code class=&quot;highlighter-rouge&quot;&gt;this is my password!&lt;/code&gt;라는 내용을 저장하였습니다. 이제 이 키를 사용할 서비스를 하나 생성하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name secret &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --secret my-password &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -p 4569:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;SECRET_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/run/secrets/my-password &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/secret&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;nmyk5647bv4mfneafwhpg7o4t&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--secret&lt;/code&gt;옵션으로 어떤 키를 사용할지 지정하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/run/secrest&lt;/code&gt;디렉토리 밑에 키 이름의 파일로 마운트 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;subicura/secret&lt;/code&gt; 이미지는 파일의 내용을 출력해주는 웹 애플리케이션으로 4569포트로 오픈하였습니다.&lt;/p&gt;

&lt;p&gt;잘 동작하는지 테스트해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl core-01:4569&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;this is my password!&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;아주 잘 동작합니다. 도커를 이용하여 서비스를 구축하면 패스워드 정보를 어떻게 할지 고민일 때가 있는데 아주 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/secret.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker secre&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;traefik---&quot;&gt;Traefik 리버스 프록시 서버&lt;/h3&gt;

&lt;p&gt;스웜은 매니저 노드에서 모든 서비스를 관리할 수 있고 서비스가 생성된 것을 체크하면 무언가를 자동화할 수 있습니다. &lt;a href=&quot;https://traefik.io/&quot;&gt;Traefik&lt;/a&gt;은 이러한 아이디어를 이용해 웹 애플리케이션이 생성되면 자동으로 도메인을 만들고 내부 서비스로 연결해줍니다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;whoami&lt;/code&gt;라는 서비스를 만들면 &lt;code class=&quot;highlighter-rouge&quot;&gt;whoami.local.dev&lt;/code&gt;도메인으로 접속할 수 있게 해주고 &lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;라는 서비스를 만들면 &lt;code class=&quot;highlighter-rouge&quot;&gt;counter.local.dev&lt;/code&gt;도메인으로 접속할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;테스트를 위해 도메인 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;에 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;172.17.8.101 portainer.local.dev counter.local.dev&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;프록시로 연결하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;frontend&lt;/code&gt;라는 네트워크를 생성합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker network create --driver overlay frontend&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;traefik&lt;/code&gt;서비스를 frontend네트워크에 연결합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name traefik &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --constraint &lt;span class=&quot;s1&quot;&gt;'node.role == manager'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -p 80:80 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -p 8080:8080 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --mount &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt;,source&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/run/docker.sock,target&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/run/docker.sock &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  traefik &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --docker &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --docker.swarmmode &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --docker.domain&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;local.dev &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --docker.watch &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --web&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--constraint&lt;/code&gt; 옵션을 이용하여 매니저 노드에서 실행하게 배포를 제한하였습니다. 스웜 서비스 정보를 얻기 위해서는 반드시 매니저 노드에서 실행되어야 합니다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 이용해 호스트의 도커 소켓을 마운트 하였습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -v&lt;/code&gt; 옵션과 유사한데 service를 만들 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 사용합니다. 80포트는 실제 웹 서비스를 제공하기 위해 사용할 포트고 8080은 관리자용 포트입니다.&lt;/p&gt;

&lt;p&gt;관리자 페이지에 접속해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/traefik.png&quot; alt=&quot;traefik dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;뭔가 그럴싸한 관리자 화면이 보입니다. 아직 아무것도 실행하지 않아 휑한 모습입니다. &lt;a href=&quot;http://portainer.io/&quot;&gt;portainer&lt;/a&gt; 웹 애플리케이션을 실행하여 자동으로 연결해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service create --name portainer &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --label traefik.port&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;9000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --constraint &lt;span class=&quot;s1&quot;&gt;'node.role == manager'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --mount &lt;span class=&quot;s2&quot;&gt;&quot;type=bind,source=/var/run/docker.sock,target=/var/run/docker.sock&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  portainer/portainer&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;traefik과 접속할 수 있도록 frontend네트워크에 연결했고 &lt;code class=&quot;highlighter-rouge&quot;&gt;--label&lt;/code&gt;옵션으로 내부적으로 사용하는 웹 포트를 알려주었습니다. traefik은 &lt;code class=&quot;highlighter-rouge&quot;&gt;traefik.port&lt;/code&gt;라벨의 값을 읽어 해당 포트로 리버스 프록시를 연결합니다. portainer는 스웜을 관리해주는 툴이기 때문에 매니저 노드에 실행하도록 했습니다.&lt;/p&gt;

&lt;p&gt;서비스 이름을 portainer로 했기 때문에 서비스가 실행되면 traefik서비스가 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;portainer.local.dev&lt;/code&gt;도메인 정보를 생성하고 portainer컨테이너의 9000번 포트로 연결합니다. 서비스를 생성하고 잠시 기다리면 프록시 설정이 자동으로 완료됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/traefik-portainer.png&quot; alt=&quot;traefik dashboard - portainer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;traefik 관리자 화면에 portainer가 등록된 모습이 보입니다! 이제 실제로 &lt;code class=&quot;highlighter-rouge&quot;&gt;portainer.local.dev&lt;/code&gt;에 접속해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-1.png&quot; alt=&quot;portainer dashboard&quot; /&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-2.png&quot; alt=&quot;portainer services&quot; /&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/portainer-3.png&quot; alt=&quot;portainer swarm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;portainer도 역시 접속 성공입니다! 이제 어떤 서비스도 frontend네트워크를 연결하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;traefik.port&lt;/code&gt; 라벨만 지정하면 자동으로 외부에 노출됩니다. 내친김에 아까 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;서비스도 붙여보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker service rm counter
docker service create --name counter &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;frontend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --network&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;backend &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --replicas 3 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --label traefik.port&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;REDIS_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;redis &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  subicura/counter&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기존에 생성되어 있던 서비스를 삭제하고 새로운 옵션으로 서비스를 생성하였습니다. frontend와 backend 두개의 네트워크에 모두 속해있고 label을 주어 traefik에서 자동으로 인식할 수 있도록 했습니다. 이제 테스트해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl counter.local.dev

&lt;span class=&quot;c&quot;&gt;# output&lt;/span&gt;

50bec9ce8874 &amp;gt; 2                                                                
5cbd7ecbb5b8 &amp;gt; 1                                                                
6705a6272a4a &amp;gt; 2                                                                
92b471d0d741 &amp;gt; 2 &lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/magic.gif&quot; alt=&quot;this is magic!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마법과 같은 일이 옵션 몇줄로 일어났습니다. 음.. 스웜 정말 좋지 않나요?&lt;/p&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-25-container-orchestration-with-docker-swarm/traefik.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;traefik&lt;/figcaption&gt;&lt;/div&gt;

&lt;h3 id=&quot;section-12&quot;&gt;스웜 서버 모니터링&lt;/h3&gt;

&lt;p&gt;스웜은 자체적인 모니터링 서비스를 제공하지 않습니다. 따라서 적당한 툴을 선택하여 직접 운영해야 합니다. &lt;a href=&quot;￼https://prometheus.io/&quot;&gt;prometheus&lt;/a&gt;와 &lt;a href=&quot;￼http://grafana.org/&quot;&gt;grafana&lt;/a&gt;를 이용하면 아주 그럴듯한 모니터링 시스템을 만들 수 있습니다. 게다가 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker stack&lt;/code&gt;명령어를 이용하면 여러 개의 서비스를 일일이 생성하지 않고 하나의 docker-compose 설정 파일로 관리할 수 있습니다. 명령어 한 줄로 모든 서버에 정보를 수집하는 서비스를 생성하고 모니터링 툴을 설치할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-25-container-orchestration-with-docker-swarm/grafana.png&quot; alt=&quot;grafana&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크린샷이 그럴듯해 보이지 않나요? 이부분에 대한 자세한 내용은 prometheus와 더불어 다음 기회에 따로 포스팅하도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a class=&quot;waiting-post&quot;&gt;[준비중] 도커 스웜과 prometheus를 이용한 서버 모니터링&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;도커 스웜의 핵심내용인 노드와 서비스에 대해 알아보았고 ingress 네트워크와 자체 내장된 로드밸런서, DNS 서버를 사용해봤습니다.&lt;/p&gt;

&lt;p&gt;도커 스웜은 어떠한 툴도 추가적으로 설치할 필요 없이 굉장히 간단하고 빠르게 클러스터를 구성할 수 있습니다. 기능적으로 아쉬운 부분이 조금 있지만 작은 규모에서 일반적인 작업을 하기에는 무리가 없습니다. (오토스케일링 같은 기능을 많은 곳에서 쓰진 않겠죠)&lt;/p&gt;

&lt;p&gt;기존에 오케스트레이션 도입을 꺼렸던 많은 소규모 개발팀에서는 스웜이 아주 매력적인 선택이 될 것 같습니다.&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/02/25/container-orchestration-with-docker-swarm.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/02/25/container-orchestration-with-docker-swarm.html</guid>
        
        <category>Docker</category>
        
        <category>Swarm</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        <category>Cluster</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>초보를 위한 도커 안내서 - 이미지 만들고 배포하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;code class=&quot;highlighter-rouge&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지&lt;/code&gt; 시리즈의 마지막 글입니다. 지난 글에서 도커를 설치하고 컨테이너를 실행해 보았으니 이번엔 이미지를 만들고 서버에 배포해보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;도커 이미지 만들기&lt;/h2&gt;
&lt;p&gt;도커는 이미지를 만들기 위해 &lt;strong&gt;컨테이너의 상태를 그대로 이미지로 저장&lt;/strong&gt;하는 단순하고 무식(?)한 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/create-image.png&quot; alt=&quot;create docker image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 어떤 애플리케이션을 이미지로 만든다면 리눅스만 설치된 컨테이너에 애플리케이션을 설치하고 그 상태를 그대로 이미지로 저장합니다. 가상머신의 스냅샷과 비스므리한 방식입니다.&lt;/p&gt;

&lt;p&gt;이런 과정은 콘솔에서 명령어를 직접 입력하는 것과 별 차이가 없으므로 쉘 스크립트를 잘 알아야 하지만 좋은 샘플이 많이 &lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=dockerfile￼&quot;&gt;공개&lt;/a&gt;되어 있어 잘 몰라도 크게 걱정하지 않아도 됩니다. &lt;del&gt;복붙만세!&lt;/del&gt; 또한 컨테이너의 가벼운 특성과 레이어 개념을 이용하여 생성과 테스트를 빠르게 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;a href=&quot;https://www.ruby-lang.org/ko&quot;&gt;Ruby&lt;/a&gt;로 만들어진 간단한 웹 애플리케이션을 도커라이징&lt;sub&gt;Dockerizing&lt;/sub&gt;(=도커 이미지를 만듦)해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;sinatra---&quot;&gt;Sinatra 웹 애플리케이션 샘플&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/sinatra.png&quot; alt=&quot;Sinatra&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 웹 애플리케이션 소스코드를 작성해야겠죠. &lt;a href=&quot;http://www.sinatrarb.com/&quot;&gt;Sinatra&lt;/a&gt;라는 가벼운 웹 프레임워크를 사용하기 위해 새로운 폴더를 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;app.rb&lt;/code&gt;를 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gemfile&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://rubygems.org'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sinatra'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;app.rb&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sinatra'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'socket'&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;Socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;gethostname&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ruby와 sinatra에 대해 전혀 모르더라도 &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;은 패키지를 관리하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;app.rb&lt;/code&gt;는 호스트명을 출력하는 웹 서버를 만들었다는 걸 예상할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 패키지를 설치하고 서버를 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;bundle install            &lt;span class=&quot;c&quot;&gt;# install package&lt;/span&gt;
bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;ruby app.rb   &lt;span class=&quot;c&quot;&gt;# Run sinatra&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/run-sinatra.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run-sinatra&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;ruby가 설치되어 있지 않다고요? 도커만 있으면 문제없습니다. 다음 명령어를 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run --rm &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
-p 4567:4567 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
-v &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;:/usr/src/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
-w /usr/src/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
ruby &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
bash -c &lt;span class=&quot;s2&quot;&gt;&quot;bundle install &amp;amp;&amp;amp; bundle exec ruby app.rb -o 0.0.0.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/run-docker-sinatra.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run-docker-sinatra&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;호스트의 디렉토리를 루비가 설치된 컨테이너의 디렉토리에 마운트한다음 그대로 명령어를 실행하면 로컬에 개발 환경을 구축하지 않고 도커 컨테이너를 개발환경으로 사용할 수 있습니다. &lt;del&gt;어으썸!&lt;/del&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커를 개발환경으로 사용하면 개발=테스트=운영이 동일한 환경에서 실행되는 놀라운 상황이 펼쳐집니다. 이 부분은 재미있는 내용이 많지만, 주제에서 벗어나므로 이 정도만 언급하고 다음 기회에 더 자세히 알아봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서버가 정상적으로 실행됐으면 웹 브라우저에서 테스트해봅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4567&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/first-test.png&quot; alt=&quot;Browser test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 컨테이너의 호스트명이 보입니다. 소스는 잘 작성한 것 같네요! 이제 도커 이미지를 만들 준비가 완료됐습니다.&lt;/p&gt;

&lt;h3 id=&quot;ruby-application-dockerfile&quot;&gt;Ruby Application Dockerfile&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/dockerfile.png&quot; alt=&quot;Dockerfile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 이미지를 만들기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;이라는 이미지 빌드용 DSL&lt;sub&gt;Domain Specific Language&lt;/sub&gt; 파일을 사용합니다. 단순 텍스트 파일로 일반적으로 소스와 함께 관리합니다.&lt;/p&gt;

&lt;p&gt;고오급 개발자는 바로 Dockerfile을 만들 수도 있겠지만, 일반 개발자들은 일단 리눅스 서버에서 테스트로 설치해보고 안 되면 될 때까지 삽질하면서 최적의 과정을 Dockerfile로 작성해야 합니다. 우리는 초보니까 Ruby 웹 애플리케이션을 ubuntu에 배포하는 과정을 먼저 살펴보겠습니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;순서&lt;/th&gt;
      &lt;th&gt;작업&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;ubuntu 설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;ruby  설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;소스 복사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Gem 패키지 설치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Sinatra 서버 실행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 과정을 그대로 쉘 스크립트로 옮겨봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# 1. ubuntu 설치 (패키지 업데이트)&lt;/span&gt;
apt-get update

&lt;span class=&quot;c&quot;&gt;# 2. ruby 설치&lt;/span&gt;
apt-get install ruby
gem install bundler

&lt;span class=&quot;c&quot;&gt;# 3. 소스 복사&lt;/span&gt;
mkdir -p /usr/src/app
scp Gemfile app.rb root@ubuntu:/usr/src/app  &lt;span class=&quot;c&quot;&gt;# From host&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 4. Gem 패키지 설치&lt;/span&gt;
bundle install

&lt;span class=&quot;c&quot;&gt;# 5. Sinatra 서버 실행&lt;/span&gt;
bundle &lt;span class=&quot;nb&quot;&gt;exec &lt;/span&gt;ruby app.rb&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ubuntu 컨테이너를 실행하고 위 명령어를 그대로 실행하면 웹 서버를 실행할 수 있습니다. 리눅스에서 테스트가 끝났으니 이 과정을 Dockerfile로 만들면 됩니다. 아직 자세한 명령어를 배우진 않았지만 일단 만들어 봅니다. 핵심 명령어는  파일을  복사하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt;와 명령어를 실행하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;입니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;# 1. ubuntu 설치 (패키지 업데이트 + 만든사람 표시)
FROM       ubuntu:16.04
MAINTAINER subicura@subicura.com
RUN        apt-get -y update

# 2. ruby 설치
RUN apt-get -y install ruby
RUN gem install bundler

# 3. 소스 복사
COPY . /usr/src/app

# 4. Gem 패키지 설치 (실행 디렉토리 설정)
WORKDIR /usr/src/app
RUN     bundle install

# 5. Sinatra 서버 실행 (Listen 포트 정의)
EXPOSE 4567
CMD    bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/f3f9d9b67dc59da9bad9afe76caba824.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;쉘 스크립트의 내용을 거어어어어의 그대로 Dockerfile로 옮겼습니다. 차이점은 도커 빌드 중엔 키보드를 입력할 수 없기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;(y/n)&lt;/code&gt;을 물어보는 걸 방지하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-y&lt;/code&gt; 옵션을 추가한 것 정도입니다.&lt;/p&gt;

&lt;p&gt;빌드 파일을 작성했으니 이제 이미지를 만들어 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-build&quot;&gt;Docker build&lt;/h3&gt;

&lt;p&gt;이미지를 빌드하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker build [OPTIONS] PATH | URL | -&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;생성할 이미지 이름을 지정하기 위한 &lt;code class=&quot;highlighter-rouge&quot;&gt;-t(--tag)&lt;/code&gt; 옵션만 알면 빌드가 가능합니다.&lt;/p&gt;

&lt;p&gt;Dockerfile을 만든 디렉토리로 이동하여 다음 명령어를 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker build -t app .&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon 22.02 kB
Step 1/10 : FROM ubuntu:16.04
 ---&amp;gt; f49eec89601e
Step 2/10 : MAINTAINER subicura@subicura.com
 ---&amp;gt; Running in 06f20ac1017d
 ---&amp;gt; fc41cd8ac52d
Removing intermediate container 06f20ac1017d
Step 3/10 : RUN apt-get -y update
 ---&amp;gt; Running in c35738e75a51
Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]
Get:2 http://archive.ubuntu.com/ubuntu xenial-updates InRelease [102 kB]
Get:3 http://archive.ubuntu.com/ubuntu xenial-security InRelease [102 kB]
Get:4 http://archive.ubuntu.com/ubuntu xenial/main Sources [1103 kB]
Get:5 http://archive.ubuntu.com/ubuntu xenial/restricted Sources [5179 B]

... 생략 ...

Step 9/10 : EXPOSE 4567
 ---&amp;gt; Running in 9c514a1f0c8e
 ---&amp;gt; c5ce4376282e
Removing intermediate container 9c514a1f0c8e
Step 10/10 : CMD bundle exec ruby app.rb -o 0.0.0.0
 ---&amp;gt; Running in 1f7a9ba8d63c
 ---&amp;gt; 54d239c00f11
Removing intermediate container 1f7a9ba8d63c
Successfully built 54d239c00f11&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-build.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker-build&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;빌드 명령어를 실행하면 Dockerfile에 정의한 내용이 한 줄 한 줄 실행되는 걸 볼 수 있습니다. 실제로 명령어를 실행하기 때문에 빌드 시간이 꽤 걸리는 걸 알 수 있습니다. 최종적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Successfully built xxxxxxxx&lt;/code&gt; 메시지가 보이면 정상적으로 이미지를 생성한 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 이미지가 잘 생성되었는지 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
app                 latest              54d239c00f11        4 minutes ago       209 MB
ubuntu              16.04               f49eec89601e        2 weeks ago         129 MB&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;와..와우! 드디어 첫 번째 도커 이미지를 생성했습니다! 이미지를 생성했으니 잘 동작하는지 컨테이너를 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 8080:4567 app
docker run -d -p 8081:4567 app
docker run -d -p 8082:4567 app&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/container-test.png&quot; alt=&quot;Container test result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;접속 성공입니다. 기분이 좋아서 호스트 네임을 출력하는 &lt;del&gt;무쓸모&lt;/del&gt; 웹서버를 3개나 만들었습니다. 이미지가 잘 만들어졌네요.&lt;/p&gt;

&lt;h3 id=&quot;dockerfile--&quot;&gt;Dockerfile 기본 명령어&lt;/h3&gt;

&lt;p&gt;이미지를 만드는 데 사용한 Dockerfile의 기본적인 명령어를 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
FROM ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;베이스 이미지를 지정합니다. 반드시 지정해야 하며 어떤 이미지도 베이스 이미지가 될 수 있습니다. tag는 될 수 있으면 latest(기본값)보다 구체적인 버전(16.04등)을 지정하는 것이 좋습니다.
이미 만들어진 다양한 베이스 이미지는 &lt;a href=&quot;https://hub.docker.com/explore/&quot;&gt;Docker hub&lt;/a&gt;에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MAINTAINER&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MAINTAINER &amp;lt;name&amp;gt;
MAINTAINER subicura@subicura.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dockerfile을 관리하는 사람의 이름 또는 이메일 정보를 적습니다. 빌드에 딱히 영향을 주지는 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COPY&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;COPY &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
COPY . /usr/src/app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;파일이나 디렉토리를 이미지로 복사합니다. 일반적으로 소스를 복사하는 데 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;디렉토리가 없다면 자동으로 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;
ADD . /usr/src/app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt;명령어와 매우 유사하나 몇가지 추가 기능이 있습니다.  &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;에 파일 대신 URL을 입력할 수 있고  &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;에 압축 파일을 입력하는 경우 자동으로 압축을 해제하면서 복사됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN &amp;lt;command&amp;gt;
RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
RUN bundle install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;가장 많이 사용하는 구문입니다. 명령어를 그대로 실행합니다. 내부적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh -c&lt;/code&gt; 뒤에 명령어를 실행하는 방식입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CMD&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]
CMD command param1 param2
CMD bundle exec ruby app.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;도커 컨테이너가 실행되었을 때 실행되는 명령어를 정의합니다. 빌드할 때는 실행되지 않으며 여러 개의 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;가 존재할 경우 가장 마지막 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;만 실행됩니다. 한꺼번에 여러 개의 프로그램을 실행하고 싶은 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;run.sh&lt;/code&gt;파일을 작성하여 데몬으로 실행하거나 &lt;a href=&quot;http://supervisord.org/&quot;&gt;supervisord&lt;/a&gt;나 &lt;a href=&quot;https://github.com/ddollar/forego&quot;&gt;forego&lt;/a&gt;와 같은 여러 개의 프로그램을 실행하는 프로그램을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /path/to/workdir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;RUN, CMD, ADD, COPY등이 이루어질 기본 디렉토리를 설정합니다. 각 명령어의 현재 디렉토리는 한 줄 한 줄마다 초기화되기 때문에  &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN cd /path&lt;/code&gt;를 하더라도 다음 명령어에선 다시 위치가 초기화 됩니다. 같은 디렉토리에서 계속 작업하기 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;WORKDIR&lt;/code&gt;을 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]
EXPOSE 4567
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;도커 컨테이너가 실행되었을 때 요청을 기다리고 있는(Listen) 포트를 지정합니다. 여러개의 포트를 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VOLUME&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VOLUME [&quot;/data&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다. 반드시 지정하지 않아도 마운트 할 수 있지만, 기본적으로 지정하는 것이 좋습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ENV&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...
ENV DB_URL mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;컨테이너에서 사용할 환경변수를 지정합니다. 컨테이너를 실행할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt;옵션을 사용하면 기존 값을 오버라이딩 하게 됩니다.&lt;/p&gt;

&lt;p&gt;여기까지 Dockerfile에서 가장 많이 사용하는 명령어에 대해 알아보았습니다. 모든 명령어가 궁금하신 분은 &lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;공식문서&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;h3 id=&quot;build-&quot;&gt;Build 분석&lt;/h3&gt;

&lt;p&gt;도커는 Dockerfile을 가지고 무슨 일을 하는 걸까요? 빌드를 하면서 궁금하지 않으셨나요? 궁금하지 않으셨더라도 build로그를 보면서 하나하나 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon  5.12 kB   &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 1/10 : FROM ubuntu:16.04                     &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 ---&amp;gt; f49eec89601e                                &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 2/10 : MAINTAINER subicura@subicura.com      &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 ---&amp;gt; Running &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;f4de0c750abb                     &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 ---&amp;gt; 4a400609ff73                                &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Removing intermediate container f4de0c750abb      &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;7&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Step 3/10 : RUN apt-get -y update                 &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
...
...
Successfully built 20369cef9829                   &amp;lt;-- &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;9&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(1) Sending build context to Docker daemon  5.12 kB
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;빌드 명령어를 실행한 디렉토리의 파일들을 빌드컨텍스트&lt;sub&gt;build context&lt;/sub&gt;라고 하고 이 파일들을 도커 서버(daemon)로 전송합니다. 도커는 서버-클라이언트 구조이므로 도커 서버가 작업하려면 미리 파일을 전송해야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(2) Step 1/10 : FROM ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dockerfile을 한 줄 한 줄 수행합니다. 첫 번째로 FROM 명령어를 수행합니다. ubuntu:16.04 이미지를 다운받는 작업입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(3) ---&amp;gt; f49eec89601e
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;명령어 수행 결과를 이미지로 저장합니다. 여기서는 ubuntu:16.04를 사용하기로 했기 때문에 ubuntu 이미지의 ID가 표시됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(4) Step 2/10 : MAINTAINER subicura@subicura.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dockerfile의 두 번째 명령어인 MAINTAINER 명령어를 수행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(5) ---&amp;gt; Running in f4de0c750abb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;명령어를 수행하기 위해 바로 이전에 생성된 &lt;code class=&quot;highlighter-rouge&quot;&gt;f49eec89601e&lt;/code&gt; 이미지를 기반으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;f4de0c750abb&lt;/code&gt;컨테이너를 임시로 생성하여 실행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(6) ---&amp;gt; 4a400609ff73
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;명령어 수행 결과를 이미지로 저장합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(7) Removing intermediate container f4de0c750abb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;명령어를 수행하기 위해 임시로 만들었던 컨테이너를 제거합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(8) Step 3/10 : RUN apt-get -y update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dockerfile의 세 번째 명령어를 수행합니다. 이전 단계와 마찬가지로 바로 전에 만들어진 이미지를 기반으로 임시 컨테이너를 만들어 명령어를 실행하고 그 결과 상태를 이미지로 만듭니다. 이 과정을 마지막 줄까지 무한 반복합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(9) Successfully built 20369cef9829
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;최종 성공한 이미지 ID를 출력합니다.&lt;/p&gt;

&lt;p&gt;결론적으로 도커 빌드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;임시 컨테이너 생성&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;명령어 수행&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이미지로 저장&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;임시 컨테이너 삭제&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;새로 만든 이미지 기반 임시 컨테이너 생성&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;명령어 수행&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이미지로 저장&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;임시 컨테이너 삭제&lt;/code&gt; &amp;gt; … 의 과정을 계속해서 반복한다고 볼 수 있습니다. 명령어를 실행할 때마다 이미지 레이어를 저장하고 다시 빌드할 때 Dockerfile이 변경되지 않았다면 기존에 저장된 이미지를 그대로 캐시처럼 사용합니다.&lt;/p&gt;

&lt;p&gt;이러한 레이어 개념을 잘 이해하고 있어야 최적화된 이미지를 생성할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;도커 이미지 리팩토링&lt;/h3&gt;

&lt;p&gt;사실 앞에서 만든 이미지는 몇 가지 최적화 문제가 있습니다. 다시 한땀 한땀 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Base Image&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 만든 Ruby 애플리케이션 이미지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt;를 베이스로 만들었지만 사실 훠어어얼씬 간단한  &lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt; 베이스 이미지가 존재합니다. &lt;del&gt;미리 이야기하지 않아 죄송..&lt;/del&gt; 기존에 ruby를 설치했던 명령어는 ruby 이미지를 사용하는 것으로 간단하게 생략할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
FROM ubuntu:16.04
MAINTAINER subicura@subicura.com
RUN apt-get -y update
RUN apt-get -y install ruby
RUN gem install bundler

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
FROM ruby:2.3
MAINTAINER subicura@subicura.com&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ruby외에도 nodejs, python, java, go등 다양한 베이스 이미지가 이미 존재합니다. 세부적인 설정이 필요하지 않다면 그대로 사용하는게 간편합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Build Cache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;조금전에 빌드한 이미지를 다시 빌드해볼까요?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Sending build context to Docker daemon 13.31 kB
Step 1/10 : FROM ubuntu:16.04
 ---&amp;gt; f49eec89601e
Step 2/10 : MAINTAINER subicura@subicura.com
 ---&amp;gt; Using cache
 ---&amp;gt; fc41cd8ac52d
Step 3/10 : RUN apt-get -y update
 ---&amp;gt; Using cache
 ---&amp;gt; 61d45ce11dc6
 ....
 &lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;한번 빌드한 이미지를 다시 빌드하면 굉장히 빠르게 완료되는 걸 알 수 있습니다. 이미지를 빌드하는 과정에서 각 단계를 이미지 레이어로 저장하고 다음 빌드에서 캐시로 사용합니다.&lt;/p&gt;

&lt;p&gt;도커는 빌드할 때 Dockerfile의 명령어가 수정되었거나 추가하는 파일이 변경 되었을 때 캐시가 깨지고 그 이후 작업은 새로 이미지를 만들게 됩니다. ruby gem 패키지를 설치하는 과정은 꽤 많은 시간이 소요되는데 최대한 캐시를 이용하여 빌드 시간을 줄여야 합니다.&lt;/p&gt;

&lt;p&gt;기존 소스에서 소스파일이 수정되면 캐시가 깨지는 부분은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;COPY . /usr/src/app    &lt;span class=&quot;c&quot;&gt;# &amp;lt;- 소스파일이 변경되면 캐시가 깨짐&lt;/span&gt;
WORKDIR /usr/src/app
RUN bundle install     &lt;span class=&quot;c&quot;&gt;# 패키지를 추가하지 않았는데 또 인스톨하게 됨 ㅠㅠ&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;복사하는 파일이 이전과 다르면 캐시를 사용하지 않고 그 이후 명령어는 다시 실행됩니다. ruby gem 패키지를 관리하는 파일은 Gemfile이고 Gemfile은 잘 수정되지 않으므로 다음과 같이 순서를 바꿀 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;COPY Gemfile&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; /usr/src/app/ &lt;span class=&quot;c&quot;&gt;# Gemfile을 먼저 복사함&lt;/span&gt;
WORKDIR /usr/src/app
RUN bundle install          &lt;span class=&quot;c&quot;&gt;# 패키지 인스톨&lt;/span&gt;
COPY . /usr/src/app         &lt;span class=&quot;c&quot;&gt;# &amp;lt;- 소스가 바꼈을 때 캐시가 깨지는 시점 ^0^&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;gem 설치 하는 부분을 소스 복사 이전으로 옮겼습니다. 이제 소스가 수정되더라도 매번 gem을 설치하지 않아 더욱 빠르게 빌드할 수 있습니다. 요즘 언어들은 대부분 패키지 매니저를 사용하므로 비슷한 전략으로 작성하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;명령어 최적화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이미지를 빌드할 때 불필요한 로그는 무시하는게 좋고 패키지 설치시 문서 파일도 생성할 필요가 없습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN apt-get -y update

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN apt-get -y -qq update&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-qq&lt;/code&gt; 옵션으로 로그를 출력하지 않게 했습니다. 각종 리눅스 명령어는 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;quite&lt;/code&gt; 옵션이 있으니 적절하게 적용하면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN bundle install

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN bundle install --no-rdoc --no-ri&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--no-doc&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;--no-ri&lt;/code&gt; 옵션으로 필요 없는 문서를 생성하지 않아 이미지 용량도 줄이고 빌드 속도도 더 빠르게 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이쁘게&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어는 비슷한 것끼리 묶어 주는 게 보기도 좋고 레이어 수를 줄이는데 도움이 됩니다. 도커 이미지는 스토리지 엔진에 따라 레이어의 개수가 127개로 제한되어 있는 경우도 있어 너무 많은 명령어는 좋지 않습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
RUN apt-get -y -qq update
RUN apt-get -y -qq install ruby

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
RUN apt-get -y -qq update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    apt-get -y -qq install ruby&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;최종&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최종 결과는 다음과 같습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM ruby:2.3
MAINTAINER subicura@subicura.com
COPY Gemfile* /usr/src/app/
WORKDIR /usr/src/app
RUN bundle install --no-rdoc --no-ri
COPY . /usr/src/app
EXPOSE 4567
CMD bundle exec ruby app.rb -o 0.0.0.0&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/877bced4293c68769302141f51e4b766.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;드디어 아까보다 훨씬 나은 이미지가 완성됐습니다. &lt;del&gt;만세&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;이 외에도 다양한 이미지 생성팁이 있지만 일단 이 정도면 꽤 이쁘게 만들어진 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;이미지 저장소&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-registry.png&quot; alt=&quot;Docker Registry&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 빌드한 이미지를 서버에 배포하기 위해 직접 파일을 복사하는 방법 대신 &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;도커 레지스트리&lt;/a&gt;&lt;sub&gt;Docker Registry&lt;/sub&gt;라는 이미지 저장소를 사용합니다. 도커 명령어를 이용하여 이미지를 레지스트리에 푸시&lt;sub&gt;push&lt;/sub&gt;하고 다른 서버에서 풀&lt;sub&gt;pull&lt;/sub&gt;받아 사용하는 구조입니다. &lt;del&gt;git을 사용하는 느낌?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;도커 레지스트리는  &lt;a href=&quot;https://github.com/docker/distribution&quot;&gt;오픈소스&lt;/a&gt;로 무료로 설치할 수 있고 설치형이 싫다면 도커(Docker Inc.)에서 서비스 중인 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;도커 허브&lt;/a&gt;&lt;sub&gt;Docker Hub&lt;/sub&gt;를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;

&lt;p&gt;도커 허브는 도커에서 제공하는 기본 이미지 저장소로 ubuntu, centos, debian등의 베이스 이미지와 ruby, golang, java, python 등의 공식 이미지가 저장되어 있습니다. 일반 사용자들이 만든 이미지도 50만 개가 넘게 저장되어 있고 다운로드 횟수는 80억 회를 넘습니다.&lt;/p&gt;

&lt;p&gt;회원가입만 하면 대용량의 이미지를 무료로 저장할 수 있고 다운로드 트래픽 또한 무료입니다. 단, 기본적으로 모든 이미지는 공개되어 누구나 접근 가능하므로 비공개로 사용하려면 유료 서비스를 이용해야 합니다. (한 개는 무료)&lt;/p&gt;

&lt;p&gt;회원가입을 하고 앞에서 만든 Ruby 웹 애플리케이션 이미지를 저장해보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;회원가입&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-hub.png&quot; alt=&quot;Docker Hub&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot;&gt;도커 허브&lt;/a&gt;사이트에 접속하면 쉽게 회원가입을 할 수 있습니다. 디자인이 참 마음에 들지 않는데… 처음부터 지금까지 업데이트한 모습이 이 모양이라 앞으로도 크게 기대되지 않습니다. &lt;del&gt;다른 페이지는 다 이쁜데 ㅠㅠ&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로그인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커에서 도커 허브 계정을 사용하려면 로그인을 해야합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker login&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Login with your Docker ID to push and pull images from Docker Hub. If you don&lt;span class=&quot;s1&quot;&gt;'t have a Docker ID, head over to https://hub.docker.com to create one.
Username: subicura
Password:
Login Succeeded&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;ID와 패스워드를 입력하면 로그인이 되고 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.docker/config.json&lt;/code&gt;에 인증정보가 저장되어 로그아웃하기 전까지 로그인 정보가 유지됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미지 태그&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지 이름은 다음과 같은 형태로 구성됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;[Registry URL]/[사용자 ID]/[이미지명]:[tag]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Registry URL은 기본적으로 도커 허브를 바라보고 있고 사용자 ID를 지정하지 않으면 기본값(library)을 사용합니다. 따라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;library/ubuntu&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library/ubuntu&lt;/code&gt; 는 모두 동일한 표현입니다.&lt;/p&gt;

&lt;p&gt;도커의 &lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;명령어를 이용하여 기존에 만든 이미지에 추가로 이름을 지어줄 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;앞에서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt;이미지에 계정정보와 버전 정보를 추가해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker tag app subicura/sinatra-app:1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;subicura&lt;/code&gt;라는 ID를 사용하고 이미지 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;sinatra-app&lt;/code&gt;으로 변경했습니다. 첫 번째 버전이므로 태그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;을 사용합니다. 이제  &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;명령을 이용해 도커 허브에 이미지를 전송해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker push subicura/sinatra-app:1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;The push refers to a repository &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;docker.io/subicura/sinatra-app]
2adeabae7edc: Pushed
8343e5bcf528: Pushed
af3b68c8b565: Pushed
40dd6783317f: Pushed
c6ae77e29c22: Pushed
5eb5bd4c5014: Mounted from library/ubuntu
d195a7a18c70: Mounted from library/ubuntu
af605e724c5a: Mounted from library/ubuntu
59f161c3069d: Mounted from library/ubuntu
4f03495a4d7d: Mounted from library/ubuntu
1: digest: sha256:af83aca920982c1fb17f08b4aa300439470349d58d63c921f67261054a0c9467 size: 2409&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;성공적으로 이미지를 도커 허브에 푸시하였습니다. 도커 허브에 저장된 50만 개의 이미지에 새로운 이미지가 하나 추가되었습니다!&lt;/p&gt;

&lt;p&gt;이제 어디서든 &lt;code class=&quot;highlighter-rouge&quot;&gt;subicura/sinatra-app:1&lt;/code&gt;이미지를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;private-docker-registry&quot;&gt;Private Docker Registry&lt;/h3&gt;

&lt;p&gt;도커 이미지를 비공개로 저장하려면  &lt;a href=&quot;https://www.docker.com/products/docker-cloud&quot;&gt;Docker Cloud&lt;/a&gt;를 유료($7 for 5 repos/month)로 사용하거나 레지스트리 서버를 자체적으로 구축해야합니다.&lt;/p&gt;

&lt;p&gt;도커 레지스트리는 도커를 이용하여 쉽게 만들 수 있습니다. 도커 이미지를 저장할 서버를 도커 스스로 만들어서 도커 이미지를 관리하다니 뭔가 므-_-흣합니다. &lt;del&gt;도커로 다하는 느낌&lt;/del&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
-v &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;/registry:/var/lib/registry &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
-p 5000:5000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
distribution/registry:2.6.0&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;저장된 이미지는 파일로 관리되기 때문에 호스트의 디렉토리를 마운트하였습니다. (S3 저장소를 사용할 수도 있습니다) 이제 레지스트리 서버의 아이피와 포트정보를 이미지명에 추가하면 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker tag app localhost:5000/subicura/sinatra-app:1
docker push localhost:5000/subicura/sinatra-app:1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;앞에서 만든 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:5000/&lt;/code&gt;를 추가했습니다. 레지스트리 서버에 파일이 잘 저장되었나 마운트한 디렉토리를 한번 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;tree registry&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;registry
└── docker
    └── registry
        └── v2
            ├── blobs
            │   └── sha256
            │       ├── 05
            │       │   └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
            │       │       └── data
            │       ├── 1b
            │       │   └── 1bacd3c8ccb1f15609a10bd4a403831d0ec0b354438ddbf644c95c5d54f8eb13
            │       │       └── data
            │       ├── 3e
            │       │   └── 3e309f550af7bb4e3177e94e498938a24c20cf7404d90da4b24bd586d6376ab2
            │       │       └── data
            │       ├── 5b
            │       │   └── 5b8ee2811f46dea888057c8a2eb1fcd43838bb2545588f7e108d462d0836e217
            │       │       └── data
            │       ├── 76
            │       │   └── 761e0e61cc35ced6b08ce33b1db84a3e92a4843f908476d4cfc52f99b2b7e78a
            │       │       └── data
            │       ├── 86
            │       │   └── 869d5d3f92f8bbdcaa1023ce719df7e337d34b2a13954cde7954c6b1327297e9
            │       │       └── data
            │       ├── 97
            │       │   └── 976dd3af6adc358c852b97651cef1ceaade821a25f3bf566de3a8ea8b7d6bc6a
            │       │       └── data
            │       ├── a2
            │       │   └── a2037218c9af7a6913308a60127a320272fd6d58405692a5be48ce976ace6c6d
            │       │       └── data
            │       ├── e2
            │       │   └── e2d7e96004fdd10e671372a8b5e861bae78bcf878e062d13f6c470311936d500
            │       │       └── data
            │       ├── f4
            │       │   └── f40e1388890a7ca2b5180e2fae69aa982926307cdfa98c8c6a2dde01c0464587
            │       │       └── data
            │       ├── f8
            │       │   └── f8a4e25b40ce0ecc925cfb0b2ec7eec0a06948eda173e943c228cd51f78b40c5
            │       │       └── data
            │       └── fd
            │           └── fdeb3bd5d1b49c094875dcacccb743b0bc913c7de80ba783f2f1bbda6b1a3b55
            │               └── data
            └── repositories
                └── subicura
                    └── app
                        ├── _layers
                        │   └── sha256
                        │       ├── 1bacd3c8ccb1f15609a10bd4a403831d0ec0b354438ddbf644c95c5d54f8eb13
                        │       │   └── link
                        │       ├── 3e309f550af7bb4e3177e94e498938a24c20cf7404d90da4b24bd586d6376ab2
                        │       │   └── link
                        │       ├── 5b8ee2811f46dea888057c8a2eb1fcd43838bb2545588f7e108d462d0836e217
                        │       │   └── link
                        │       ├── 761e0e61cc35ced6b08ce33b1db84a3e92a4843f908476d4cfc52f99b2b7e78a
                        │       │   └── link
                        │       ├── 869d5d3f92f8bbdcaa1023ce719df7e337d34b2a13954cde7954c6b1327297e9
                        │       │   └── link
                        │       ├── 976dd3af6adc358c852b97651cef1ceaade821a25f3bf566de3a8ea8b7d6bc6a
                        │       │   └── link
                        │       ├── a2037218c9af7a6913308a60127a320272fd6d58405692a5be48ce976ace6c6d
                        │       │   └── link
                        │       ├── e2d7e96004fdd10e671372a8b5e861bae78bcf878e062d13f6c470311936d500
                        │       │   └── link
                        │       ├── f40e1388890a7ca2b5180e2fae69aa982926307cdfa98c8c6a2dde01c0464587
                        │       │   └── link
                        │       ├── f8a4e25b40ce0ecc925cfb0b2ec7eec0a06948eda173e943c228cd51f78b40c5
                        │       │   └── link
                        │       └── fdeb3bd5d1b49c094875dcacccb743b0bc913c7de80ba783f2f1bbda6b1a3b55
                        │           └── link
                        ├── _manifests
                        │   ├── revisions
                        │   │   └── sha256
                        │   │       └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
                        │   │           └── link
                        │   └── tags
                        │       └── latest
                        │           ├── current
                        │           │   └── link
                        │           └── index
                        │               └── sha256
                        │                   └── 05e91de6d378244d3b4dcfbb978548e47b2c22d9918638444c0f9e640d2bf819
                        │                       └── link
                        └── _uploads

56 directories, 26 files&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지가 레이어별로 이쁘게 저장된 걸 확인할 수 있습니다. 이렇게 개인 저장소를 만드는 법은 매우 간단합니다. 이제 내부적으로 이미지를 관리하고 여러 서버에 배포할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;보안&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커 레지스트리는 일반적인 HTTP 프로토콜을 사용하여 이미지를 전송합니다. 따라서 SSL(HTTPS)을 사용하지 않으면 이미지 내용이 유출될 수 있습니다. 이런 보안 이슈 때문에 도커는 기본적으로 로컬(localhost) 서버를 제외하곤 HTTP 사용을 금지하고 있으며 이런 보안위험을 무시하려면 도커 엔진을 실행할 때 허용 옵션을 넣어야 합니다.&lt;/p&gt;

&lt;p&gt;관련 설정은 &lt;a href=&quot;https://docs.docker.com/registry/insecure/&quot;&gt;문서&lt;/a&gt;를 참고하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;배포하기&lt;/h2&gt;
&lt;p&gt;드디어 도커 안내서의 마지막 주제, 서버관리의 꽃! 배포&lt;sub&gt;deploy&lt;/sub&gt;에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;컨테이너 배포 방식으로&lt;/h3&gt;

&lt;p&gt;컨테이너를 배포하는 방식은 기존에 애플리케이션을 배포하는 방식과 큰 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;기존에 애플리케이션을 배포하는 방식은 사용하는 언어, 프레임워크, 웹(or WAS)서버, 리눅스 배포판, 개발자의 취향에 따라 각각 다른 방식을 사용했습니다.&lt;/p&gt;

&lt;p&gt;새로운 서버를 셋팅하고 한 번에 배포를 성공한다는 건 굉장히 힘든 일이었고 의존성 라이브러리가 제대로 설치되었는지 검증하기도 매우 어려웠습니다.&lt;/p&gt;

&lt;p&gt;ftp, rsync, ant, gradle, capistrano, fabric, chef, puppet, ansible등 다양한 배포툴이 저마다의 장점을 가지고 등장하였고 배포하는 방식을 하나로 정의한다는 건 거의 불가능했습니다.&lt;/p&gt;

&lt;p&gt;하지만, 컨테이너를 사용하면 어떤 언어, 어떤 프레임워크를 쓰든 상관없이 배포 방식이 동일해지고 과정 또한 굉장히 단순해집니다. 그냥 이미지를 다운받고 컨테이너를 실행하면 끝입니다.&lt;/p&gt;

&lt;p&gt;음…&lt;/p&gt;

&lt;p&gt;&lt;em&gt;네, 그게 답니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;서버에 접속해서 컨테이너를 실행할 줄 안다면 이미 배포하는 법을 알고 있는 겁니다.  참 쉽죠?&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;컨테이너 업데이트&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-update.png&quot; alt=&quot;Update&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커를 사용하면 업데이트하는 방식도 배포와 큰 차이가 없습니다.&lt;/p&gt;

&lt;p&gt;최신 이미지를 기반으로 새 컨테이너를 만들고 이전 컨테이너를 중지(삭제)하면 됩니다. 최신 소스를 어떻게 복사할지 서버 프로세스는 어떻게 재시작할지 고민할 필요가 없습니다. 그냥 통째로 바꿔버리는 겁니다.&lt;/p&gt;

&lt;p&gt;단, 컨테이너를 중지하지 않고 graceful&lt;del&gt;스무스&lt;/del&gt;하게 샤샤샥 교체하는 방법은 아쉽지만 존재하지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨테이너를 중지하지 않고 컨테이너 내부에 접속하여 소스를 업데이트하는 방법도 “가능”은 하지만 컨테이너의 장점을 살릴 수 없는 “잘못된 패턴”입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 방식은 매우 단순하지만, 컨테이너가 멈추는 순간 실행 중인 프로세스가 &lt;strong&gt;종료&lt;/strong&gt;되고 프로세스가 종료되면 고객들은 접속이 안 되고 접속이 안 되면 매출이 떨어지고 매출이 떨어지면 월급이 안나오기 때문에 무중단을 고려한 &lt;a href=&quot;http://nginx.org/&quot;&gt;nginx&lt;/a&gt;나 &lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt;같은 로드 발란서&lt;sub&gt;Load Balancer&lt;/sub&gt;와 2대 이상의 컨테이너를 사용해야 합니다.&lt;/p&gt;

&lt;p&gt;여기서는 개념만 소개하고 실제로 컨테이너를 업데이트하는 구체적인 방법은 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;도커를 이용한 웹서비스 무중단 배포하기&lt;/a&gt;&lt;del&gt;막간 홍보&lt;/del&gt;글로 대신합니다.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;배포에 대해 더 알아보기&lt;/h3&gt;

&lt;p&gt;도커를 이용한 배포, 그 자체는 매우 단순하지만 여러 대의 서버를 관리하고 문제없이 업데이트 하는 건 완전히 새로운 이야기입니다.&lt;/p&gt;

&lt;p&gt;여러 대의 서버를 관리하려면 가상네트워크, 공유 파일, 로그관리, CPU나 메모리 같은 자원분배에 대해 고민해야 하고 Service Discovery에 대한 개념과 Orchestration이라는 주제에 관해 공부해야 합니다. 딱 정해진 답은 없고 현재 운영 중인 환경에 적합한 방법을 찾아야 하며 지금도 계속해서 발전하고 여러 컨퍼런스에서 활발하게 논의되는 주제입니다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 초보를 위한 안내서의 범위를 벗어나므로 더 많은 내용이 궁금하신 분은 각자 공부하는 것으로… &lt;del&gt;화이팅!!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;마무으리&lt;/h2&gt;
&lt;p&gt;클라우드가 발전하면서 언제든 원하는 장소에 수십 대의 서버를 클릭 한 번으로 생성하는 시대가 되었습니다. 서버는 구입하는것이 아니라 필요한 만큼 잠시 &lt;strong&gt;대여&lt;/strong&gt;하는 개념이 되었고 오토 스케일링이라는 환상적인 기능은 부하에 따라 자동으로 서버 개수를 늘리고 줄여줍니다.&lt;/p&gt;

&lt;p&gt;이러한 흐름 속에서 아무 문제 없이 서비스를 배포하고 운영하는 것은 사실 기적이라고 할 수 있습니다. 도커가 등장하여 복잡한 부분을 단순하게 하고 많은 문제를 해결해 주고 있지만 도커도 모든 문제를 해결해 주지는 않습니다. (대표적으로 데이터베이스처럼 stateful한 애플리케이션은 관리가 어렵습니다) 다만, 현재 시점에서 그 어떤 방법보다도 &lt;strong&gt;좀 더 나은 방법&lt;/strong&gt;인 건 확실합니다.&lt;/p&gt;

&lt;p&gt;초보를 위한 도커 안내서는 오늘도 서버운영으로 고통받고 있는 개발자분께 도커를 소개하고 전반적인 내용을 전달하기 위해 작성하였습니다. 길다면 길고 짧다면 짧은 글을 통해 아무쪼록 초보분들에게 많은 도움이 되었으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;도커에 대해 궁금한 점은 &lt;a href=&quot;http://slack.opencontainer.co.kr&quot;&gt;오픈컨테이너 슬랙&lt;/a&gt;으로 오시면 많은 도움을 받을 수 있습니다. 내용에 대한 다양한 피드백도 환영합니다. 읽어주셔서 감사합니다~&lt;/p&gt;

&lt;p&gt;마지막으로 “Future of Everything(모든것의 미래)”라는 슬라이드를 소개하며 글을 마칩니다.&lt;/p&gt;

&lt;div style=&quot;text-align: center; margin-bottom: 20px&quot;&gt;
  &lt;iframe src=&quot;//www.slideshare.net/slideshow/embed_code/key/IylipWTfVGtdaY&quot; width=&quot;595&quot; height=&quot;485&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&quot; allowfullscreen=&quot;&quot;&gt; &lt;/iframe&gt; 
  &lt;div style=&quot;margin-bottom:5px; font-size: 14px&quot;&gt; &lt;strong&gt; &lt;a href=&quot;//www.slideshare.net/MichaelDucy/the-future-of-everything-37344357&quot; title=&quot;The Future of Everything&quot; target=&quot;_blank&quot;&gt;The Future of Everything&lt;/a&gt; &lt;/strong&gt; from &lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;//www.slideshare.net/MichaelDucy&quot;&gt;Michael Ducy&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 10 Feb 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html</guid>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;code class=&quot;highlighter-rouge&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지&lt;/code&gt; 2번째 글입니다. 이번엔 도커 설치부터 컨테이너를 실행하고 컨테이너를 둘러보는 방법에 대해 설명합니다. 도커에 대해 1도 모르는 분들을 위해 아주 가볍게 자주 쓰는 명령어만 다루었기 때문에 모든 명령어가 궁금하신 분은 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;여기&lt;/a&gt;를 참고해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;도커 설치하기&lt;/h2&gt;

&lt;p&gt;도커는 리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우 가상머신에 설치가 됩니다. 리눅스 컨테이너 말고 윈도우즈 컨테이너라는 것도 존재하지만 여기서는 다루지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;

&lt;p&gt;리눅스에 도커를 설치하는 방법은 자동 설치 스크립트를 이용하는 것이 가장 쉽습니다. 다음 명령어를 입력하면 root 권한을 요구하고 잠시 기다리면 설치가 완료됩니다. 음.. 참 쉽죠?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl -fsSL https://get.docker.com/ | sudo sh&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-install-on-linux.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;Docker Install (ubuntu)&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;sudo 없이 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;docker는 기본적으로 root권한이 필요합니다. root가 아닌 사용자가 sudo없이 사용하려면 해당 사용자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;그룹에 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sudo usermod -aG docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 현재 접속중인 사용자에게 권한주기&lt;/span&gt;
sudo usermod -aG docker your-user &lt;span class=&quot;c&quot;&gt;# your-user 사용자에게 권한주기&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용자가 로그인 중이라면 다시 로그인 후 권한이 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도커를 실행하기 위한 kernel 버전은 3.10.x 이상입니다. ubuntu 14.04 이상을 사용하면 큰 문제가 없고 kernel의 버전이 낮을 경우 제대로 동작을 안하거나 문제가 생길 수 있습니다. 가급적 최신버전으로 업데이트 해주세요.&lt;/li&gt;
  &lt;li&gt;ubuntu나 centos가 아닌 경우는 다른 방법이 필요합니다. 다른 리눅스를 쓰시는 분은 대부분 고오오급 개발자 분이시니 따로 설명하지 않아도 될 것 같아 &lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;&gt;링크&lt;/a&gt;로 대신하겠습니다. &lt;del&gt;절대 귀찮아서가 아님&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-for-mac--docker-for-windows&quot;&gt;Docker for Mac / Docker for Windows&lt;/h3&gt;

&lt;p&gt;도커를 맥이나 윈도우즈에 설치하려면 &lt;a href=&quot;https://docs.docker.com/docker-for-mac&quot;&gt;Docker for mac&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/docker-for-windows&quot;&gt;Docker for windows&lt;/a&gt;를 설치하면 됩니다. 파일을 다운받고 설치하고 재부팅하면 대부분 문제없이 완료됩니다. 소소한 옵션들이 있는데 특별히 건드릴 부분은 없으나 한번 살펴보고 적절하게 설정하시면 됩니다. (windows는 공유 드라이브를 선택해주세요)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-for-mac.png&quot; alt=&quot;Docker for Mac&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마치 네이티브스럽게 설치된 것 같지만 도커는 리눅스 컨테이너이므로 실제로는 가상머신에 설치가 되었습니다. 사용자는 가상머신을 사용한다는 느낌이 전혀 안드는데 그런부분을 굉장히 신경써서 설계하였습니다. 예를 들면, 포트를 연결하기 위해 도커 컨테이너의 특정 포트를 가상머신에 연결하고 다시 mac이나 windows의 포트와 연결해야 합니다. 디렉토리를 연결한다면 디렉토리를 가상머신과 공유하고 그 디렉토리를 다시 컨테이너와 연결해야 합니다. 이런 한단계 추가적으로 거쳐야하는 부분을 자연스럽게 처리해줍니다.&lt;/p&gt;

&lt;p&gt;docker for mac은 &lt;a href=&quot;https://github.com/mist64/xhyve&quot;&gt;xhyve&lt;/a&gt;라는 macOS에서 제공하는 가상환경을 이용하고 docker for windows는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-V&quot;&gt;Hyper-V&lt;/a&gt;기능을 이용합니다. 따라서 OS가 최신버전이 아니면 동작하지 않을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;가상머신에 설치하기&lt;/h3&gt;

&lt;p&gt;이런저런 이유로 Docker for … 를 사용하지 못하는 경우 &lt;a href=&quot;https://docs.docker.com/machine/&quot;&gt;Docker machine&lt;/a&gt;을 이용할 수 있는데 처음 도커를 공부하는 경우에는 Virtual Box나 VMware같은 가상머신에 리눅스를 설치하고 리눅스에 접속하여 도커를 사용하는 방법을 권장합니다. 처음부터 Docker machine을 사용하면 환경이 약간 혼란스러울 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;설치확인하기&lt;/h3&gt;

&lt;p&gt;설치가 완료되었다면 정상적으로 설치되었는지 도커 명령어를 입력해 확인해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker version&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Client:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      darwin/amd64

Server:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      linux/amd64&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Client와 Server 정보가 정상적으로 출력되었다면 설치가 완료된 것 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Server 정보가 안나오고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error response from daemon: Bad response from Docker engine&lt;/code&gt;이라는 메시지가 출력되는 경우는 보통 docker daemon이 정상적으로 실행되지 않았거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;를 입력하지 않은 경우입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;혹시, 특이한 부분을 찾으셨나요? 버전정보가 클라이언트와 서버로 나뉘어져 있습니다. 도커는 하나의 실행파일이지만 실제로 클라이언트와 서버역할을 각각 할 수 있습니다. 도커 커맨드를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-host.png&quot; alt=&quot;docker client-host&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본값이 도커 서버의 소켓을 바라보고 있기 때문에 사용자는 의식하지 않고 마치 바로 명령을 내리는 것 같은 느낌을 받습니다. 이러한 설계가 mac이나 windows의 터미널에서 명령어를 입력했을때 가상 서버에 설치된 도커가 동작하는 이유입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;컨테이너 실행하기&lt;/h2&gt;
&lt;p&gt;이제! 드디어! 컨테이너를 실행해 보려고 합니다. 손이 근질근질하고 컨테이너의 강려크함을 보여드리고 싶기 때문에 여러개의 프로그램을 마구잡이로 손쉽게 띄워보겠습니다.&lt;/p&gt;

&lt;p&gt;도커를 실행하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다음은 자주 사용하는 옵션들입니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;옵션&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;detached mode 흔히 말하는 백그라운드 모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 포트를 연결 (포워딩)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 디렉토리를 연결 (마운트)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;컨테이너 내에서 사용할 환경변수 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–name&lt;/td&gt;
      &lt;td&gt;컨테이너 이름 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–rm&lt;/td&gt;
      &lt;td&gt;프로세스 종료시 컨테이너 자동 제거&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-it&lt;/td&gt;
      &lt;td&gt;-i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–link&lt;/td&gt;
      &lt;td&gt;컨테이너 연결 [컨테이너명:별칭]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;엄청나게 직관적인 옵션으로 몇번 실행해보면 자연스럽게 익숙해집니다.&lt;/p&gt;

&lt;h3 id=&quot;ubuntu-1604-container&quot;&gt;ubuntu 16.04 container&lt;/h3&gt;

&lt;p&gt;시작은 가볍게 ubuntu 16.04 컨테이너를 생성하고 컨테이너 내부에 들어가 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run ubuntu:16.04&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 사용하면 사용할 이미지가 저장되어 있는지 확인하고 없다면 다운로드(&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;)를 한 후 컨테이너를 생성(&lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt;)하고 시작(&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;) 합니다.&lt;/p&gt;

&lt;p&gt;위 예제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 이미지를 다운받은 적이 없기 때문에 이미지를 다운로드 한 후 컨테이너가 실행되었습니다. 컨테이너는 정상적으로 실행됐지만 뭘 하라고 명령어를 전달하지 않았기 때문에 컨테이너는 생성되자마자 종료됩니다. 컨테이너는 프로세스이기 때문에 실행중인 프로세스가 없으면 컨테이너는 종료됩니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt; 명령어를 입력해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 컨테이너를 실행해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run --rm -it ubuntu:16.04 /bin/bash

&lt;span class=&quot;c&quot;&gt;# in container&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat /etc/issue
Ubuntu 16.04.1 LTS &lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu-bash.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container with /bin/bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너 내부에 들어가기 위해 bash 쉘을 실행하고 키보드 입력을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 줍니다. 추가적으로 프로세스가 종료되면 컨테이너가 자동으로 삭제되도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt; 옵션도 추가하였습니다.&lt;/p&gt;

&lt;p&gt;이번에는 바로 전에 이미지를 다운 받았기 때문에 이미지를 다운로드 하는 화면 없이 바로 실행되었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;cat /etc/issue&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;를 실행해보면 ubuntu 리눅스인걸 알 수 있습니다. 뭔가 가벼운 가상머신 같나요?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;로 bash 쉘을 종료하면 컨테이너도 같이 종료됩니다.&lt;/p&gt;

&lt;p&gt;도커를 이용하여 가장 기본적인 컨테이너를 순식간에 만들어 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;redis-container&quot;&gt;redis container&lt;/h3&gt;

&lt;p&gt;2번째 컨테이너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt; 입니다. &lt;a href=&quot;https://redis.io/&quot;&gt;redis&lt;/a&gt;는 메모리기반의 다양한 기능을 가진 스토리지입니다. 6379 포트로 통신하며 telnet 명령어로 테스트해 볼 수 있습니다. redis 컨테이너는 detached mode(백그라운드 모드)로 실행하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 추가하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 추가하여 컨테이너의 포트를 호스트의 포트로 연결해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt;옵션이 없다면 프로세스가 foreground로 실행되어 아무키도 입력할 수 없게 됩니다. 컨테이너를 종료하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + c&lt;/code&gt;를 입력해 주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 1234:6379 redis

&lt;span class=&quot;c&quot;&gt;# redis test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;telnet localhost 1234
&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mykey hello
+OK
get mykey
&lt;span class=&quot;nv&quot;&gt;$5&lt;/span&gt;
hello&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-redis.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run redis container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 주었기 때문에 컨테이너를 실행하자마자 컨테이너의 ID(5dff91d2…)를 보여주고 바로 쉘로 돌아왔습니다. 컨테이너는 종료된 것이 아니라 백그라운드 모드로 동작하고 있고 컨테이너 ID를 이용하여 컨테이너를 제어할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 이용하여 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;1234포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;6379포트&lt;/code&gt;로 연결하였고 localhost의 1234포트로 접속하면 하면 redis를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;테스트 결과 redis에 접속하여 새로운 키를 저장하고 불러오는데 성공했습니다. 실행이 간단한건 물론이고 호스트의 포트만 다르게 하면 하나의 서버에 여러개의 redis 서버를 띄우는 것도 매우 간단합니다.&lt;/p&gt;

&lt;h3 id=&quot;mysql-57-container&quot;&gt;MySQL 5.7 container&lt;/h3&gt;

&lt;p&gt;3번째 실행할 컨테이너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL 서버&lt;/code&gt;입니다. 가장 흔하게 사용하는 데이터베이스인데 이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 옵션을 이용하여 환경변수를 설정하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt; 옵션을 이용하여 컨테이너에 읽기 어려운 ID 대신 쉬운 이름을 부여할 예정입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt;옵션을 생략하면 도커가 자동으로 이름을 지어 줍니다. 이름은 유명한 과학자나 해커의 이름과 수식어를 조합하여 랜덤으로 &lt;a href=&quot;https://github.com/docker/docker/blob/master/pkg/namesgenerator/names-generator.go&quot;&gt;생성&lt;/a&gt;합니다. (ex - boring_wozniak) 우리나라 과학자 &lt;a href=&quot;https://github.com/docker/docker/issues/8996&quot;&gt;장영실&lt;/a&gt;도 등록되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/mysql/&quot;&gt;MySQL Docker hub&lt;/a&gt; 페이지에 접속하면 간단한 사용법과 환경변수에 대한 설명이 있습니다. 여러가지 설정값이 있는데 패스워드 없이 root계정을 만들기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/code&gt; 환경변수를 설정합니다. 그리고 컨테이너의 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;로 할당하고 백그라운드 모드로 띄우기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 줍니다. 포트는 &lt;code class=&quot;highlighter-rouge&quot;&gt;3306포트&lt;/code&gt;를 호스트에서 그대로 사용하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -h127.0.0.1 -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-mysql.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run mysql 5.7 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 순식간에 MySQL서버가 실행되었습니다. 이번 테스트는 호스트 OS에 MySQL 클라이언트가 설치되어 있어야 합니다. 추후에 실행중인 MySQL 도커 컨테이너에 접속하여 클라이언트를 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;처음 접속 시도시 에러가 난 화면은 MySQL 서버가 최초로 실행되면서 준비작업을 하기 때문에 발생하는 에러입니다. 컨테이너를 실행하면 백그라운드에서 MySQL 서버를 띄우는 시간이 필요하기 때문에 잠시 후에 다시 시도 했을 때 정상적으로 접속된 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;wordpress-container&quot;&gt;WordPress container&lt;/h3&gt;

&lt;p&gt;이번에는 블로그&lt;del&gt;보다 웹용으로 더 흔히 쓰이는&lt;/del&gt;엔진으로 유명한 &lt;a href=&quot;https://wordpress.com&quot;&gt;워드프레스&lt;/a&gt;를 실행합니다. 워드프레스는 데이터베이스가 필요하기 때문에 조금 복잡한 형태를 띄지만 크게 어렵지 않습니다. 바로 전에 생성했던 MySQL 컨테이너에 워드프레스 데이터베이스를 만들고 WordPress 컨테이너를 실행할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션을 이용하여 MySQL 컨테이너를 연결하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 환경변수와 IP정보를 공유하는데 링크한 컨테이너의 IP정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;에 자동으로 입력하므로 워드프레스 컨테이너가 MySQL 데이터베이스의 정보를 알 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, 워드프레스용 데이터베이스를 생성하고 워드프레스 컨테이너를 실행합니다. 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;8080포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;80포트&lt;/code&gt;로 연결하고 MySQL 컨테이너와 연결한 후 각종 데이터베이스 설정 정보를 환경변수로 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# create mysql database&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -h127.0.0.1 -uroot
create database wp CHARACTER SET utf8;
grant all privileges on wp.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; to wp@&lt;span class=&quot;s1&quot;&gt;'%'&lt;/span&gt; identified by &lt;span class=&quot;s1&quot;&gt;'wp'&lt;/span&gt;;
flush privileges;
quit

&lt;span class=&quot;c&quot;&gt;# run wordpress container&lt;/span&gt;
docker run -d -p 8080:80 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --link mysql:mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  wordpress&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-wp.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run wordpress container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너가 제대로 실행되었는지 웹 브라우저로 확인해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/wp.png&quot; alt=&quot;wordpress setup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;워드프레스가 실행되었습니다! 단지 이미지를 다운받고 적절한 환경변수를 입력하여 컨테이너를 실행했을 뿐입니다. 워드프레스 컨테이너 내부는 apache2와 php가 설치되어 있지만 추상화되어 있어 실행과정에선 드러나지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 예제는 테스트용으로만 사용해야 합니다. 운영 환경에서 사용하려면 추가적인 셋팅이 필요합니다. 이부분은 밑에서 다시 다룹니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 deprecated 되어 곧 사용할 수 없습니다. 대신 Docker network 기능을 이용해야 하지만 쉬운 이해를 돕기 위해 사용하였습니다. &lt;del&gt;참고만 하고 실제 사용은 ㄴㄴ&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제, 원하는 서비스가 있다면 이미지를 찾거나 직접 만들고, 어디서나 손쉽게 서비스를 실행할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;tensorflow&quot;&gt;tensorflow&lt;/h3&gt;

&lt;p&gt;마지막으로 이렇게 활용할 수 있다라는 예제로 tensorflow를 실행보도록 하겠습니다. &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;tensorflow&lt;/a&gt;는 손쉽게 머신러닝을 할 수 있는 툴입니다. tensorflow는 python으로 만들어져 python과 관련 패키지를 설치해야 합니다. 이번에 설치하는 이미지는 python과 함께 numpy, scipy, pandas, jupyter, scikit-learn, gensim, BeautifulSoup4, Tensorflow가 설치되어 있습니다. 뭔가 복잡해 보이지만 도커라면 손쉽게 실행해 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 8888:8888 -p 6006:6006 teamlab/pydata-tensorflow:0.1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치된 파일이 많아 다운로드 하는데 시간이 좀 걸립니다. 컨테이너가 실행되면 웹 브라우저에서 jupyter에 접속하여 머신러닝을 시작해 봅시다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/tensorflow.png&quot; alt=&quot;Hello, Tensorflow!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;와우! 성공적으로 tensorflow 테스트를 마쳤습니다. 이제 조금 있으면 A.I를 만들 수 있을 것 같습니다.(?!)&lt;/p&gt;

&lt;p&gt;여기까지 ubuntu, MySQL, redis, Wordpress, tensorflow를 실행해 보았습니다. 가상머신을 이용해서 동일한 작업을 했다면 컴퓨터가 엄청나게 버벅이기 시작했겠지만 컨테이너 기반의 도커를 이용하여 매우 가볍게 실행하고 있습니다. 내부 구조나 설치과정은 자세히 모르지만, 간단한 도커 명령어로 여러개의 서비스를 순식간에 실행하고 사용할 수 있다니 정말 짱짱맨입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;도커 기본 명령어&lt;/h2&gt;

&lt;p&gt;앞에서 도커의 &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어를 이용하여 여러개의 컨테이너를 실행했습니다. 이제 컨테이너의 상태를 살펴보고 어떤 이미지가 설치되어 있는지 확인하는 명령어를 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;ps&quot;&gt;컨테이너 목록 확인하기 (ps)&lt;/h3&gt;

&lt;p&gt;컨테이너 목록을 확인하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker ps [OPTIONS]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;일단 기본옵션과 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a, --all&lt;/code&gt; 옵션만 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED              STATUS              PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             About a minute ago   Up About a minute   0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   8 minutes ago        Up 8 minutes        0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   9 minutes ago        Up 9 minutes        0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   16 minutes ago       Up 9 minutes        0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt; 명령어는 실행중인 컨테이너 목록을 보여줍니다. detached mode로 실행중인 컨테이너들이 보입니다. 어떤 이미지를 기반으로 만들었는지 어떤 포트와 연결이 되어있는지 등 간단한 내용을 보여줍니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; 옵션을 추가로 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps -a&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS                      PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             2 minutes ago       Up 2 minutes                0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   9 minutes ago       Up 9 minutes                0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   10 minutes ago      Up 10 minutes               0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   18 minutes ago      Up 10 minutes               0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla
e1a00c5934a7        ubuntu:16.04                    &quot;/bin/bash&quot;              32 minutes ago      Exited (0) 32 minutes ago                                                            berserk_visvesvaraya&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 실행했다가 종료된 컨테이너(Exited (0))가 추가로 보입니다. 컨테이너는 종료되어도 삭제되지 않고 남아있습니다. 종료된 건 다시 시작할 수 있고 컨테이너의 읽기/쓰기 레이어는 그대로 존재합니다. 명시적으로 삭제를 하면 깔끔하게 컨테이너가 제거됩니다.&lt;/p&gt;

&lt;h3 id=&quot;stop&quot;&gt;컨테이너 중지하기 (stop)&lt;/h3&gt;

&lt;p&gt;실행중인 컨테이너를 중지하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker stop [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;옵션은 특별한게 없고 실행중인 컨테이너를 하나 또는 여러개 (띄어쓰기로 구분) 중지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 실행한 tensorflow 컨테이너는 더이상 필요가 없으니 중지해 보겠습니다. 중지하려면 컨테이너의 ID 또는 이름을 입력하면 됩니다. tensorflow 컨테이너의 ID를 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;명령을 통해 확인하고 중지해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker stop &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps -a &lt;span class=&quot;c&quot;&gt;# show all containers&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커 ID의 전체 길이는 64자리 입니다. 하지만 명령어의 인자로 전달할 때는 전부 입력하지 않아도 됩니다. 예를 들어 ID가 &lt;code class=&quot;highlighter-rouge&quot;&gt;abcdefgh...&lt;/code&gt;라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;abcd&lt;/code&gt;만 입력해도 됩니다. 앞부분이 겹치지 않는다면 1-2자만 입력해도 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잠시 기다리면 tensorflow 컨테이너가 종료됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ps -a&lt;/code&gt;명령어를 입력하여 종료되었는지 확인합니다.&lt;/p&gt;

&lt;h3 id=&quot;rm&quot;&gt;컨테이너 제거하기 (rm)&lt;/h3&gt;

&lt;p&gt;종료된 컨테이너를 완전히 제거하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rm [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;종료 명령어도 옵션은 특별한게 없습니다. 종료된 컨테이너를 하나 또는 여러개 삭제할 수 있습니다. 종료된 ubuntu 컨테이너와 tensorflow 컨테이너를 삭제해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps -a &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker rm &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;UBUNTU_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps -a &lt;span class=&quot;c&quot;&gt;# check exist&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너가 말끔히 삭제되었습니다. 호스트 OS는 아무런 흔적도 남아있지 않고 컨테이너만 격리된 상태로 실행되었다가 삭제되었습니다. 시스템이 꼬일 걱정이 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;중지된 컨테이너를 일일이 삭제 하는 건 귀찮은 일입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;docker rm -v $(docker ps -a -q -f status=exited)&lt;/code&gt; 명령어를 입력하면 중지된 컨테이너 ID를 가져와서 한번에 삭제합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;images&quot;&gt;이미지 목록 확인하기 (images)&lt;/h3&gt;

&lt;p&gt;도커가 다운로드한 이미지 목록을 보는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker images [OPTIONS] [REPOSITORY[:TAG]]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;간단하게 도커 이미지 목록을 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
wordpress                   latest              b1fe82b15de9        43 hours ago        400.2 MB
redis                       latest              45c3ea2cecac        44 hours ago        182.9 MB
mysql                       5.7                 f3694c67abdb        46 hours ago        400.1 MB
ubuntu                      16.04               104bec311bcd        4 weeks ago         129 MB
teamlab/pydata-tensorflow   0.1                 7bdf5d7e0191        6 months ago        3.081 GB&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지 주소와 태그, ID, 생성시점, 용량이 보입니다. 이미지가 너무 많이 쌓이면 용량을 차지하기 때문에 사용하지 않는 이미지는 지우는 것이 좋습니다.&lt;/p&gt;

&lt;h3 id=&quot;pull&quot;&gt;이미지 다운로드하기 (pull)&lt;/h3&gt;

&lt;p&gt;이미지를 다운로드하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker pull [OPTIONS] NAME[:TAG|@DIGEST]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:14.04&lt;/code&gt;를 다운받아보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker pull ubuntu:14.04&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 입력하면 이미지가 없을 때 자동으로 다운받으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 언제 쓰는지 궁금할 수 있는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;은 최신버전으로 다시 다운 받습니다. 같은 태그지만 이미지가 업데이트 된 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 통해 새로 다운받을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;rmi&quot;&gt;이미지 삭제하기 (rmi)&lt;/h3&gt;

&lt;p&gt;이미지를 삭제하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rmi [OPTIONS] IMAGE [IMAGE...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;images&lt;/code&gt;명령어를 통해 얻은 이미지 목록에서 이미지 ID를 입력하면 삭제가 됩니다. 단, 컨테이너가 실행중인 이미지는 삭제되지 않습니다. 컨테이너는 이미지들의 레이어를 기반으로 실행중이므로 당연히 삭제할 수 없습니다.&lt;/p&gt;

&lt;p&gt;tensorflow는 더 이상 사용하지 않으니 이미지를 제거해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images &lt;span class=&quot;c&quot;&gt;# get image ID&lt;/span&gt;
docker rmi &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_IMAGE_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Untagged: teamlab/pydata-tensorflow:0.1
Untagged: teamlab/pydata-tensorflow@sha256:cb5e036afc0aa647a6fe1f384475275aeed946c751de5209d84282c986589b7f
Deleted: sha256:7bdf5d7e0191a6133a385ac69ec6a07be46b08cf5b5e6b826a89b9b47aadabe5
Deleted: sha256:9d72165f240630813a39e2f802a75f45caa2bc230881fa73c2f620c4b04686b5
Deleted: sha256:5c90ba76fff96b155b8a9446f2fb42d2ae04566832f3929df41dc52c0ae462ae
Deleted: sha256:1e23db6b02673d34c54fe87ec958ae8f2e310ca4aa911c7f8488b6c7988bfba0
Deleted: sha256:759641367a6788b55361f9eeedcbc356f8e464ef794a883b5621fba6e23c6b18
Deleted: sha256:b5d017cd48c0d8461230b5ab0aed68e27a4018996344470db3c4b5adba10b49f
Deleted: sha256:470cdb158a12a416ffebde8d299fdbde28d56da062c701bf7a51d6484f777e97
Deleted: sha256:d136c3aea28597fadb667a084a6e5701e287fd36f03cc9555b0e5bca2e674f9b
Deleted: sha256:e62e6cce767baec3711dc1ec8cfcd76f68b88a6ca9ffcd2f3d22345048a0f8d7
Deleted: sha256:8e0761516c1c1ad792c9e67d1541d574905f067cb3b67e19a3af58ca7389eee9
Deleted: sha256:ad45f6539a6ce95216c9990d26b4b2e44c0b50637c1f0949b6965610b023fd97
Deleted: sha256:ebe200261801abef54e60699c098def3a4bd39a7b4833f164b99e23a88e8a98a
Deleted: sha256:698c310f0ec8a1f607a59f15a6affa7d9d21e21d9eaf6eb65b6ab6f33fcb62b4
Deleted: sha256:e5da0b4fd6d0143d7953e47a244a9be16919d1f4018e128e82fba6df967e790e
Deleted: sha256:7d8ffbfe2c1a55581e08b81f34506a746022e5beeb85f5848154b0b7d41208cf
Deleted: sha256:854cd556e616f5e5b21cd69f1e7c0d225c9b28eb5cf653aa4aa0937930298d72
Deleted: sha256:10e6f47febf1912a4d7a08b7652e360905a6ba8b76f188fd167c8d6afa09951a
Deleted: sha256:737ee41ad49072c9ba8301a17751e16d69c1045df74ac77f4ae05f849b08faec
Deleted: sha256:62b01cf4b1440085b0b9311372eb8acb509581faf655b2837a2e234c12fdfd24
Deleted: sha256:7dcdbe5fc9a2290d596e3bab8052c3141a69a451a29a98bd12678a7139891094
Deleted: sha256:8a9f069492b445dc889f9639572dc289f7c3fc1ac4d597a7468614fa2c624091
Deleted: sha256:34a63dcc0c5574597918a8e9df80e364f9fec88c0f4e25a0e5187acd241773ad
Deleted: sha256:af6fa43db2e379d3f0f3f36d61a0ece782133314c678d7223872eb7158f102ba
Deleted: sha256:efbafc7aa3a87241c10bf0c495672cf4a7b0cc2d23db06120ae1e13528316f82
Deleted: sha256:ea0c616be3659f71afce45eff2e28e51e04b25f1ae58b306521e6877f3adf2df
Deleted: sha256:f2dccb8902ea3d85aa9a954af894f59100fc00fa78c09b213c76dcf2727e3c3e
Deleted: sha256:3fe0adbd3614d696ded87bcb47aed81f49b113770a3778e276cd88abe9010b9f
Deleted: sha256:b88d260c0bcff3b4434a39ba33f58a2f9807400d664185057edd393133630242
Deleted: sha256:4de08f41d77237b2dbc0660036fe8352fdbacf6e079623d318003ed7e833a40a
Deleted: sha256:f32c8f02713c719181c2bf32be13dbd333932411d5fc3e0b6cfb780da8bb8124
Deleted: sha256:985d69571ed5d6d7e69bf58232fd8f30f8cd4ac77f41122a80fdab56347ec22d
Deleted: sha256:8509bc9969877f784fa6e704098cbcf77d694596644f389c5a2fefe5267878ab
Deleted: sha256:0ad5b9ed74fe2eee856b368d426cdd9335a6a6ecec0c4c705b5153c219a82692
Deleted: sha256:b159c847c5b9b899c23eba59395a4d7b7b275a8c686191ed6c4ef21ceadad8a2
Deleted: sha256:89e9f76552fd1a8d249c1e133e4c8964fe1f9104bb708db1e0ca6f6171ee4c22
Deleted: sha256:6d31e1827ca8f5037077314b2403eabd82590f9eae8baf956a2c2a819db68d4e
Deleted: sha256:7f4734de8e3dd402f10030f06bcb8781129b1eb6a25c58811a76d015f2a0982f&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지가 삭제되었습니다. 이미지는 여러개의 레이어로 구성되어 있기 때문에 모든 레이어가 삭제된 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;컨테이너 둘러보기&lt;/h2&gt;

&lt;p&gt;도커에 대한 아주아주아주 기본적인 명령어를 살펴보았습니다. 사실 저 명령어들과 이번에 살펴볼 &lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; 명령어를 익히면 도커에서 사용하는 명령어는 거의 다 익혔다고 할 수 있습니다. 다른 명령어는 필요에 따라 하나하나 살펴보면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;logs&quot;&gt;컨테이너 로그 보기 (logs)&lt;/h3&gt;

&lt;p&gt;컨테이너가 정상적으로 동작하는지 확인하는 좋은 방법은 로그를 확인하는 것 입니다. 로그를 확인하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker logs [OPTIONS] CONTAINER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기본 옵션과, &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--tail&lt;/code&gt; 옵션을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;기존에 생성해 놓은 워드프레스 컨테이너 로그를 확인해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps
docker logs &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;WordPress not found in /var/www/html - copying now...
Complete! WordPress has been successfully copied to /var/www/html
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
[Thu Jan 19 16:10:16.507735 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.29 configured -- resuming normal operations
[Thu Jan 19 16:10:16.507776 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET / HTTP/1.1&quot; 302 379 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET /wp-admin/install.php HTTP/1.1&quot; 200 2513 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/buttons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 1698 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/zxcvbn-async.min.js?ver=1.0 HTTP/1.1&quot; 200 582 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/css/install.min.css?ver=4.7.1 HTTP/1.1&quot; 200 2329 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1 HTTP/1.1&quot; 200 4366 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.1&quot; 200 34120 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/password-strength-meter.min.js?ver=4.7.1 HTTP/1.1&quot; 200 825 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너에서 실행한 로그가 쭈욱 보입니다. 아무 옵션을 주지 않았을 때는 전체 로그를 &lt;del&gt;무식하게&lt;/del&gt; 전부 다 출력합니다. 너무 많으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;--tail&lt;/code&gt;옵션으로 마지막 10줄만 출력해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs --tail 10 &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;마지막 10줄만 보니 좀 나아 보입니다. 이제 실시간으로 로그가 생성되는 걸 확인해보겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 옵션으로 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs -f &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-log-f.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker logs -f&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;로그를 켜 놓은 상태에서 워드프레스 페이지를 새로고침하면 브라우저 접속 로그가 실시간으로 보입니다. 가장 흔하게 사용하는 옵션이고 로그 보기를 중지하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로그에 대해 좀 더 자세히&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램마다 로그 파일은 제각각 생길텐데 어떻게 저 로그가 나올까 라는 의문이 생깁니다. 도커는 로그파일을 자동으로 알아채는게 아니라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams&quot;&gt;표준 스트림&lt;/a&gt;&lt;sub&gt;Standard streams&lt;/sub&gt; 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;를 수집합니다. 따라서 컨테이너에서 실행되는 프로그램의 로그 설정을 파일이 아닌 표준출력으로 바꾸어야 합니다. 단지 출력 방식만 바꾸는 것으로 모든 컨테이너는 로그에 대해 같은 방식으로 관리할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;또하나 중요한 점은 컨테이너의 로그파일은 json 방식으로 어딘가에 저장이 됩니다. 로그가 많으면 은근히 파일이 차지하는 용량이 커지므로 주의해야합니다. 도커는 다양한 플러그인을 지원하여 json이 아닌 특정 로그 서비스에 스트림을 전달할 수 있습니다. 어느 정도 앱의 규모가 커지면 기본적인 방식 대신 로그 서비스를 이용하는 걸 고려해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;exec&quot;&gt;컨테이너 명령어 실행하기 (exec)&lt;/h3&gt;

&lt;p&gt;컨테이너를 관리하다 보면 실행중인 컨테이너에 들어가보거나 컨테이너의 파일을 실행하고 싶을 때가 있습니다. 컨테이너에 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt;를 설치하면 되지 않을까? 라고 생각할 수 있지만 SSH는 권장하지 않습니다. &lt;del&gt;하지 말라고 하면 꼭 하는 분들이 있던데 제발..&lt;/del&gt; 예전에는 &lt;a href=&quot;https://github.com/jpetazzo/nsenter&quot;&gt;nsenter&lt;/a&gt;라는 프로그램을 이용하였는데 docker에 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;라는 명령어로 흡수되었습니다.&lt;/p&gt;

&lt;p&gt;컨테이너 명령어를 실행하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker exec [OPTIONS] CONTAINER COMMAND [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어와 유사해 보입니다. 차이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;은 새로 컨테이너를 만들어서 실행하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;는 실행중인 컨테이너에 명령어를 내리는 정도입니다.&lt;/p&gt;

&lt;p&gt;일단, 가볍게 실행중인 &lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 컨테이너에 접속해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; -it mysql /bin/bash

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-bash.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;키보드 입력이 필요하니 run 명령어와 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 주었고 bash 쉘로 접속하여 마치 가상머신에 들어온 것 같은 느낌이 듭니다. 접속한 이후에는 어떤 작업도 할 수 있고 컨테이너를 마음껏 건드릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;쉘로 완전한 권한을 얻는 방법말고 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;명령어를 실행 할 수도 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; -it mysql mysql -uroot

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-mysql.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec mysql&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;이제, 호스트 OS에 mysql을 설치하지 않아도 mysql 클라이언트를 사용할 수 있습니다. 굳이 복잡한 작업이 필요 없는 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션없이 단순하게 명령을 실행하고 종료할 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;컨테이너 업데이트&lt;/h2&gt;

&lt;p&gt;이제 지금까지 배운 모든걸 정리해서 컨테이너를 새로운 버전으로 업데이트 하는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/container-update.png&quot; alt=&quot;도커 컨테이너 업데이트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 컨테이너를 업데이트 하려면 새 버전의 이미지를 다운(&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;)받고 기존 컨테이너를 삭제(&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt;) 한 후 새 이미지를 기반으로 새 컨테이너를 실행(&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;)하면 됩니다. 배포와 관련된 자세한 사항은 다음글에서 이야기하고 여기선 그냥 그렇구나 하고 이해합시다.&lt;/p&gt;

&lt;p&gt;컨테이너를 삭제한다는 건 컨테이너에서 생성된 파일이 사라진다는 뜻입니다. 데이터베이스라면 그동안 쌓였던 데이터가 모두 사라진다는 것이고 웹 어플리케이션이라면 그동안 사용자가 업로드한 이미지가 모두 사라진다는 것입니다. ㄷㄷ&lt;/p&gt;

&lt;p&gt;이런 상황&lt;del&gt;도커 도입했다가 퇴사&lt;/del&gt;을 방지하기 위해 컨테이너 삭제시 유지해야하는 데이터는 반드시 컨테이너 내부가 아닌 외부 스토리지에 저장해야 합니다. 가장 좋은 방법은 &lt;a href=&quot;http://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html&quot;&gt;AWS S3&lt;/a&gt;같은 클라우드 서비스를 이용하는 것이고 그렇지 않으면 데이터 볼륨&lt;sub&gt;Data volumes&lt;/sub&gt;을 컨테이너에 추가해서 사용해야 합니다. 데이터 볼륨을 사용하면 해당 디렉토리는 컨테이너와 별도로 저장되고 컨테이너를 삭제해도 데이터가 지워지지 않습니다.&lt;/p&gt;

&lt;p&gt;데이터 볼륨을 사용하는 방법은 몇가지가 있는데 여기서는 호스트의 디렉토리를 마운트해서 사용하는 방법에 대해 알아봅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어에서 소개한 옵션중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 옵션을 드디어 사용해 보겠습니다. MySQL이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리에 모든 데이터베이스 정보가 담기므로 호스트의 특정 디렉토리를 연결해주면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -v /my/own/datadir:/var/lib/mysql &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &amp;lt;- volume mount&lt;/span&gt;
  mysql:5.7&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 샘플은 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리로 마운트 하였습니다. 이제 데이터베이스 파일은 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리에 저장되고 컨테이너를 삭제해도 데이터는 사라지지 않습니다. 최신버전의 MySQL 이미지를 다운받고 다시 컨테이너를 실행할 때 동일한 디렉토리를 마운트 한다면 그대로 데이터를 사용할 수 있습니다. &lt;del&gt;만세!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-compose&quot;&gt;Docker Compose&lt;/h2&gt;

&lt;p&gt;지금까지 도커를 커맨드라인에서 명령어로 작업했습니다. 지금은 간단한 작업만 했기 때문에 명령이 길지 않지만 컨테이너 조합이 많아지고 여러가지 설정이 추가되면 명령어가 금방 복잡해집니다.&lt;/p&gt;

&lt;p&gt;도커는 복잡한 설정을 쉽게 관리하기 위해 &lt;a href=&quot;https://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;방식의 설정파일을 이용한 &lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;Docker Compose&lt;/a&gt;라는 툴을 제공합니다. 깊게 파고들면 은근 기능이 많고 복잡한데 이번에는 아주 가볍게 다루고 지나가도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;설치하기&lt;/h3&gt;

&lt;p&gt;Docker for Mac 또는 Docker for Windows를 설치했다면 자동으로 설치됩니다. 리눅스의 경우 다음 명령어를 입력하여 설치합니다. 그냥 설치파일 하나 다운받으면 됩니다. &lt;del&gt;Golang 짱&lt;/del&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl -L &lt;span class=&quot;s2&quot;&gt;&quot;https://github.com/docker/compose/releases/download/1.9.0/docker-compose-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;uname -s&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;uname -m&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
&lt;span class=&quot;c&quot;&gt;# test&lt;/span&gt;
docker-compose version&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;wordpress-&quot;&gt;wordpress 만들기&lt;/h3&gt;

&lt;p&gt;기존에 명령어로 만들었던 wordpress를 compose를 이용해 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 빈 디렉토리를 하나 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;파일을 만들어 설정을 입력합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;version: &amp;#39;2&amp;#39;

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: wordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     volumes:
       - wp_data:/var/www/html
     ports:
       - &amp;quot;8000:80&amp;quot;
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
    db_data:
    wp_data:&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/7c76c1a90e65606f5e5f55f83943eac2.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;몇몇 생소해보이는 설정이 눈에 보이지만, 일단 실행해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker-compose up&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;https://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-compose.json&quot; poster=&quot;npt:0:15&quot; speed=&quot;2&quot; theme=&quot;snazzy&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker-compose&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 아주 손쉽게 워드프레스가 만들어 졌습니다. 단지 명령어를 설정파일로 바꾼거에 불과하지만 가독성과 편리성은 훨씬 향상되었습니다.&lt;/p&gt;

&lt;p&gt;Docker Compose의 다른 기능과 생소한 설정내용은 숙제로 남겨드립니다. 원래 개발공부라는게 왠만큼 했다고 생각하면 또 다른게 나오고 끊임없이 공부해야 하는 분야입니다. &lt;del&gt;화이팅!&lt;/del&gt; 도커에 대해 이해를 했다면 Docker Compose 또한 쉽게 사용할 수 있을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;여기까지 도커에 대해 기본적인 내용부터 컨테이너를 실행하고 살펴보는 방법까지 알아보았습니다. 도커가 어떤건지, 컨테이너가 뭔지, 이미지가 뭔지 감이 좀 오시나요? 이제 남이 만든 이미지를 사용하는 것이 아니라 직접 이미지를 만들고 컨테이너를 여러 서버로 배포하는 방법을 알아봐야하는데… 다음글에서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 도커란 무엇인가?&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기 ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Thu, 19 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</guid>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        <category>Container</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>초보를 위한 도커 안내서 - 도커란 무엇인가?</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느날 친구한테 메시지를 받았습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커 공부 좀 하려는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello world&lt;/code&gt; 문서 어떤 거 보면서 시작하는 게 좋음?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;구글에서 docker 검색ㄱㄱ&lt;/code&gt;라고 말하려다 인터넷에 있는 &lt;a href=&quot;https://github.com/remotty/documents.docker.co.kr&quot;&gt;도커 관련 글&lt;/a&gt;과 &lt;a href=&quot;http://youtube.opencontainer.co.kr&quot;&gt;동영상&lt;/a&gt; 중에 입문자용 링크를 몇 개 전달해 주었습니다. 이후에도 몇 번 비슷한 요청을 받으면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;도커에 대해 가볍게 정리해보자&lt;/code&gt;라는 생각이 들었고 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;예전 글(도커를 이용한 웹서비스 무중단 배포하기)&lt;/a&gt;과 밋업 때 발표했던 내용, 그리고 그동안의 사용경험을 모아 글을 작성하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 글은 도커에 대해 1도 모르는 시스템 관리자나 서버 개발자를 대상으로 도커 전반에 대해 얕고 넓은 지식을 담고 있습니다. 도커가 등장한 배경과 도커의 역사, 그리고 도커의 핵심 개념인 컨테이너와 이미지에 대해 알아보고 실제로 도커를 설치하고 컨테이너를 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 도커란 무엇인가? ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;서버를 관리한다는 것&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/contraption-illustration.jpg&quot; alt=&quot;복잡하고 어려운 서버관리&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 서버를 관리한다는 건 복잡하고 어려우며 고오급 개발자들의 섬세한 작업이 필요한 영역입니다.&lt;/p&gt;

&lt;p&gt;2006년 병역특례를 시작하고 맨 처음 했던 일은 매뉴얼을 보고 Redhat Enterprise Linux 4에 Oracle 10g을 설치하는 일이였습니다. 정확히 기억이 나지는 않지만 설치 매뉴얼은 길고 복잡했고 알 수 없는 이유로 자꾸 설치를 실패하였습니다. 제대로 설치가 되지 않으면 다시 OS를 설치하는 것부터 반복하여 몇 번을 재설치한 끝에 성공하곤 했습니다. 회사에서 사용하는 리눅스와 오라클 버전은 딱 정해져 있었고 버전을 업데이트 하는 건 엄청난 리스크였기 때문에 서버는 최대한 건드리지 않고 그대로 두는 게 최선의 방법이였습니다.&lt;/p&gt;

&lt;p&gt;새로운 서버를 셋팅하는 날은 밤을 새는 날이였고 몇 번 밤을 새다보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;의 달인이 되어 있었습니다. 어느 정도 익숙해졌다고 생각한 시점에도 리눅스 배포판이 바뀌거나 환경이 달라지면 꼭 문제가 생기곤 했습니다.&lt;/p&gt;

&lt;p&gt;하나의 서버에 여러개의 프로그램을 설치하는 것도 문제였는데 서로 사용하는 라이브러리의 버전이 다르거나 동일한 포트를 사용하는 경우는 설치가 굉장히 까다로웠습니다. 차라리 서로 다른 서버에 설치하는게 나았고 그렇게 조립PC는 늘어나고 자원은 낭비됩니다.&lt;/p&gt;

&lt;p&gt;시간이 흐르면서 서버 환경이 계속 바뀌는데 &lt;a href=&quot;https://www.centos.org/&quot;&gt;CentOS&lt;/a&gt;에 익숙해지면 &lt;a href=&quot;https://www.ubuntu.com/&quot;&gt;Ubuntu&lt;/a&gt;를 써야하는 일이 생기고 &lt;a href=&quot;https://aws.amazon.com&quot;&gt;AWS&lt;/a&gt;에 익숙해지면 &lt;a href=&quot;https://azure.microsoft.com&quot;&gt;Azure&lt;/a&gt;를 써야하는 일이 생깁니다. &lt;a href=&quot;https://www.chef.io/chef/&quot;&gt;Chef&lt;/a&gt;의 cookbook에 익숙해지면 &lt;a href=&quot;https://www.ansible.com/&quot;&gt;Ansible&lt;/a&gt;의 playbook을 작성해야 하는 일이 생깁니다. &lt;del&gt;야호&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DevOps&quot;&gt;DevOps&lt;/a&gt;의 등장으로 개발주기가 짧아지면서 배포는 더 자주 이루어지고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Microservices&quot;&gt;마이크로서비스 아키텍쳐&lt;/a&gt;가 유행하면서 프로그램은 더 잘게 쪼개어져 관리는 더 복잡해집니다. 새로운 툴은 계속해서 나오고 클라우드의 발전으로 설치해야 할 서버가 수백, 수천대에 이르는 &lt;code class=&quot;highlighter-rouge&quot;&gt;1 나누기 0&lt;/code&gt; &lt;del&gt;답이 없는&lt;/del&gt; 같은 상황에서 &lt;a href=&quot;https://www.docker.com/&quot;&gt;도커(Docker)&lt;/a&gt; 가 등장하고 서버관리 방식이 완전히 바뀌게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;도커의 역사&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/the-future-of-linux-containers.png&quot; alt=&quot;The future of Linux Containers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 2013년 3월 산타클라라에서 열린 Pycon Conference에서 dotCloud의 창업자인 Solomon Hykes가 &lt;a href=&quot;https://youtu.be/wW9CAH9nSLs&quot;&gt;The future of Linux Containers&lt;/a&gt; 라는 세션을 발표하면서 처음 세상에 알려졌습니다.&lt;/p&gt;

&lt;p&gt;이 발표 이후 도커가 인기를 얻으면서 2013년 10월 아예 회사이름을 도커(Docker Inc.)로 바꾸고 2014년 6월 도커 1.0을 발표합니다. 2014년 8월 도커에 집중하기 위해 dotCloud 플랫폼을 매각하고 2015년 4월 $95M(약 1,100억원) 투자를 유치한 후 계속해서 빠르게 성장하고 있습니다. (현재까지 총 투자액은 $180M이며 2016년 6월 MS에서 $4B/₩4조에 인수하려 했다는 &lt;a href=&quot;https://www.sdxcentral.com/articles/news/sources-microsoft-tried-to-buy-docker-for-4b/2016/06/&quot;&gt;기사&lt;/a&gt;가 있습니다.) &lt;del&gt;누가 오픈소스는 돈이 되지 않는다고 했는가?!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-survey.png&quot; alt=&quot;The Evolution of the Modern Software Supply Chain - The Docker Survey, 2016&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;도커에서한&lt;/del&gt; 2016년 설문조사에서 90%가 개발에 사용중이고 80%가 DevOps에 사용할 예정이며 58%가 운영환경에서 사용중이라고 합니다. 2014년 도커 서울 밋업을 시작할 때만 해도 대부분의 사람들이 도커를 잘 모르고 개념도 이해하지 못했는데 이제는 거의 모르는 사람이 없을 정도로 널리 쓰이고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;도커란?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-works.png&quot; alt=&quot;도커는 컨테이너를 관리하는 플랫폼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 &lt;strong&gt;컨테이너 기반의 오픈소스 가상화 플랫폼&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;컨테이너라 하면 배에 실는 네모난 화물 수송용 박스를 생각할 수 있는데 각각의 컨테이너 안에는 옷, 신발, 전자제품, 술, 과일등 다양한 화물을 넣을 수 있고 규격화되어 컨테이너선이나 트레일러등 다양한 운송수단으로 쉽게 옮길 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버에서 이야기하는 컨테이너도 이와 비슷한데 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줍니다. 백엔드 프로그램, 데이터베이스 서버, 메시지 큐등 어떤 프로그램도 컨테이너로 추상화할 수 있고 조립PC, AWS, Azure, Google cloud등 어디에서든 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;컨테이너를 가장 잘 사용하고 있는 기업은 구글인데 &lt;a href=&quot;https://speakerdeck.com/jbeda/containers-at-scale&quot;&gt;2014년 발표&lt;/a&gt; 에 따르면 구글은 모든 서비스들이 컨테이너로 동작하고 매주 20억 개의 컨테이너를 구동 한다고 합니다. &lt;del&gt;갓구글&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;컨테이너(Container)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-container.png&quot; alt=&quot;docker container&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다. 가상화 기술의 하나지만 기존방식과는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;기존의 가상화 방식은 주로 &lt;strong&gt;OS를 가상화&lt;/strong&gt;하였습니다.&lt;/p&gt;

&lt;p&gt;우리에게 익숙한 &lt;a href=&quot;http://www.vmware.com/&quot;&gt;VMware&lt;/a&gt;나 &lt;a href=&quot;https://www.virtualbox.org&quot;&gt;VirtualBox&lt;/a&gt;같은 가상머신은 호스트 OS위에 게스트 OS 전체를 가상화하여 사용하는 방식입니다. 이 방식은 여러가지 OS를 가상화(리눅스에서 윈도우를 돌린다던가) 할 수 있고 비교적 사용법이 간단하지만 무겁고 느려서 운영환경에선 사용할 수 없었습니다.&lt;/p&gt;

&lt;p&gt;이러한 상황을 개선하기 위해 CPU의 가상화 기술(&lt;a href=&quot;https://en.wikipedia.org/wiki/Hardware-assisted_virtualization&quot;&gt;HVM&lt;/a&gt;)을 이용한 &lt;a href=&quot;http://www.linux-kvm.org/&quot;&gt;KVM&lt;/a&gt;&lt;sub&gt;Kernel-based Virtual Machine&lt;/sub&gt;과 &lt;a href=&quot;https://en.wikipedia.org/wiki/Paravirtualization&quot;&gt;반가상화&lt;/a&gt; &lt;sub&gt;Paravirtualization&lt;/sub&gt;방식의 &lt;a href=&quot;https://www.xenproject.org/&quot;&gt;Xen&lt;/a&gt;이 등장합니다. 이러한 방식은 게스트 OS가 필요하긴 하지만 전체OS를 가상화하는 방식이 아니였기 때문에 호스트형 가상화 방식에 비해 성능이 향상되었습니다. 이러한 기술들은 &lt;a href=&quot;https://www.openstack.org/&quot;&gt;OpenStack&lt;/a&gt;이나 AWS, &lt;a href=&quot;https://www.rackspace.com/&quot;&gt;Rackspace&lt;/a&gt;같은 클라우드 서비스에서 가상 컴퓨팅 기술의 기반이 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/vm-vs-docker.png&quot; alt=&quot;가상머신과 도커&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전가상화든 반가상화든 추가적인 OS를 설치하여 가상화하는 방법은 어쨋든 성능문제가 있었고 이를 개선하기 위해 &lt;strong&gt;프로세스를 격리&lt;/strong&gt; 하는 방식이 등장합니다.&lt;/p&gt;

&lt;p&gt;리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작합니다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거어어어어의 손실이 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커의 기본 네트워크 모드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bridge&lt;/code&gt;모드로 약간의 성능 손실이 있습니다. 네트워크 성능이 중요한 프로그램의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt; 옵션을 고려해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하나의 서버에 여러개의 컨테이너를 실행하면 서로 영향을 미치지 않고 독립적으로 실행되어 마치 가벼운 VM&lt;sub&gt;Virtual Machine&lt;/sub&gt;을 사용하는 느낌을 줍니다. 실행중인 컨테이너에 접속하여 명령어를 입력할 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;으로 패키지를 설치할 수 있으며 사용자도 추가하고 여러개의 프로세스를 백그라운드로 실행할 수도 있습니다. CPU나 메모리 사용량을 제한할 수 있고 호스트의 특정 포트와 연결하거나 호스트의 특정 디렉토리를 내부 디렉토리인 것처럼 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;새로운 컨터이너를 만드는데 걸리는 시간은 겨우 1-2초&lt;del&gt;(체감 0.001초)&lt;/del&gt;로 가상머신과 비교도 할 수 없이 빠릅니다.&lt;/p&gt;

&lt;p&gt;이러한 컨테이너라는 개념은 도커가 처음 만든 것이 아닙니다. 도커가 등장하기 이전에, 프로세스를 격리하는 방법으로 리눅스에서는 cgroups&lt;sub&gt;control groups&lt;/sub&gt;와 namespace를 이용한 &lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LXC&lt;/a&gt;&lt;sub&gt;Linux container&lt;/sub&gt;가 있었고 FreeBSD에선 &lt;a href=&quot;https://www.freebsd.org/doc/handbook/jails.html&quot;&gt;Jail&lt;/a&gt;, Solaris에서는 &lt;a href=&quot;https://docs.oracle.com/cd/E18440_01/doc.111/e18415/chapter_zones.htm#OPCUG426&quot;&gt;Solaris Zones&lt;/a&gt;이라는 기술이 있었습니다. 구글에서는 고오오급 기술자들이 직접 컨테이너 기술을 만들어 사용하였고 &lt;a href=&quot;https://github.com/google/lmctfy&quot;&gt;lmctfy(Let Me Contain That For You)&lt;/a&gt;라는 &lt;del&gt;뭐라고 읽어야 할지 알 수 없는&lt;/del&gt; 오픈소스 컨테이너 기술을 공개했지만 성공하진 못했습니다.&lt;/p&gt;

&lt;p&gt;도커는 LXC를 기반으로 시작해서 0.9버전에서는 자체적인 &lt;a href=&quot;https://github.com/docker/libcontainer&quot;&gt;libcontainer&lt;/a&gt; 기술을 사용하였고 추후 &lt;a href=&quot;http://runc.io/&quot;&gt;runC&lt;/a&gt;기술에 합쳐졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미지(Image)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-image.png&quot; alt=&quot;Docker image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 가장 중요한 개념은 컨테이너와 함께 이미지라는 개념입니다.&lt;/p&gt;

&lt;p&gt;이미지는 &lt;strong&gt;컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것&lt;/strong&gt;으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.&lt;/p&gt;

&lt;p&gt;ubuntu이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 MySQL이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보등을 가지고 있습니다. 좀 더 복잡한 예로 Gitlab 이미지는 centos를 기반으로 ruby, go, database, redis, gitlab source, nginx등을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;말그대로 이미지는 컨테이너를 실행하기 위한 모오오오오든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다. 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다. 한 서버에 여러개의 컨테이너를 실행할 수 있고, 수십, 수백, 수천대의 서버도 문제없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-store.png&quot; alt=&quot;Docker Store&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지는 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker hub&lt;/a&gt;에 등록하거나 &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;Docker Registry&lt;/a&gt; 저장소를 직접 만들어 관리할 수 있습니다. 현재 공개된 도커 이미지는 50만개가 넘고 Docker hub의 이미지 다운로드 수는 80억회에 이릅니다. 누구나 쉽게 이미지를 만들고 배포할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;왜 이렇게 핫한가?&lt;/h2&gt;

&lt;p&gt;도커는 완전히 새로운 기술이 아니며 이미 존재하는 기술을 잘 포장했다고 볼 수 있습니다. &lt;del&gt;(마치 최신기술을 잘 포장해서 만든 아이폰처럼)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;컨테이너, &lt;a href=&quot;https://en.wikipedia.org/wiki/Overlay_network&quot;&gt;오버레이 네트워크&lt;/a&gt;&lt;sub&gt;overlay network&lt;/sub&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;유니온 파일 시스템&lt;/a&gt;&lt;sub&gt;union file systems&lt;/sub&gt;등 이미 존재하는 기술을 도커처럼 잘 조합하고 사용하기 쉽게 만든 것은 없었고 사용자들이 원하는 기능을 간단하지만 획기적인 아이디어로 구현하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;레이어 저장방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/image-layer.png&quot; alt=&quot;Docker Layer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백메가&lt;sub&gt;MB&lt;/sub&gt;에 이릅니다. 처음 이미지를 다운받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적일 수 밖에 없습니다.&lt;/p&gt;

&lt;p&gt;도커는 이런 문제를 해결하기 위해 &lt;strong&gt;레이어&lt;sub&gt;layer&lt;/sub&gt;&lt;/strong&gt;라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해줍니다. 이미지는 여러개의 읽기 전용&lt;sub&gt;read only&lt;/sub&gt; 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성됩니다. ubuntu 이미지가 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;가 됩니다. webapp 이미지를 nginx 이미지 기반으로 만들었다면 예상대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt; 레이어로 구성됩니다. webapp 소스를 수정하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt; 레이어를 제외한 새로운 &lt;code class=&quot;highlighter-rouge&quot;&gt;source(v2)&lt;/code&gt; 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있습니다. &lt;del&gt;(개이득)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;컨테이너를 생성할 때도 레이어 방식을 사용하는데 기존의 이미지 레이어 위에 읽기/쓰기&lt;sub&gt;read-write&lt;/sub&gt; 레이어를 추가합니다. 이미지 레이어를 그대로 사용하면서 컨테이너가 실행중에 생성하는 파일이나 변경된 내용은 읽기/쓰기 레이어에 저장되므로 여러개의 컨테이너를 생성해도 최소한의 용량만 사용합니다.&lt;/p&gt;

&lt;p&gt;가상화의 특성상 이미지 용량이 크고 여러대의 서버에 배포하는걸 감안하면 단순하지만 엄청나게 영리한 설계입니다.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;이미지 경로&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/image-url.png&quot; alt=&quot;Docker image url&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지는 url 방식으로 관리하며 태그를 붙일 수 있습니다. ubuntu 14.04 이미지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library/ubuntu:14.04&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library/ubuntu:trusty&lt;/code&gt; 이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library&lt;/code&gt;는 생략가능하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:14.04&lt;/code&gt; 로 사용할 수 있습니다. 이러한 방식은 이해하기 쉽고 편리하게 사용할 수 있으며 태그 기능을 잘 이용하면 테스트나 롤백도 쉽게 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;noscript&gt;&lt;pre&gt;# vertx/vertx3 debian version
FROM subicura/vertx3:3.3.1
MAINTAINER chungsub.kim@purpleworks.co.kr

ADD build/distributions/app-3.3.1.tar /
ADD config.template.json /app-3.3.1/bin/config.json
ADD docker/script/start.sh /usr/local/bin/
RUN ln -s /usr/local/bin/start.sh /start.sh

EXPOSE 8080
EXPOSE 7000

CMD [&amp;quot;start.sh&amp;quot;]&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/7deda80268943f5f72750e08c37182fb.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;도커는 이미지를 만들기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;이라는 파일에 자체 DSL&lt;sub&gt;Domain-specific language&lt;/sub&gt;언어를 이용하여 이미지 생성 과정을 적습니다. 추후에 문법에 대해 자세히 다루겠지만 위 샘플을 보면 그렇게 복잡하지 않다는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이것은 굉장히 간단하지만 유용한 아이디어인데, 서버에 어떤 프로그램을 설치하려고 이것저것 의존성 패키지를 설치하고 설정파일을 만들었던 경험이 있다면 더 이상 그 과정을 블로깅 하거나 메모장에 적지 말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;로 관리하면 됩니다. 이 파일은 소스와 함께 버전 관리 되고 원한다면 누구나 이미지 생성과정을 보고 수정할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-pull.png&quot; alt=&quot;Docker Hub Hits 5 Billion Pulls(2016/08)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지의 용량은 보통 수백메가로 수기가가 넘는 경우도 흔합니다. 이렇게 큰 용량의 이미지를 서버에 저장하고 관리하는 것은 쉽지 않은데 도커는 Docker hub를 통해 공개 이미지를 무료로 관리해 줍니다. 하루에도 엄청난 용량의 이미지가 전세계에서 다운로드 되고 트래픽 비용만 해도 어마어마 할 것 같은데 그것이 다 무료!입니다.&lt;/p&gt;

&lt;h3 id=&quot;command-api&quot;&gt;Command와 API&lt;/h3&gt;

&lt;p&gt;도커 클라이언트의 커맨드 명령어는 정말 자아아알 만들어져 있습니다. 대부분의 명령어는 직관적이고 사용하기 쉬우며 컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있습니다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋고 훌륭한 3rd party 툴이 나오기 좋은 환경입니다.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;유용한 새로운 기능들&lt;/h3&gt;

&lt;p&gt;도커는 발전속도가 아주 빠른 오픈소스입니다. 사용하면서 부족하다고 느꼈던 부분은 빠르게 개선되고 새로운 버전이 나오면 유용한 기능이 대폭 추가됩니다. 어떻게 보면 프로그램을 작은 조각으로 나누고 여러개의 프로그램을 조합하여 동작시키는 유닉스의 철학에는 맞지 않지만.. 너무 잘합니다. ㅠㅠ&lt;/p&gt;

&lt;p&gt;이번 &lt;a href=&quot;https://blog.docker.com/2017/01/whats-new-in-docker-1-13/&quot;&gt;1.13버전&lt;/a&gt;에서는 &lt;a href=&quot;https://github.com/docker/docker/blob/master/experimental/docker-stacks-and-bundles.md&quot;&gt;Docker stacks&lt;/a&gt;이라는 여러개의 컨테이너를 한번에 관리하는 기능이 정식으로 릴리즈 되었고 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/system/&quot;&gt;system&lt;/a&gt; 커맨드가 추가되어 이미지, 컨테이너 관리가 더 편해졌습니다. &lt;a href=&quot;https://github.com/docker/docker/pull/27794&quot;&gt;Secrets Management&lt;/a&gt;라는 비밀정보를 관리하는 기능도 추가됩니다.&lt;/p&gt;

&lt;p&gt;새로운 기능이 계속 추가되고 있고 다음 릴리즈가 기대됩니다.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;훌륭한 생태계&lt;/h3&gt;

&lt;p&gt;도커는 굉장히 큰 생태계를 가지고 있고 커다란 기업과 협력하여 사실상 클라우드 컨테이너 세계의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%8B%A4%EC%83%81_%ED%91%9C%EC%A4%80&quot;&gt;de facto&lt;/a&gt;가 되었습니다. 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포등 다양한 분야에서 다양한 툴들이 존재하며 아예 &lt;a href=&quot;https://coreos.com/why/&quot;&gt;도커를 위한 OS(coreos-&amp;gt; container linux)&lt;/a&gt;도 존재합니다.&lt;/p&gt;

&lt;p&gt;현재 도커를 기반으로한 오픈소스 프로젝트는 10만개가 넘고 굉장히 활발하게 진행되고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;커뮤니티 지원&lt;/h3&gt;

&lt;p&gt;도커는 기술기업답지 않게 홍보와 커뮤니티 관리에 굉장히 신경쓰고 있습니다. 커뮤니티를 위한 스티커나 티셔츠를 무료로 제공하고 필요하면 연사요청도 할 수 있습니다. 홈페이지에서는 전세계에서 열리는 밋업 상황을 볼 수 있고 일주일마다 발송되는 &lt;a href=&quot;https://blog.docker.com/docker-weekly-archives/&quot;&gt;뉴스레터&lt;/a&gt;에는 다양한 개발자들의 글이 실려있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/docker-jpetazzo.jpg&quot; alt=&quot;Docker office에서 만난 Jérôme Petazzoni&quot; /&gt;&lt;/p&gt;

&lt;p&gt;운이 좋았지만 도커 오피스에 방문해서 사무실을 구경할 수도 있었고 고오오오급 개발자 &lt;a href=&quot;https://twitter.com/jpetazzo&quot;&gt;Jérôme Petazzoni&lt;/a&gt;와 직접 이야기를 나눌수 있었습니다! &lt;del&gt;아 또 가고 싶다&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;moby-dock&quot;&gt;moby dock&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/animals.jpg&quot; alt=&quot;Tux(linux) - Moby Dock(docker) - Gopher (golang)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 넘나 귀여운 고래를 로고로 하고 있습니다. 로고 스티커는 항상 인기가 넘치고 로고가 그려진 티셔츠는 입고 돌아다녀도 개발자처럼 보이지 않습니다. 도커가 성공한 가장 큰 이유는 귀여운 고래 덕분이라고 생각합니다.(엄근진) &lt;del&gt;오픈소스가 성공하려면 귀여운 동물 캐릭터를 사용하세요!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;여기까지 도커에 대해 기본적인 내용을 아주 얕게 살펴보았습니다. 이제 실전으로 들어가봅시다!&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 도커란 무엇인가? ✓&lt;/strong&gt; &lt;span class=&quot;series&quot;&gt;SERIES 1/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치하고 컨테이너 실행하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 2/3&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/02/10/docker-guide-for-beginners-create-image-and-deploy.html&quot;&gt;초보를 위한 도커 안내서 - 이미지 만들고 배포하기&lt;/a&gt; &lt;span class=&quot;series&quot;&gt;SERIES 3/3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Thu, 19 Jan 2017 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</link>
        <guid isPermaLink="true">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</guid>
        
        <category>Docker</category>
        
        <category>DevOps</category>
        
        <category>Server</category>
        
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>2016년 블로그 회고</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-12-31-remember-2016/woozoo_read_the_book.jpg&quot; alt=&quot;김우주(19개월)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느덧 2016년 마지막 날입니다. 올 한해 역시 정신없이 지나갔고 작년에 태어난 딸도 돌을 지나고 어느새 python 개발 서적을 읽을 정도의 나이가 되었습니다(&lt;del&gt;위 사진 참조&lt;/del&gt;). 회사는 6주년을 맞이했고 올해 처음으로 일반 고객을 대상으로한 서비스를 오픈했습니다. 서비스를 운영하면서 느낀 점도 많지만 일단은 블로그에 대해 한해를 마무리하는 회고를 하려고 합니다.&lt;/p&gt;

&lt;p&gt;10년 전쯤 블로그를 처음 시작하고 방치하고 삭제하고 다시 만들고 방치하고 삭제하고를 반복했습니다. 애초에 글을 쓸 실력이 안되었고 특별한 목적을 가지고 만들지 않았기 때문에 내용도 부실하고 방문자수도 없는 상황이였습니다. 그러다 2016년 5월 30일 다시 블로그를 만들었고 첫번째 글 “&lt;a href=&quot;/2016/05/30/likehs-develop-log.html&quot;&gt;홈쇼핑처럼 개발후기&lt;/a&gt;“가 반응을 타면서 몇 개 글을 더 썼고 7월 이후 다시 방치..되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;블로그 구성&lt;/h2&gt;

&lt;p&gt;현재 블로그는 &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt; 엔진을 이용하여 &lt;a href=&quot;https://github.com/subicura/subicura.github.io&quot;&gt;github&lt;/a&gt;에서 정적 문서로 제공되고 있습니다. 이 방식은 무료면서 디자인을 자유롭게 구성할 수 있고 마크다운 문서로 편리하게 글을 관리할 수 있습니다. 네이버 블로그나 티스토리, 브런치같은 무료 호스트 방식은 커스터마이징등 기능에 제한이 있고 &lt;a href=&quot;https://wordpress.com/&quot;&gt;wordpress&lt;/a&gt;나 &lt;a href=&quot;https://ghost.org/&quot;&gt;ghost&lt;/a&gt;와 같은 설치형은 자유롭게 수정할 수 있으나 서버 및 버전 관리가 귀찮은 점 때문에 최종적으로 jekyll+github 방식을 사용하였습니다.&lt;/p&gt;

&lt;p&gt;jekyll skin은 &lt;a href=&quot;https://github.com/dirkfabisch/mediator&quot;&gt;mediator&lt;/a&gt;를 fork한 후 폰트와 가로폭, 줄간격, 로고, 코멘트 방식, 이전/다음글 목록을 한땀한땀 수정하여 보는 사람이 편하게 볼 수 있도록 최대한 노력하였습니다. &lt;a href=&quot;https://medium.com/&quot;&gt;medium&lt;/a&gt;과 &lt;a href=&quot;https://brunch.co.kr/&quot;&gt;브런치&lt;/a&gt;가 워낙 이뻐서 많은 영향을 받았습니다. (&lt;del&gt;medium은 윈도우에서 한글폰트가 꽝입니다.&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;글 작성은 &lt;a href=&quot;https://atom.io/&quot;&gt;atom&lt;/a&gt;에디터에서 Markdown Preview 기능을 이용하여 작성하고 있고 코드는 &lt;a href=&quot;https://gist.github.com/&quot;&gt;gist&lt;/a&gt;를 사용하였습니다. gist는 코드관리가 편하고 다양한 언어의 syntax highlighting을 지원하여 아주 이쁘게 표현해 줍니다. 차트나 순서도는 &lt;a href=&quot;https://www.lucidchart.com/&quot;&gt;Lucidchart&lt;/a&gt;를 이용하고 있는데 단순하게 쓰기에 무료플랜도 전혀 문제없고 아주 쉽고 빠르게 그럴듯한 결과물을 만들 수 있습니다. 블로그뿐 아니라 시스템 구성도나 프로세스를 설명할 때도 자주 사용하고 있습니다. 특히 &lt;a href=&quot;https://fonts.google.com/specimen/Titillium+Web&quot;&gt;Titillium 폰트&lt;/a&gt;와 함께 사용하면 깔끔해 보입니다. 색을 선택하기 어렵다면 &lt;a href=&quot;http://flatuicolors.com/&quot;&gt;flatuicolors&lt;/a&gt;서비스를 추천합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;올 해 쓴글&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-12-31-remember-2016/pageview.png&quot; alt=&quot;2016년 쓴 글&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 글을 쓸때는 1주일에 한개를 목표로 하였으나 최종적으로 5개밖에 쓰지 못했습니다. (…) 첫번째 글인 &lt;a href=&quot;/2016/05/30/likehs-develop-log.html&quot;&gt;홈쇼핑처럼 개발후기&lt;/a&gt;는 하루만에 페이지뷰가 10,000을 돌파하는 예상외의 폭발적인 반응&lt;del&gt;과 우려&lt;/del&gt;을 얻었고 파워블로거를 해볼까..라는 &lt;del&gt;헛된&lt;/del&gt; 생각과 블로그의 주제에 대해 많은 고민을 하게 해주었습니다.&lt;/p&gt;

&lt;p&gt;이후에 작성한 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;도커를 이용한 웹서비스 무중단 배포하기&lt;/a&gt;도 반응이 좋아 7월경에 “홈쇼핑처럼x개발자처럼_첫번째이야기”라는 오프라인 모임도 갖게 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-12-31-remember-2016/1st_off.jpg&quot; alt=&quot;홈쇼핑처럼x개발자처럼_첫번째이야기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 후기를 정리하여 6번째 글을 작성할 예정이였으나 결국 올해를 넘기게 되었습니다. ㅠㅠ 이부분은 아마 내년 초에 작성할 것 같습니다. 그 때 참여해 주셨던 분들 모두 감사드리고 좋은 말씀 나누어서 뜻깊은 시간이였습니다.&lt;/p&gt;

&lt;p&gt;3번째 글인 &lt;a href=&quot;/2016/06/13/start-go-shipment-tracking-opensource.html&quot;&gt;Go언어로 오픈소스 배송조회 서비스 만들기&lt;/a&gt;도 많은 분들이 읽어주셨고 관련하여 오픈한 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;delibird&lt;/a&gt; 소스는 아주 활성화 되지는 않았지만 좋아요는 100개를 넘겼습니다. ㅎㅎ 마성의 언어인 Go에 대해 요즘 사용이 뜸해져서 개인프로젝트에 다시 사용해 보려고 하고 있습니다.&lt;/p&gt;

&lt;p&gt;4번째 글인 &lt;a href=&quot;/2016/06/20/server-side-rendering-with-react.html&quot;&gt;왜 React와 서버 사이드 렌더링인가?&lt;/a&gt;는 React를 꽤 사용해보고 적었다고 생각했는데 그 이후로 React에 대해 몰랐던 부분을 많이 배웠고 글 쓴 당시보다는 React에 &lt;del&gt;꽤&lt;/del&gt; 실망하고 있습니다. React는 여전히 매력적이고 계속해서 한동안 사용할 것 같지만 3rd party 라이브러리들에서 은근 문제가 많이 발생하고 디렉토리 구조나 사용패턴등이 너무 다양하여 선택자체에 시간과 고민이 너무 많이 소요되었습니다. 많은 고민 끝에 어느정도 패턴을 정형화 하여 사용중이긴 하나 아직 확신이 들지 않습니다. 이 부분은 어느정도 더 정리가 되면 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;5번째 글인 &lt;a href=&quot;/2016/07/11/coding-convention.html&quot;&gt;linter를 이용한 코딩스타일과 에러 체크하기&lt;/a&gt;는 다른글에 비해 급하게 작성하였는데 역시 페이지뷰에서 증명되었습니다. 오랫동안 생각하고 정리한 글이 확실히 반응이 좋았던 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;어려운점&lt;/h2&gt;

&lt;p&gt;개발자 중에서 글을 재밌고 논리정연하게 잘 작성하는 &lt;a href=&quot;https://github.com/sarojaba/awesome-devblog&quot;&gt;고오오급 개발자 분들&lt;/a&gt;도 많지만 저 같은 경우는 글쓰기 자체가 어려웠습니다. 글을 쓰는 것 보다 코드를 한 줄 더 작성하는게 좋고 잘 정리하고 이해하기 쉽게 쓰려면 시간이 꽤 많이 필요했습니다. 일이 먼저, 글은 나중이 되다보니 쓸 시간은 점점 더 없어지고 집에서도 아기와 함께하느라 시간내기가 어려웠습니다. 이부분은 부지런해지는 수밖에 없는 것 같습니다.&lt;/p&gt;

&lt;p&gt;그리고 주제를 정하는 것이 특히 어려웠습니다. 흔한 주제는 쓰기는 쉽지만 차별화가 어렵고, 좋은 외국 개발자의 글을 번역하는 것은 내용이나 의미가 바뀔까봐 쓰기가 어려웠습니다. 많이 하고 잘 아는 분야에 대해 글을 써야 하는데 알면 알수록 모르는게 많아지는 개발공부의 특성상 부정확한 정보를 작성하는 것에 대한 두려움이 글을 쓰기 어렵게 만드는 것 같습니다.&lt;/p&gt;

&lt;p&gt;내가 직접 경험한 내용과 남이 경험한 내용을 들은 것, 내가 직접 확인한 것과 거의 확실하다고 추측되는 것등을 적절하게 선택하여 글을 쓰려면 많은 고민이 필요하고 더더욱 글을 쓰기 어렵게 만듭니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;개발 관련 글을 쓰거나 발표를 하면 자칫 입으로 개발을 하는 사람(&lt;del&gt;입개발&lt;/del&gt;)이 되는 경우가 있습니다. 허세와 건방짐이 있는 것처럼 보이는데 이러한 부분이 무조건 나쁘다고 생각하지 않습니다. 문제는 무조건 내가 맞다고 주장하거나 피드백을 받아 들이지 못하는 경우라고 생각합니다.&lt;/p&gt;

&lt;p&gt;글을 쓰려면 틀릴걸 각오하는 용기가 필요합니다. 이러한 것이 없다면 모든 걸 다 알기 전까진 글을 쓰지 못할 것이고 &lt;strong&gt;“Done is better then perfect”&lt;/strong&gt;라는 말처럼 어쨋든 무언가를 하는 것이 낫다고 생각합니다. 글을 쓰면서 생각을 정리하고 모호했던 부분을 다시 공부하고 많은 사람과 피드백 속에 더 좋은 결과가 나오는 것 같습니다.&lt;/p&gt;

&lt;p&gt;많은 글을 쓰진 못했지만.. 많은 분들이 글을 좋게 봐주셔서 감사한 한해였고, 내년에는 좀더 부지런하게 글을 쓰도록 해야겠습니다.&lt;/p&gt;

&lt;p&gt;새해 복 많이 받으세요.&lt;/p&gt;
</description>
        <pubDate>Sat, 31 Dec 2016 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2016/12/31/remember-2016.html</link>
        <guid isPermaLink="true">https://subicura.com/2016/12/31/remember-2016.html</guid>
        
        <category>Blog</category>
        
        
        <category>Talk</category>
        
      </item>
    
      <item>
        <title>linter를 이용한 코딩스타일과 에러 체크하기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/carbo.jpg&quot; alt=&quot;돈까스먹는용만이x까르보돈까스&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt; 6번째 상품인 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/27/&quot;&gt;까르보돈까스&lt;/a&gt;는 부먹과 찍먹을 선택해야 합니다. 코딩도 둘중에 하나를 선택해야 하는 경우가 많은데 협업을 위해 코딩 스타일을 설정하고 규칙에 어긋난 코드를 한땀한땀 수정했던 순간이 떠올라 linter에 대해 이야기합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/civil_war.jpg&quot; alt=&quot;시빌워&quot; title=&quot;시빌워&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_style&quot;&gt;코딩스타일&lt;/a&gt;, 코딩 표준이라고도 불리는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Coding_conventions&quot;&gt;코딩 컨벤션&lt;/a&gt;은 코드를 작성할 때 추천하는 코딩 스타일, 괜찮은 사례등을 모아 놓은 가이드라인입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;에 중괄호({)는 다음 줄에 쓰는게 좋을까요, 같은 줄에 쓰는게 좋을까요? 띄어쓰기는 스페이스랑 탭중에 어떤걸 쓸까요? 스페이스를 사용한다면 2칸? 4칸? 8칸? 몇칸을 띄우는 나을까요? 정답은 없지만 어떤게 인기 있는지는 &lt;a href=&quot;http://sideeffect.kr/popularconvention/#java&quot;&gt;여기&lt;/a&gt;서 언어별 대세를 확인해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;코딩 컨벤션은 표준이라고 하지만 꼭 지켜지 않아도 프로그램은 잘 동작하고 이 방식이 좋은지 저 방식이 좋은지 백날 싸워도 결론이 없는 딱히 신경 쓰지 않아도 크게 문제 없어 보이는 가이드라인입니다.&lt;/p&gt;

&lt;p&gt;이러한 코딩 컨벤션과 에러 체크를 도와주는 툴을 linter라고 합니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;문제는 유지보수&lt;/h2&gt;

&lt;p&gt;과거의 많은 고오급 개발자들은 개발하는 시간의 반이상이 유지보수를 하는데 쓰인다는걸 알았습니다. 미래의 내가 현재의 나를 욕하지 않고 레거시가 내거시가 되어 나를 괴롭히지 않으려면 유지보수가 쉽도록 코드를 작성해야합니다.&lt;/p&gt;

&lt;p&gt;유지보수가 쉽고 버그가 없는 코드를 작성하려면 많은 경험과 노력이 필요합니다. 어떻게 하면 코드의 품질을 높일 수 있을까..라고 많은 개발자들이 고민했고 정량적으로 코드를 분석할 수 있는 정적분석과 동적분석용 툴을 만들고 테스트 코드를 작성하는 방법을 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_program_analysis&quot;&gt;정적분석&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정적분석은 프로그램을 실행하지 않고 코드를 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;코드를 보면 띄어쓰기나 줄바꿈이 이상한 부분을 발견할 수 있고 메소드가 너무 길거나 변수명 형식이 어떤건 언더바(form_value) 어떤건 카멜케이스(formValue)로 오락가락하면 통일하는게 좋습니다. 상수로 사용하는 변수는 변경되지 않도록 하는게 버그를 예방할 수 있기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;로 선언하는게 낫고 사용하지 않는 변수나 함수는 지우는게 나중에 코드를 볼때 훨씬 편합니다. 한 클래스는 적절한 수의 메소드를 가지고 있어야 하고 if문을 사용할때는 너무 복잡하게 중첩하면 무슨 내용인지 이해하기가 어렵죠.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;strong&gt;느낌적&lt;/strong&gt;으로 알고 있는 내용을 모아모아모아서 고급 개발자들이 코딩컨벤션, 예상결함방지, 코드복잡도 메트릭스등의 이름으로 정리하였고 다양한 툴들이 유/무료로 제공되고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_program_analysis&quot;&gt;동적분석&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;동적분석은 실제로 프로그램을 실행해보고 취약점을 분석합니다.&lt;/p&gt;

&lt;p&gt;메모리에 릭이 발생하거나 쓰레드가 꼬이는 문제는 실제로 프로그램을 실행하지 않으면 발견하기가 어렵습니다. 앱 개발자들은 한참 앱을 사용하다가 죽으면 아.. 어디선가 메모리가 세고 있다는걸 &lt;strong&gt;느낌적&lt;/strong&gt;으로 알고 있습니다. 이러한 때에 메모리누수 체크툴을 사용하면 실시간으로 메모리 사용량을 프로파일링해주고 어떤 변수가 문제가 있는지를 표로 정리해서 보여줍니다. &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode&lt;/a&gt;와 &lt;a href=&quot;http://developer.android.com/tools&quot;&gt;Android Studio&lt;/a&gt;에서 관련 기능을 제공하고 있기 때문에 릴리즈 하기전에 메모리 누수등을 체크해보면 예상치 못한 곳에서 결함을 발견할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_testing&quot;&gt;테스트&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;테스트는 다양한 방법이 존재하고 여러가지 방식으로 코드가 정상적으로 동작하는지 검사합니다.&lt;/p&gt;

&lt;p&gt;어떤 메소드를 아무리 잘 설계하고 코드를 잘 작성했다고 하더라도 해당 메소드에 대한 테스트 코드가 없다면 검증 및 유지보수가 어렵습니다. 대부분의 유명한 오픈소스들은 기능을 추가하는 코드를 풀 리퀘스트하게 되면 테스트 코드도 같이 작성해 달라고 요청을 합니다. 테스트 코드가 없으면 추가되는 기능을 검증하기 위해 일일이 수작업으로 체크를 해야하고 나중에 소스가 수정되었을 때 어떤 영향을 미치는지 알 수가 없게 됩니다. 운좋게 동작하는 라이브러리를 만드는게 아니라면 테스트코드는 필수 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/TechnicalDebt.html&quot;&gt;기술부채&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여러분석툴을 사용하고 테스트코드를 열심히 작성하면 분명 코드의 품질은 좋아집니다. 하지만, 실제로 분석툴을 돌려보면 어마어마한 경고를 받게 되고 그런 결함을 수정하다보면 이게 코드를 작성하는건지 하루종일 경고만 보고 리팩토링만 하는 건지 혼란스러울 수 있습니다.&lt;/p&gt;

&lt;p&gt;버그는 없고 코드는 단단하지만 느리게 개발하는 방식과 개발속도는 빠르지만 코드는 약간 지저분하게 작성하는 방식중에 많은 스타트업은 후자를 선택합니다.
코드는 복잡해지고 찝찝한 부분도 생기지만 일단 기능을 빠르게 구현하고 잘 동작하는 것 같으면 릴리즈합니다. 이렇게 알면서도 방치하는 몇몇 문제들을 기술부채&lt;sub&gt;technical debt&lt;/sub&gt;라고 하고 우리는 그렇게 빚이 쌓여가게 됩니다. &lt;del&gt;현실에서도 빚, 개발에서도 빚, 엉엉&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;쌓이고 쌓인 기술부채는 여러가지 방법으로 이자를 갚거나 주기적인 리팩토링을 통해 원금을 갚아야 하지만 개발자 한명 뽑기 어려운 스타트업에서는 사실상 개선하기 어려운 부분(&lt;del&gt;너 왜 개발안하고 노니?&lt;/del&gt;)이 많습니다. 큰 회사도 예외는 아니여서 그렇게 방치하고 땜질하다가 어느날 고도화라는 이름의 프로젝트를 시작하고 아예 새로 코드를 작성하기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;linter-&quot;&gt;Linter 적용해보기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;유지보수는 어렵고 시간이 많이 걸린는 작업이다. 개선이 필요하다고 생각한다.&lt;/li&gt;
  &lt;li&gt;다양한 분석툴과 테스트코드를 작성하면 유지보수와 협업이 쉬워진다.&lt;/li&gt;
  &lt;li&gt;기술부채는 꾸준히 갚아가는게 중요하다.&lt;/li&gt;
  &lt;li&gt;코드의 품질이 높아지면 앱의 완성도가 높아지고 수익이 증가하여 결국 이득이다.&lt;/li&gt;
  &lt;li&gt;하지만, 시간과 인력이 부족하다. 뭔가 추가로 작업할 여력이 없다. ㅠ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 5가지에 동의를 하지만 아직 아무 조치도 취하지 않았다면 linter를 적용하기 좋은때입니다.&lt;/p&gt;

&lt;p&gt;linter는 코딩 컨벤션과 에러를 체크해주는 작은 프로그램입니다. 독립적으로 실행할 수도 있고 IDE의 플러그인으로도 존재합니다. Python, Ruby, Java, Swift, HTML, CSS, YAML, 심지어 Markdown까지 대부분의 문법을 지원하고 있기 때문에 어떤 프로그램 언어를 사용하든 바로 체크해 볼 수 있습니다. Atom 에디터에서 지원하는 &lt;a href=&quot;https://atomlinter.github.io/&quot;&gt;Linter 목록&lt;/a&gt;을 보면 대부분의 언어를 지원하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;구글(&lt;a href=&quot;https://github.com/google/styleguide&quot;&gt;구글스타일가이드&lt;/a&gt;), 마이크로소프트와 같은 고오오오급 개발회사들은 자체적인 코딩 컨벤션을 가지고 있고 기본적으로 소스를 제출하기전에 코딩 스타일을 맞추는 것은 기본입니다. 회사차원이 아닌 언어차원에서 스타일을 지정하기도 하는데 Python의 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot;&gt;PEP8&lt;/a&gt;이라던가 Golang의 gofmt등이 있고, wordpress(&lt;a href=&quot;https://codex.wordpress.org/WordPress_Coding_Standards&quot;&gt;wordpress coding standards&lt;/a&gt;), drupal 같은 유명한 툴들도 각각 스타일을 정의해서 가이드라인으로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;예전에는 코딩 스타일 가이드를 문서로 만들어 관리하기도 하였으나, 툴의 도움이 없다면 사실상 무의미한 작업입니다. 요즘은 다양한 툴이 존재하고 바로 적용하기 쉬우며 단계적으로 조금씩 적용하는 것도 가능합니다. 미적으로도 이쁘고 협업과 코드 리뷰를 할때도 좋고 심지어 더 나은 코드를 추천해주어 실력도 늘수 있는.. 이게 1석 몇조야… 바로 적용하지 않을 이유가 없습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;import React, { Component } from &amp;#39;react&amp;#39;;

//form
class Comment extends Component {
  constructor(props) {
    super(props);

    this.state = {
      msg:&amp;quot;&amp;quot;
    };
  }
  onSubmit() {
    if(this.props.useComment) {
      alert(this.state.name + &amp;quot;님이 댓글을 작성하였습니다.&amp;quot;);
    }
  }
  componentDidMount() {
    this.submitBtn = this.refs.submitBtn;
  }
  render() {
    var onChange = e =&amp;gt; this.setState({ msg: e.target.value });

    return (
      &amp;lt;form method=&amp;quot;post&amp;quot; className=&amp;quot;form-horizontal&amp;quot; onSubmit={this.onSubmit.bind(this)}&amp;gt;
        &amp;lt;input name=&amp;quot;msg&amp;quot; type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; onChange={onChange.bind(this)} value={this.state.msg} /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; ref=&amp;quot;submitBtn&amp;quot;&amp;gt;{ this.props.useComment ? &amp;#39;글쓰기&amp;#39; : &amp;#39;댓글불가&amp;#39; }&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    )
  }
}

export default Comment;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/f98964692aed12ae1bab67005e4ecf27.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;ReactJS 샘플 코드입니다. 최신 es6 문법도 적용하고 최선을 다해 잘 작성했다고 보이는데.. 그 유명한 &lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&quot;&gt;airbnb의 eslint&lt;/a&gt;규칙을 체크해볼까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;3:1   Expected exception block, space or tab after ‘//’ in comment&lt;/li&gt;
  &lt;li&gt;9:11  Missing space before value for key ‘msg’&lt;/li&gt;
  &lt;li&gt;9:11  Strings must use singlequote&lt;/li&gt;
  &lt;li&gt;9:13  Missing trailing comma&lt;/li&gt;
  &lt;li&gt;12:3   onSubmit should be placed after componentDidMount&lt;/li&gt;
  &lt;li&gt;13:5   Expected space(s) after “if”&lt;/li&gt;
  &lt;li&gt;13:19  ‘useComment’ is missing in props validation&lt;/li&gt;
  &lt;li&gt;14:7   Unexpected alert&lt;/li&gt;
  &lt;li&gt;14:13  Unexpected string concatenation&lt;/li&gt;
  &lt;li&gt;14:31  Strings must use singlequote&lt;/li&gt;
  &lt;li&gt;21:5   Unexpected var, use let or const instead&lt;/li&gt;
  &lt;li&gt;25:39  Unknown property ‘class’ found, use ‘className’ instead&lt;/li&gt;
  &lt;li&gt;26:47  There should be no space after ‘{‘&lt;/li&gt;
  &lt;li&gt;26:60  ‘useComment’ is missing in props validation&lt;/li&gt;
  &lt;li&gt;26:88  There should be no space before ‘}’&lt;/li&gt;
  &lt;li&gt;28:6   Missing semicolon&lt;/li&gt;
  &lt;li&gt;32:2   Newline required at end of file but not found&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;헉, 무려 17개의 경고메시지가 발생합니다. 100% 완벽하진 않을꺼라 생각했지만 이 짧은 소스에 이렇게 많은 경고가 뜨다니 놀랍습니다. 이제 경고를 수정해 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;import React, { Component, PropTypes } from &amp;#39;react&amp;#39;;

// form
class Comment extends Component {
  constructor(props) {
    super(props);

    this.state = {
      msg: &amp;#39;&amp;#39;,
    };
  }
  componentDidMount() {
    this.submitBtn = this.refs.submitBtn;
  }
  onSubmit() {
    if (this.props.useComment) {
      alert(`${this.state.name}님이 댓글을 작성하였습니다.`);
    }
  }
  render() {
    const onChange = e =&amp;gt; this.setState({ msg: e.target.value });

    return (
      &amp;lt;form method=&amp;quot;post&amp;quot; className=&amp;quot;form-horizontal&amp;quot; onSubmit={this.onSubmit.bind(this)}&amp;gt;
        &amp;lt;input name=&amp;quot;msg&amp;quot; type=&amp;quot;text&amp;quot; className=&amp;quot;form-control&amp;quot; onChange={onChange.bind(this)} value={this.state.msg} /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; ref=&amp;quot;submitBtn&amp;quot;&amp;gt;{this.props.useComment ? &amp;#39;글쓰기&amp;#39; : &amp;#39;댓글불가&amp;#39;}&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
}

Comment.propTypes = {
  useComment: PropTypes.bool.isRequired,
};

export default Comment;
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/e89afea3a71ec0151926e24a719d2f5f.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;수정해서보니 엄청나게 바뀐부분은 없지만 왠지 퀄리티가 높아보입니다. 코딩 컨벤션은 단순히 띄어쓰기를 가이드 하는 것 말고도 React의 props validation 코드가 빠졌다는 걸 알려주고 ES6에 추가된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template string&lt;/a&gt;기능도 알려줍니다. 처음 React를 하면 많이 실수하는 className대신 class를 적은 것도 지적해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 Javascript 코드가 눈에 잘 안들어오는 분들을 위해 아주 심플한 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;scss&lt;/a&gt; 코드도 살펴봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;.post {
  .name {
    color:#ffffff;

    &amp;amp;.admin {
      background-color:rgba(255,0,0,0.5);

      &amp;amp;.active {
        font-weight:bold;
      }
    }
  }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/2e70ea5d7972c7dd388b25f6f03a5608.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;이번 예제는 그리 길지도 않아서 크게 문제 없어보이는데… &lt;a href=&quot;https://github.com/brigade/scss-lint&quot;&gt;scss-lint&lt;/a&gt;를 돌려봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
  &lt;li&gt;ColorVariable: Color literals like ‘#ffffff’ should only be used in variable declarations; they should be referred to via variable everywhere else.&lt;/li&gt;
  &lt;li&gt;HexLength: Color ‘#ffffff’ should be written as ‘#fff’&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
  &lt;li&gt;ColorVariable: Color literals like ‘rgba(255, 0, 0, 0.5)’ should only be used in variable declarations; they should be referred to via variable everywhere else.&lt;/li&gt;
  &lt;li&gt;LeadingZero: ‘0.5’ should be written without a leading zero as ‘.5’&lt;/li&gt;
  &lt;li&gt;NestingDepth: Nesting should be no greater than 3, but was 4&lt;/li&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11개의 경고메시지가 발생했습니다. -ㅁ-;; 내가 작성한 코드가 그렇게도 일반적인 표준과 거리가 멀단말인가…?! 라고 생각하면서 일단 수정해 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;$white-color: #fff;
$admin-red-bg-color: rgba(255, 0, 0, .5);

.post {
  .name {
    color: $white-color;

    &amp;amp;.admin {
      background-color: $admin-red-bg-color;
    }

    &amp;amp;.active {
      font-weight: bold;
    }
  }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/a4f80ad19a443ed7cac29f7e3f6d32c1.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;전과 비교하여 소스가 깔끔해 보이나요? 스페이스 규칙은 물론 스타일의 순서와 내부 클래스의 깊이까지 제한해줍니다. sass/scss를 처음 사용하면 내부 클래스의 깊이가 마구 늘어나다가 나중에 범용적으로 적용하기 어려운 경우를 발견하곤 하는데 이러한 문제를 미리 방지해줍니다.&lt;/p&gt;

&lt;p&gt;사람마다 원하는 스타일이 다르고 이게 더 낫다고 생각하는 부분도 있지만, 정말 그런 스타일이 유지보수와 협업에 도움이 되는지 생각해봐야 합니다. 혼자 작성하는 코드가 아니라면 &lt;strong&gt;자신의 스타일&lt;/strong&gt; 보다는 대부분이 괜찮다고 하는 &lt;strong&gt;모두의 스타일&lt;/strong&gt;에 맞추는 것이 유지보수와 협업에 도움이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;eslinthttpeslintorg-&quot;&gt;&lt;a href=&quot;http://eslint.org/&quot;&gt;eslint&lt;/a&gt; 적용하기&lt;/h2&gt;

&lt;p&gt;실제로 lint를 어떻게 적용하는지, 어떠한 옵션이 있는지 알아보기 위해 javascript lint툴인 eslint를 설치하고 사용하는 방법을 알아봅니다. 굳이 javascript lint툴을 가지고 예를 든 이유는 javascript가 개발자들 마다 가장 스타일 차이가 많이 나는 언어라고 생각하기 때문입니다. linter들의 사용법과 옵션은 비슷비슷하기 때문에 eslint를 살펴보면 다른 언어의 linter도 적용하기 쉬울거라 생각됩니다.&lt;/p&gt;

&lt;h3 id=&quot;eslint-&quot;&gt;eslint 설치&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;eslint는 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;로 작성된 프로그램입니다. 먼저, nodejs를 설치후에 eslint를 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install -g eslint&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;초기설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;설치후엔 eslint 초기 설정을 진행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm init
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint --init

? How would you like to configure ESLint? Answer questions about your style
? Are you using ECMAScript 6 features? Yes
? Are you using ES6 modules? Yes
? Where will your code run? Browser
? Do you use CommonJS? No
? Do you use JSX? Yes
? Do you use React Yes
? What style of indentation &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Spaces
? What quotes &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;strings? Single
? What line endings &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Unix
? Do you require semicolons? Yes
? What format &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you want your config file to be &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;? JavaScript&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;몇가지 옵션을 물어보면서 자동으로 필요한 plugin을 추가하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc.js&lt;/code&gt;라는 설정파일을 만들어줍니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true,
        &amp;quot;es6&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;installedESLint&amp;quot;: true,
    &amp;quot;parserOptions&amp;quot;: {
        &amp;quot;ecmaFeatures&amp;quot;: {
            &amp;quot;experimentalObjectRestSpread&amp;quot;: true,
            &amp;quot;jsx&amp;quot;: true
        },
        &amp;quot;sourceType&amp;quot;: &amp;quot;module&amp;quot;
    },
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ],
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;always&amp;quot;
        ]
    }
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/29778c2ab4c2c4f94f29ceabe9416ae3.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;대부분의 linter는 위와 같이 세부적인 설정파일을 제공하고 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;sub&gt;dot&lt;/sub&gt;으로 시작하여 보이지 않는 파일로 관리합니다. linter에서 체크하는 규칙중에 현재 코드에 적용이 어려운 규칙등은 무시하게 설정할 수 있어 일단 툴을 돌려보고 수정하는데 무리가 있는 규칙은 제외하거나 바꾸면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Airbnb 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본적인 옵션은 범용적으로 설정되기 때문에 회사마다 특성에 맞게 조금씩 규칙을 고쳐서 사용합니다. Airbnb 또한 자체적인 규칙을 설정하여 사용중인데 이를 &lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;오픈소스&lt;/a&gt;로 공개하였고 React와 ES6를 사용하는 프로젝트에 적절한 규칙을 제공합니다. Airbnb룰을 적용해봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev eslint-config-airbnb eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y eslint&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;,
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ]
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/57c7ba78118f3afab25dbbb9b3276d81.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;Airbnb에서 만든 플러그인을 추가하고 lint 설정파일을 바꿨습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;나만의 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Airbnb규칙중에 &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md&quot;&gt;react/jsx-no-bind&lt;/a&gt;규칙은 빼는게 현재 상황에 적당할 것 같아 해당 규칙을 뺍니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;,
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ],
    &amp;quot;rules&amp;quot;: {
    	&amp;quot;react/jsx-no-bind&amp;quot;: &amp;quot;off&amp;quot;
    }
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/1b7f686371897d96823f743f1b22c496.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;inline 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가끔 특정 코드에서만 규칙을 따로 적용하고 싶을 수 있습니다. 이럴땐 주석을 이용한 inline 규칙을 적용하면 됩니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;/* eslint no-class-assign: &amp;quot;off&amp;quot; */
PostForm = reduxForm({
  form: &amp;#39;msg&amp;#39;,
})(PostForm);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/308dfda948a55be8e8534aa24a3b71b1.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;실행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 설정은 거의 끝났으니 실제로 lint를 돌려봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.jsx&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;주르륵주르륵 에러가 뜹니다. ㅠㅠ 이제 고치기만 하면 되겠네요…&lt;/p&gt;

&lt;h2 id=&quot;gulp-&quot;&gt;Gulp 설정&lt;/h2&gt;

&lt;p&gt;linter를 단독으로 사용하는 경우는 이런 샘플을 보여줄 때 빼고는 아마 거의 없을겁니다. 왜냐면 개발자들은 게을러서 파일을 저장하거나 수정할 때 자동으로 체크하게 해줘야 합니다. 테스크 자동화 툴인 &lt;a href=&quot;http://gulpjs.com/&quot;&gt;gulp&lt;/a&gt;의 watch 기능을 이용하여 자동으로 체크하도록 설정해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --global gulp-cli
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev gulp
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev gulp-eslint&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;대부분의 linter는 &lt;a href=&quot;https://github.com/adametry/gulp-eslint&quot;&gt;gulp-eslint&lt;/a&gt;와 같이 gulp용 plugin을 제공합니다. 이제 gulpfile을 설정합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;var gulp = require(&amp;#39;gulp&amp;#39;);
var eslint = require(&amp;#39;gulp-eslint&amp;#39;);

gulp.task(&amp;#39;lint&amp;#39;, function() {
  return gulp.src([&amp;#39;**/*.{js,jsx}&amp;#39;,&amp;#39;!node_modules/**&amp;#39;])
    .pipe(eslint())
    .pipe(eslint.format())
    .pipe(eslint.failAfterError());
});

gulp.task(&amp;#39;watch&amp;#39;, function() {
	gulp.watch(&amp;#39;**/*.{js,jsx}&amp;#39;, [&amp;#39;lint&amp;#39;]);
});

gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;watch&amp;#39;], function () {
});
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/65a15aea86bc2582e3cca337491f5bbe.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;실행&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gulp&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;node_modules 디렉토리를 제외하고 js와 jsx파일을 수정하면 자동으로 eslint를 실행하고 결과를 알려줍니다. 이런식으로 scss-lint등 원하는 linter를 추가할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ide-&quot;&gt;IDE 플러그인&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;SublimeText3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SublimeText3에 lint를 적용하려면 &lt;a href=&quot;http://www.sublimelinter.com/en/latest/&quot;&gt;SublimeLinter&lt;/a&gt;를 설치합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;커멘트창을 열고(cmd+shift+p on Mac OS X, ctrl+shift+p on Linux/Windows)&lt;/li&gt;
  &lt;li&gt;Package Control: Install Package 를 선택합니다.&lt;/li&gt;
  &lt;li&gt;SublimeLinter와 SublimeLinter-contrib-eslint를 설치합니다.&lt;/li&gt;
  &lt;li&gt;설치가 끝나면 재시작합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/sublimetext3.png&quot; alt=&quot;sublime text3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽에 빨간색점이 보이고 하단에 에러문구가 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WebStorm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IntelliJ의 WebStorm IDE에는 ESLint가 이미 내장되어 있습니다. 설정에서 활성화하면 바로 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/webstorm_eslint.png&quot; alt=&quot;WebStorm ESLint&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Languages &amp;amp; Frameworks &amp;gt; Javascript &amp;gt; Code Quality Tools &amp;gt; ESLint&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/webstorm_eslint_view.png&quot; alt=&quot;WebStorm ESLint Check&quot; /&gt;&lt;/p&gt;

&lt;p&gt;활성화하면 editor 오른쪽에 빨간색 라인이 보이고 마우스 오버하면 에러문구가 보입니다.&lt;/p&gt;

&lt;h2 id=&quot;ci&quot;&gt;CI&lt;/h2&gt;

&lt;p&gt;linter를 사용하는 법은 거의 끝났고, 이제 CI에 적용할때입니다. 소스를 배포하고 빌드할 때마다 자동으로 lint를 체크하고 잘못된 점을 알려서 개발자를 압박해야겠죠. &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;를 사용한다면 &lt;a href=&quot;https://github.com/jenkinsci/checkstyle-plugin&quot;&gt;checkstyle plugin&lt;/a&gt;을 사용할 수 있습니다. &lt;a href=&quot;http://checkstyle.sourceforge.net/&quot;&gt;Checkstyle&lt;/a&gt;은 원래 java파일을 체크할때 사용하던 포멧인데 다른 툴에서도 보통 같은 포멧을 제공합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint -f checkstyle &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js &amp;gt; checkstyle.xml&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;eslint에서는 -f 옵션을 통해 output 포멧을 지정할 수 있는데 checkstyle을 내장하고 있습니다. Jenkins에서 checkstyle을 설정하면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-07-11-coding-convention/checkstyle.png&quot; alt=&quot;Jenkins Checkstyle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;코딩 컨벤션을 문법단계까지 적용한 대표적인 언어가 &lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;과 &lt;a href=&quot;https://golang.org/&quot;&gt;Go&lt;/a&gt;라고 생각합니다. 처음에 python이 블록 구분을 중괄호가 아닌 들여쓰기로 한다는 이야기를 들었을땐 엄청난 충격적이였습니다. &lt;em&gt;아니 python은 이제 블록 줄바꿈가지고 개발자들끼리 싸우지 않아도 되는건가?!&lt;/em&gt; 이후에 Go를 접했을때도 Go는 줄을 바꾸지 않고 중괄호를 같은 줄에 붙이는 걸 강제하였고 언어 스펙도 굉장히 간결하여 다시 한번 충격적이였습니다. Go는 더 나아가 gofmt라는 코드 스타일 검사툴을 기본 설치판에 포함하여 대부분의 코드 스타일을 비슷하게 만들어 버렸습니다. 이때문에 Go 개발자들은 다른 사람의 소스를 이해하는게 쉽다고 느껴져 좋은 소스를 참고하고 배우는게 편하다는 이야기를 자주 합니다.&lt;/p&gt;

&lt;p&gt;Linter를 적극적으로 사용할 수록 굉장히 빡빡한 느낌이 있습니다. Linter는 결국 코드를 잘 관리하여 최종적인 생산성을 높이자는 건데 오히려 방해가 되고 속도가 더뎌지는 느낌을 받을 수 있습니다. 따라서 가장 중요한 건 무조건적으로 철저하게 지키는 것이 아닌 &lt;strong&gt;언제 어길지를 아는 것&lt;/strong&gt;이라고 생각합니다. 코딩 컨벤션을 적용한 코드가 오히려 더 눈에 안 들어오고 해석이 어렵다거나 기존에 적용된 일관성을 코딩 컨벤션이 오히려 어기는 경우는 전부다 바꾸는 시간을 고려하여 프로젝트만의 규칙을 만들고 느슨하게 설정하는 것이 낫다고 생각합니다. 그리고 간단한 프로토타입을 만드는데 까지 무조건적으로 적용하는건 어렵겠죠.&lt;/p&gt;

&lt;p&gt;Linter를 시작으로 다양한 분석툴을 적용하고 테스트코드를 작성하다 보면 지금 당장 개발 속도가 느린 것 같지만 결국 미래의 나와 우리가 행복해지는 길이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;Linter를 적용하여 개발한 홈쇼핑처럼에서 이번에 출시한 까르보돈까스 절찬리 판매중이니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 갓 대학을 졸업한 의지넘치는 신입부터 고오급 경력 개발자까지 모두 환영합니다 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jul 2016 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2016/07/11/coding-convention.html</link>
        <guid isPermaLink="true">https://subicura.com/2016/07/11/coding-convention.html</guid>
        
        <category>Coding</category>
        
        <category>Lint</category>
        
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>왜 React와 서버 사이드 렌더링인가?</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;2016/12/29 수정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;AngularJS의 단점으로 적었던 IE8지원은 React 또한 15.0.0에서 지원 중단되었습니다. ;ㅁ;&lt;/li&gt;
  &lt;li&gt;AngularJS의 단점으로 적었던 비표준 태그는 data-* 형태로 대체 가능합니다.&lt;/li&gt;
  &lt;li&gt;Angular v2 등장에 따른 v1 지원 중단 우려는 큰 문제는 없어보입니다. (최근 12/23일 업데이트)&lt;/li&gt;
  &lt;li&gt;Angular2는 TypeScript가 메인이긴 하나 자바스크립트 또는 Dart로 작성가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/fried_things.jpg&quot; alt=&quot;튀김과불맛쌀떡볶이x홈쇼핑처럼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt; 4번째 상품인 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/25/&quot;&gt;튀김&lt;/a&gt;을 기름에 튀기면서 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;를 적용하느라 고생했던 순간이 떠올라 React와 서버 사이드 렌더링 적용과정을 정리해봅니다. 여기서는 &lt;strong&gt;어떻게&lt;/strong&gt;보다는 &lt;strong&gt;왜&lt;/strong&gt;에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;현재 홈쇼핑처럼의 커머스 백엔드는 PHP로 만든 Magento를 사용하고 있고 프론트엔드는 일부 화면에서 React를 사용하고 있습니다. 웹서버에 v8js extention을 설치하여 서버 사이드 렌더링을 지원하고 있습니다. 그리고 홈쇼핑처럼에서 사용중인 채팅은 &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;로 만든 별도의 서비스로 분리하여 운영하고 있고 관리자 페이지 프론트엔드는 역시 React에 &lt;a href=&quot;https://github.com/cowboyd/therubyracer&quot;&gt;therubyracer&lt;/a&gt;라는 V8 javascript interpreter를 이용하여 서버 사이드 렌더링을 지원하고 있습니다. 이전에 작업했던 .NET 프로젝트에도 프론트엔드는 React에 &lt;a href=&quot;http://reactjs.net/&quot;&gt;ReactJS.NET&lt;/a&gt;를 이용하여 서버 사이드 렌더링을 지원하였습니다.&lt;/p&gt;

&lt;p&gt;백엔드는 프로젝트마다 달라도 프론트엔드는 React에 서버사이드 렌더링을 지원하는 방식으로 통일하고 있습니다. React가 뭐길래, 서버사이드 렌더링이 뭐가 좋길래 이런 결정을 한걸까요?&lt;/p&gt;

&lt;p&gt;먼저, 자바스크립트를 이용한 웹 개발의 발전방향을 살펴봅니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ajax--&quot;&gt;ajax가 없던 시절&lt;/h2&gt;

&lt;p&gt;지금은 Javascript를 이용하여 동적인 웹페이지를 자연스럽게 만들고 있지만 10년전 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;ajax&lt;/a&gt;가 등장하기 전에는 서버에서 전체 HTML을 만드는 방식이 일반적이였습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;?php
$servername = &amp;quot;localhost&amp;quot;;
$username = &amp;quot;username&amp;quot;;
$password = &amp;quot;password&amp;quot;;
$dbname = &amp;quot;myDB&amp;quot;;

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn-&amp;gt;connect_error) {
    die(&amp;quot;Connection failed: &amp;quot; . $conn-&amp;gt;connect_error);
} 

$sql = &amp;quot;SELECT id, firstname, lastname FROM MyGuests&amp;quot;;
$result = $conn-&amp;gt;query($sql);

if ($result-&amp;gt;num_rows &amp;gt; 0) {
    // output data of each row
    while($row = $result-&amp;gt;fetch_assoc()) {
        echo &amp;quot;id: &amp;quot; . $row[&amp;quot;id&amp;quot;]. &amp;quot; - Name: &amp;quot; . $row[&amp;quot;firstname&amp;quot;]. &amp;quot; &amp;quot; . $row[&amp;quot;lastname&amp;quot;]. &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
    }
} else {
    echo &amp;quot;0 results&amp;quot;;
}
$conn-&amp;gt;close();
?&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/427978fd79fa14e6cfd70644f6a5f4bd.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;조금 복잡해보이고 뷰에 여러가지 로직이 들어가 있지만 지금도 어디선가는 사용하고 있는 전통적인 개발 방식입니다. 이때까지만 해도 javascript는 일부 고오급 웹 개발자들이 사용하는 언어였고 웹페이지의 컨텐츠보다는 무언가를 꾸며주거나 화려한 느낌을 주는데 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax-&quot;&gt;ajax의 등장&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/google-auto-complete.png&quot; alt=&quot;Google 추천검색어&quot; title=&quot;Google 추천검색어&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;처음 ajax가 등장했을때 충격은 정말 엄청났습니다. Google의 추천 검색어 따라하기가 유행했는데 검색어 입력란에 &lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;을 입력하면 추천 검색어가 실시간으로 보였습니다. 이게 정말 웹에서 가능하다니?!&lt;/p&gt;

&lt;p&gt;그때는 Javascript의 J도 모르고 눈 내리는 소스를 복사 붙여넣기하며 좋아하던 시절이라 그 충격은 더 했습니다. 구글이 대중적으로 실시간 추천검색어 기능을 선보였고 곧 수많은 포털, 웹사이트에서 따라하기 시작합니다. 비슷한 시기에 &lt;a href=&quot;http://prototypejs.org/&quot;&gt;prototype.js&lt;/a&gt;와 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;가 나왔고 웹 세계는 대 Javascript 시대를 맞이하게 됩니다.&lt;/p&gt;

&lt;p&gt;Javascript 라이브러리를 안쓰는 페이지는 없었고 ajax를 이용한 동적인 컨텐츠 구성도 일반적으로 사용되기 시작했습니다. 하지만 제대로 된 표준이라던가 프레임워크는 없었고 이를 화면에서 표현하기 위해 다양한 방법이 등장합니다.&lt;/p&gt;

&lt;h2 id=&quot;javascript--&quot;&gt;Javascript 뷰 렌더링&lt;/h2&gt;

&lt;p&gt;예전에 뷰는 서버 프로그램에 찰싹 달라붙어 있었지만 이제 Javascript를 이용하여 동적으로 HTML을 만드는 시대가 왔습니다. 동적으로 HTML을 만드는 방법을 하나씩 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;string-concatenation&quot;&gt;String concatenation&lt;/h3&gt;

&lt;noscript&gt;&lt;pre&gt;$(&amp;#39;#profile&amp;#39;).append(&amp;#39;&amp;lt;p&amp;gt;&amp;#39; + data.name + &amp;#39;님 안녕하세요.&amp;lt;/p&amp;gt;&amp;#39;);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/dc7630ef6346f5108e2c5fc789615387.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;가장 쉬운방법은 HTML을 string을 붙이고 붙이고 붙여서 특정 DOM에 넣는 것 입니다. 굉장히 심플하고 잘 동작합니다. 그런데 쓰다보니 몇가지 문제가 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;data.name&lt;/code&gt;에 태그(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;)가 들어갈 수 있어 XSS&lt;sub&gt;Cross-Site Scripting&lt;/sub&gt; Injection에 노출되어 있습니다. 이를 보완한 좀더 복잡해진 예를 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;var htmlString = &amp;#39;&amp;#39;;
htmlString += &amp;#39;&amp;lt;div&amp;gt;&amp;#39;;
htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;#39; + data.name.replace(&amp;#39;&amp;lt;&amp;#39;, &amp;#39;&amp;amp;lt;&amp;#39;).replace(&amp;#39;&amp;gt;&amp;#39;, &amp;#39;&amp;amp;gt;&amp;#39;) + &amp;#39;&amp;lt;/p&amp;gt;&amp;#39;;
if (data.image) {
  htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#39; + data.image.replace(&amp;#39;&amp;lt;&amp;#39;, &amp;#39;&amp;amp;lt;&amp;#39;).replace(&amp;#39;&amp;gt;&amp;#39;, &amp;#39;&amp;amp;gt;&amp;#39;) + &amp;#39;&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;#39;;
} else {
  htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;/images/avatar.jpg&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;#39;;
}
htmlString += &amp;#39;&amp;lt;/div&amp;gt;&amp;#39;;

$(&amp;#39;#profile&amp;#39;).append(htmlString);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/34bb24f334004572ddedc1b3162aaf56.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;음 점점 따옴표를 사용할때마다 신경이 곤두서고 동작은 하지만 뭐가 뭔지 모르게 되어 갑니다. 태그를 치환하는 부분을 실수로 빼먹기라도 하면 심각한 보안 문제가 발생할 수 있습니다. 뷰는 더 복잡해지고 상황은 더 심각해지고 HTML은 Javascript에 섞이며 퍼블리셔는 포기하고 우리는 더 많은 야근을 하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;template-engine&quot;&gt;Template engine&lt;/h3&gt;

&lt;p&gt;이러한 상황을 해결하기 위해 각종 템플릿 엔진이 등장하기 시작합니다. 제가 가장 오랜시간 애용했던 &lt;a href=&quot;http://olado.github.io/doT/index.html&quot;&gt;doT.js&lt;/a&gt;를 비롯해 twitter에서 만든 &lt;a href=&quot;http://twitter.github.io/hogan.js/&quot;&gt;hogan.js&lt;/a&gt;, &lt;a href=&quot;https://mustache.github.io/&quot;&gt;mustach&lt;/a&gt;, &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;handlebars&lt;/a&gt;등등등등 너무너무너무 다양한 템플릿 엔진이 (지금도 계속해서) 등장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/template-engine.png&quot; alt=&quot;template engine compile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각 라이브러리마다 파일 사이즈, 성능, 부가기능등의 차이가 있지만 하는 일은 동일합니다. 중괄호(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;콧수염&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mustach&lt;/span&gt;&lt;/code&gt;)를 이용하여 반복문, 조건문 등을 넣은 템플릿파일을 만들고 Data를 연동하여 HTML을 생성합니다. 이러한 방법은 string을 붙이고 붙이고 붙이는 방법보다 훨씬 나은 환경을 보여줍니다.&lt;/p&gt;

&lt;p&gt;지금도 새로운 템플릿엔진이 계속해서 나오고 있고 동적으로 작은 view를 처리하거나 큰 프레임워크의 일부로 사용되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;framework&quot;&gt;Framework&lt;/h2&gt;

&lt;p&gt;이러한 상황에서 javascript MVC(MV*?) framework들이 등장하게 됩니다. MVC? 왜???? 서버도 MVC로 짜기 바쁜데 왠 client side mvc?&lt;/p&gt;

&lt;p&gt;웹환경은 점점 더 리치해지고 고객들은 점점 더 편하게 웹 사이트를 이용하려고 합니다. 지메일이나 구글 캘린더와 같은 서비스는 일반적인 방식으로는 거의 짜기가 불가능할 정도로 복잡해졌습니다.&lt;/p&gt;

&lt;p&gt;이때, &lt;a href=&quot;http://backbonejs.org/&quot;&gt;Backbone.js&lt;/a&gt;가 엄청나게 히트합니다. 템플릿과 모델, 이벤트를 분리하여 작업할 수 있게 도와주었고 미니멀한 구조와 빠른 속도, 이해하기 쉬운 코드로 많은 인기를 얻습니다. 심플해서 좋았지만 심플하다는건 기능이 부족했다는 뜻이고 부족한 기능을 보완하기위해 marionette과 같은 Backbone 플러그인이 등장하여 같이 인기를 얻습니다. 이전보다는 많이 진일보했지만 아직 &lt;strong&gt;프레임워크&lt;/strong&gt;라고 부르기에는 기능이 조금 부족합니다.&lt;/p&gt;

&lt;p&gt;Backbone.js가 인기를 끌기 시작할때 &lt;strong&gt;제대로 된&lt;/strong&gt; 프론트엔드 프레임워크들이 등장합니다. &lt;a href=&quot;http://emberjs.com/&quot;&gt;Ember&lt;/a&gt;, &lt;a href=&quot;http://knockoutjs.com/&quot;&gt;Knockout&lt;/a&gt;등이 등장하였는데 예전부터 각자의 프로젝트에서 활용하고 있던 것들을 잘 정리하여 오픈소스로 공개하였습니다. 이러한 프레임워크들은 소스사이즈가 컸고 성능은 무겁고 기능은 복잡하고 러닝커브는 마구 올라갔습니다. 뭔가 좋아보이기는 하는데 쓰기엔 너무 무거워 보였고 굳이 프론트엔드를 MVC로 구성해야 하는 생각도 듭니다.&lt;/p&gt;

&lt;p&gt;그때 끝판왕 AngularJS가 나타납니다.&lt;/p&gt;

&lt;h2 id=&quot;angularjshttpsangularjsorg&quot;&gt;&lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;AngularJS는 React를 돋보이게 하기 위함이니 좀더 상세하게 설명합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/google-trend-angularjs.png&quot; alt=&quot;Google Trends&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AngularJS는 기존의 라이브러리나 프레임워크들과는 다르게 DOM을 조작하거나 제어하는 방식에 초점을 맞추지 않고 데이터의 변화에 초점을 맞추는 완전히 새로운 접근법을 사용합니다. 데이터에 초점을 맞추는 이러한 방식자체는 완전히 새로운게 아니였으나 정말 &lt;strong&gt;잘&lt;/strong&gt; 구현하여 사용하기 쉽게 공개한 겁니다. HTML에 작성해야 하는 코드는 조금 늘었지만 Javascript쪽 코드는 정말 놀라울정도로 단순해지고 저를 포함한 웹 프론트엔드 개발자들은 열광합니다.&lt;/p&gt;

&lt;p&gt;AngularJS의 장점을 구체적으로 살펴봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;div ng-controller=&amp;quot;myController&amp;quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li ng-repeat=&amp;quot;talk in talks&amp;quot;&amp;gt;
      {{talk.name}}
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
angular.module(&amp;#39;myApp&amp;#39;, [])  
  .controller(&amp;#39;myController&amp;#39;, function($scope) {
    $scope.talks = [{name:&amp;#39;Kim&amp;#39;}, {name:&amp;#39;Lee&amp;#39;}, {name:&amp;#39;Jung&amp;#39;}]
  });
&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/1b2d30907d648357876834eddb205075.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;개발속도가 빠름&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특별한 추가 코드 없이 변수 할당만으로 양방향 데이터 바인딩 지원. get/set 함수 필요없음&lt;/li&gt;
  &lt;li&gt;별도의 템플릿 코드 분리 없이 뷰-데이터 연동. 기본 HTML이 곧 템플릿파일&lt;/li&gt;
  &lt;li&gt;DI&lt;sub&gt;Dependency Injection&lt;/sub&gt; 패턴사용. new같은 없고 그냥 인자로 넘기기만 하면됨&lt;/li&gt;
  &lt;li&gt;모듈화가 잘되어 있어 재사용이 용이함&lt;/li&gt;
  &lt;li&gt;플러그인이 엄청나게 많음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;유지보수가 쉬움&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Javascript 코드량이 적음&lt;/li&gt;
  &lt;li&gt;MVC 패턴이 잘 정리되어 있어 개발자간 코드가 비슷함&lt;/li&gt;
  &lt;li&gt;Controller, Directive, Filter, Service 모듈 구분이 명확&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;테스트 코드 작성 용이&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모듈별 테스트 작성이 쉬움. 튜토리얼도 테스트코드부터 시작함&lt;/li&gt;
  &lt;li&gt;데이터 로딩 시점이 비동기인 경우 E2E&lt;sub&gt;end-to-end&lt;/sub&gt; 테스트가 까다로운 경우가 있는데 &lt;a href=&quot;http://www.protractortest.org/&quot;&gt;Protractor&lt;/a&gt;를 사용하면 간단함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 분리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;백엔드를 API서버로 사용하여 프론트엔드와 완전히 분리할 수 있음&lt;/li&gt;
  &lt;li&gt;템플릿을 스크립트 태그나 Javascript에서 관리하지 않고 HTML을 그대로 사용하여 퍼블리셔 협업도 좋음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;구글이 관리함&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오오, 구글에서 지메일, 캘린더 이런걸로 만드는건가??&lt;/li&gt;
  &lt;li&gt;망하진 않겠다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점이 어마어마 합니다. 그럼 단점을 알아볼까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AngularJS의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;속도가 느림. 특히 모바일&lt;/li&gt;
  &lt;li&gt;IE8지원안함 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;러닝커브가 높음. 특히 Directive는 공부할수록 헬&lt;/li&gt;
  &lt;li&gt;비표준 태그 사용의 찝찝함. (대부분의 브라우져가 잘 처리하긴 하지만서도..)&lt;/li&gt;
  &lt;li&gt;페이지 깜빡임 이슈(&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_of_unstyled_content&quot;&gt;FOUC&lt;/a&gt;&lt;sub&gt;Flash of unstyled content&lt;/sub&gt;) &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;묘한 애니메이션 적용. 컨텐츠가 그려지는 시점을 정확하게 제어하기 어려워 애니메이션 적용이 쉽지 않음&lt;/li&gt;
  &lt;li&gt;SEO 이슈. 크롤링 봇은 컨텐츠 로딩전 빈페이지만 바라봄. title, meta tag도 처음 페이지것만 바라봄 &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;뒤로가기 하면 페이지 새로 로딩함. history API를 이용한 페이지 이동이 실제로는 페이지를 동적으로 로딩하는 구조. 스크롤도 최상단으로 이동 &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;외부 서비스 콜백처리
    &lt;ul&gt;
      &lt;li&gt;외부(페이스북, 구글, …) 로그인 후 돌아오는 페이지는 어떻게 처리하나?&lt;/li&gt;
      &lt;li&gt;이메일 회원가입 확인 페이지는 어떻게 하나?&lt;/li&gt;
      &lt;li&gt;결제 페이지 이동은 어떻게 하나?&lt;/li&gt;
      &lt;li&gt;결국 백엔드쪽에 뷰 페이지를 만들어야 하나?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt;와의 호환성
    &lt;ul&gt;
      &lt;li&gt;Angular 2는 완전히 다르다?!&lt;/li&gt;
      &lt;li&gt;기존 1버전은 곧 지원 중단?!&lt;/li&gt;
      &lt;li&gt;호환이 안된다? 업데이트가 안된다?!&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;만 지원한다? 그게 뭔데 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;del&gt;구글도 자기 서비스에 안씀&lt;/del&gt;
    &lt;ul&gt;
      &lt;li&gt;안쓰는 줄 알았는데 사용하고 있었네요 (강규현님 감사합니다)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.madewithangular.com/#/categories/google&quot;&gt;https://www.madewithangular.com/#/categories/google&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;엄청난 장점만큼 단점을 같이 보았는데 사실 대부분의 단점은 AngularJS의 단점이라기 보다는 &lt;strong&gt;웹앱&lt;/strong&gt;의 단점입니다. AngularJS는 앱용 웹에 적합한 프레임워크입니다. 가만보니 공식사이트 메인에 &lt;em&gt;HTML enhanced for web apps!&lt;/em&gt; 라고 적혀있습니다.&lt;/p&gt;

&lt;p&gt;이런 사실을 무시하고 일반적인 서비스에 쓴적이 있습니다. 속도가 느린건 핸드폰이 빠르게 발전하면서 해결될거라 믿었고 위에 나열한 단점은 열심히 꼼수(?)로 해결할 수 있을것 같았습니다.&lt;/p&gt;

&lt;p&gt;하지만, 결국 Angular 2가 공개되고 업데이트를 포기하게 됩니다. 여러가지 꼼수를 다시 적용하고 테스트하고 관리하기가 너무 힘들고 이미 이전 프로젝트도 꼼수로 인해 너덜너덜해진 상태입니다. 기술적으로 안되는건 없겠지만(&lt;del&gt;안되는 것도 있음&lt;/del&gt;) 결국 유지보수와 호환성에 문제가 생깁니다. 웹앱이 아니라면 브라우저가 알아서 해주는 것들을 웹앱이기 때문에 여러가지 추가적인 셋팅이 필요하게 됩니다.&lt;/p&gt;

&lt;p&gt;AngularJS는 좋지만, 웹앱용에 한정이고 성능이 크게 중요치 않은 어드민이나 내부서비스에 적합하다고 결론을 내립니다.&lt;/p&gt;

&lt;h2 id=&quot;reactjshttpsfacebookgithubioreact&quot;&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;ReactJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;끝판왕(&lt;del&gt;인줄알았던&lt;/del&gt;) AngularJS말고 다른거 없나 찾고 있을때 거짓말처럼 페이스북에서 React를 발표합니다. React는 MVC프레임워크는 아니고 User Interface(View)를 만드는 라이브러리입니다. AngularJS처럼 MVC를 표방하는 것이 아니라 V(iew)에 집중하였고 훨씬 가벼웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;React의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉽다. API가 몇개 없다. 일단 시작하긴 쉽다.&lt;/li&gt;
  &lt;li&gt;빠르다. 느린 DOM대신 Virtual DOM이라는 걸 이용.&lt;/li&gt;
  &lt;li&gt;단순하다. 2-way 바인딩 대신 1-way를 지원하고 Component 구성하기 쉬움.&lt;/li&gt;
  &lt;li&gt;서버 사이드 렌더링 지원이 좋음&lt;/li&gt;
  &lt;li&gt;ES6지원 좋음&lt;/li&gt;
  &lt;li&gt;일부페이지에 큰 수정없이 바로 적용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 React는 갑자기 등장한 라이브러리가 아닙니다. 페이스북은 PHP를 사용하는 대표적인 회사로 PHP의 성능을 개선하기 위해 &lt;a href=&quot;http://hacklang.org/&quot;&gt;Hack&lt;/a&gt;이라는 언어를 자체적으로 만들고 &lt;a href=&quot;http://hhvm.com/&quot;&gt;HHVM&lt;/a&gt;이라는 가상머신도 만든 고오오오급 개발 회사입니다. 그리고 PHP의 문법을 변경하여 뷰 렌더링을 좀더 쉽게 한 &lt;a href=&quot;http://facebook.github.io/xhp-lib/&quot;&gt;XHP&lt;/a&gt;를 2010년에 발표하기도 하였습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// php - string concatenation
$str = &amp;#39;&amp;lt;ul&amp;gt;&amp;#39;;
foreach($talks as $talk) {
  $str += &amp;#39;&amp;lt;li&amp;gt;&amp;#39; . $talk-&amp;gt;name . &amp;#39;&amp;lt;/li&amp;gt;&amp;#39;;
}
$str = &amp;#39;&amp;lt;/ul&amp;gt;&amp;#39;;

// xhp
$content = &amp;lt;ul /&amp;gt;;
foreach($talks as $talk) {
  $content-&amp;gt;appendChild(&amp;lt;li&amp;gt;{$talk-&amp;gt;name}&amp;lt;/li&amp;gt;);
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/85b3d6f54af7be72df149463f7b142bb.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;간단한 XHP 코드 샘플을 보면 PHP변수에 HTML태그를 바로 할당하여 사용하는 걸 볼 수 있습니다. XSS 이슈를 방지해주고 커스텀 태그를 쓸 수 있어 코딩이 더 단순해지고 쉬워집니다.&lt;/p&gt;

&lt;p&gt;태그를 바로 할당해서 사용할 수 있는 아이디어를 Javascript로 가져오기로 하고 2013년에 &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;를 만듭니다. 여기에 Virtual DOM이라는 걸 도입하여 DOM을 직접 계산하지 않고 내부적으로 빠르게 diff를 계산하는 알고리즘을 만들어냅니다. 마치 git을 사용하듯이 변경된 부분만 샤샤샤 찾아주어 빠르게 화면을 렌더링 할 수 있게 해줍니다. 첫 알고리즘은 O(n&lt;sup&gt;3&lt;/sup&gt;) 이였으나 결국 O(n)으로 완성합니다. ㄷㄷㄷ 게다가 React는 처음부터 서버 사이드 렌더링을 고려하여 설계합니다. 이런 짱짱맨..&lt;/p&gt;

&lt;p&gt;서버 사이드 렌더링을 지원하므로 웹앱때문에 생기는 단점이 거의 없고 컴포넌트를 이용한 구조는 개발속도를 빠르게 하고 유지보수를 용이하게 도와줍니다. 그리고 이미 facebook, instagram, airbnb, netflix, flipboard, dropbox등에서 사용하고 있습니다. 운영 환경에 사용할 수 있는 &lt;strong&gt;현실적인 끝판왕&lt;/strong&gt;이 등장했습니다.&lt;/p&gt;

&lt;p&gt;전체 구조를 바꾸지 않더라도 적용하기 쉽기 때문에 진행중인 서비스에서 일부 동적 로직이 필요한 페이지에 React를 사용하고 서버 사이드 렌더링을 적용하기로 합니다.&lt;/p&gt;

&lt;h2 id=&quot;isomorphic-javascript&quot;&gt;Isomorphic Javascript&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-javascript.png&quot; alt=&quot;Isomorphic Javascript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동형 자바스크립트라는 어색한 말로 해석되는 Isomorphic Javascript는 서버와 클라이언트가 같은 코드를 사용한다는 뜻입니다. 웹브라우져에서만 동작할 것 같았던 Javascript가 &lt;a href=&quot;https://developers.google.com/v8/&quot;&gt;V8엔진&lt;/a&gt;이 등장하고 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;가 나타나면서 서버에서도 Javascript를 사용하기 시작합니다. 클라이언트에서 동작하던 라이브러리를 서버에서 똑같이 돌릴수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/client-side-vs-server-side.png&quot; alt=&quot;Client vs Server rendering from airbnb&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서버 사이드 렌더링의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;유저가 처음으로 컨텐츠를 보는 속도가 빨라짐&lt;/li&gt;
  &lt;li&gt;서버따로 클라이언트따로 작성하던 코드가 하나로 합쳐짐&lt;/li&gt;
  &lt;li&gt;SEO 적용도 OK&lt;/li&gt;
  &lt;li&gt;웹앱의 단점 대부분 없어짐!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react---&quot;&gt;React 서버 사이드 렌더링&lt;/h2&gt;

&lt;p&gt;React는 서버 사이드 렌더링을 염두에 두고 설계되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; 함수는 서버 사이드에서 사용하는 렌더링 함수입니다. 이 함수는 HTML을 생성하는데 클라이언트에서 동적으로 생성하는 것과 동일한 HTML을 생성합니다. 다른점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-react-checksum&lt;/code&gt;과 같은 attribute가 추가되었다는 점입니다.&lt;/p&gt;

&lt;p&gt;서버 사이드에서 생성된 HTML에는 이벤트 속성이 없기 때문에 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOM.render()&lt;/code&gt;과 같은 클라이언트 사이드 렌더링을 다시 한번 수행해야 합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;....&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;talkList&amp;quot;&amp;gt;&amp;lt;%= React.renderComponentToString(&amp;lt;TalkView /&amp;gt;); %&amp;gt;&amp;lt;/div&amp;gt;
  
  &amp;lt;script&amp;gt;
    // attach event
    React.renderComponent(&amp;lt;TalkView /&amp;gt;, document.getElementById(&amp;#39;talkList&amp;#39;));
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/6e9c87c3395f599a80da8e21ebbed822.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;두번 렌더링한다구요?&lt;/strong&gt; 네.&lt;/p&gt;

&lt;p&gt;두번째 렌더링을 할때 이미 서버 사이드 렌더링이 되어 있다면 attribute값을 보고 다시 렌더링 하지 않고 생성된 DOM에 오직 이벤트 속성만 추가합니다. checksum을 보고 판단하기 때문에 속도가 굉장히 빠릅니다.&lt;/p&gt;

&lt;p&gt;이러한 부분이 이미 React는 서버 사이드 렌더링을 염두에 두고 설계되었다는 점입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;서버 사이드 렌더링 적용&lt;/h2&gt;

&lt;p&gt;그럼 실제로 서버 사이드 렌더링을 사용하려면 어떻게 해야 할까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 서버가 Node.js일때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-only.png&quot; alt=&quot;Node.js server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버가 Node.js일 경우 바로 React 코드를 실행할 수 있습니다. 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;renderToString&lt;/code&gt; method를 실행하여 view에 그리면 됩니다. 와우!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. V8엔진 라이브러리를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-v8.png&quot; alt=&quot;Use V8 engine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버가 Node.js가 아닐 경우 각 언어에서 제공하는 V8 engine을 사용할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;V8 engine을 만들고&lt;/li&gt;
  &lt;li&gt;React와 Component 소스를 전부 입력하여 컴파일을 한 뒤&lt;/li&gt;
  &lt;li&gt;Data를 인자로 실행하여 HTML 얻음&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;서버에 V8 engine만 설치되어 있다면 비교적 쉽게 구현할 수 있습니다. 특히 &lt;a href=&quot;https://github.com/reactjs/react-rails&quot;&gt;react-rails&lt;/a&gt;, &lt;a href=&quot;https://github.com/reactjs/react-php-v8js&quot;&gt;React-PHP-V8Js&lt;/a&gt;, &lt;a href=&quot;https://github.com/reactjs/React.NET&quot;&gt;React.NET&lt;/a&gt;는 React에서 직접 관리하는 라이브러리로 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 별도의 Node.js 서버 구축&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-backend.png&quot; alt=&quot;Node.js render server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;React 코드만 실행하고 렌더링하는 별도의 Node.js 서버를 띄우는 방법입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;원래 웹서버로 요청이 들어오면&lt;/li&gt;
  &lt;li&gt;다시 Node.js 서버로 렌더링을 위한 정보(module, props JSON)를 HTTP request하고&lt;/li&gt;
  &lt;li&gt;Node.js 서버에서는 renderToString한 결과 string을 HTTP response&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;서버를 하나 더 관리해야 하는 번거로움과 HTTP 통신으로 인한 overhead가 발생하여 좋지 않은 방법이라고 생각하는데 의외로 사용하는 곳이 많은 것 같습니다. Airbnb에서 만든 &lt;a href=&quot;https://github.com/airbnb/hypernova&quot;&gt;hypernova&lt;/a&gt;를 이용하면  Express.js등을 사용할 필요 없이 렌더링 전용 서버를 구축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 기존 서버가 API 구성하기 용이할때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-front.png&quot; alt=&quot;Node.js frontend server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존 서버가 API를 잘 제공하고 있다면 앞단에 Node.js를 두고 기존 서버를 API서버로 사용하는 방법이 있습니다. 이럴 경우 쿠키라던가 인증 토큰등을 추가로 관리하고 라우팅을 다시 셋팅해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;현재 React를 즐겨 사용하고 있긴 하지만, 사실 언제 또 바뀔지 모릅니다. 최근에는 &lt;a href=&quot;https://www.meteor.com/&quot;&gt;meteor&lt;/a&gt;라는 걸출한 Javascript App Platform이 나와서 인기를 얻고 있습니다. 빠르게 변하는 웹환경만큼 새로운 라이브러리, 프레임워크도 계속해서 나옵니다. 왜 프론트엔드 개발자는 끊임없이 공부해야 하는가? 대체 언제 좀 편하게 예전에 배웠던거 슬렁슬렁 쓰면서 개발할 수 있을까? 라는 질문을 해보지만, 포기하고 적당히 하는 순간 빠르게 변하는 웹 세계에서 뒤쳐진다고 생각합니다.&lt;/p&gt;

&lt;p&gt;하지만, 공부하는 것과 운영환경에 적용하는 것은 다른 이야기로 React가 쉽고 간단한 라이브러리인 것처럼 묘사했지만 redux가 들어가고 좀 더 리치하게 사용하려고 하면 결코 쉽지 않다는걸 알게 됩니다. 그리고 많이 빨라졌다고 하지만 역시 라이브러리는 무겁고 아직 모바일 환경에서는 느릴 수 밖에 없습니다.&lt;/p&gt;

&lt;p&gt;결론적으로, 무조건 새로운 기술을 도입하는 것 보다는 정말 필요한지 고려해보고 도입하는 것이 중요합니다. 그리고 모든 페이지에 적용하려고 하지 말고 정말 필요한 일부 페이지에 적용하는 것이 속도면에서나 유지보수면에서나 호환성면에서 나은 결과를 보여줍니다. 1-2년이 지나면 결국 또 바뀌게 됩니다. 누가, 어떻게 업데이트 합니까?&lt;/p&gt;

&lt;p&gt;아무쪼록 React는 좀 오래가길 빌면서, 이번에 출시한 튀김 맛있으니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;주석&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/fergaldoyle/angular.js-ie8-builds&quot;&gt;angular.js-ie8-build&lt;/a&gt;를 이용하면 IE8에서도 돌긴돔 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.angularjs.org/api/ng/directive/ngCloak&quot;&gt;ng-cloak&lt;/a&gt;으로 어느정도 극복가능 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://prerender.io/&quot;&gt;prerender&lt;/a&gt;를 이용하면 어느정도 극복가능. meta tag 업데이트도 디렉티브를 만들면 됨 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;스크롤 위치를 기억했다가 뒤로가기라고 인지되면 다시 강제로 이동시켜주는 방법 있음 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 20 Jun 2016 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2016/06/20/server-side-rendering-with-react.html</link>
        <guid isPermaLink="true">https://subicura.com/2016/06/20/server-side-rendering-with-react.html</guid>
        
        <category>FrontEnd</category>
        
        <category>Javascript</category>
        
        <category>React</category>
        
        <category>Angular</category>
        
        
        <category>Javascript</category>
        
      </item>
    
      <item>
        <title>Go언어로 오픈소스 배송조회 서비스 만들기</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/yongman-pork.jpg&quot; alt=&quot;돈까스먹는용만이x칠리등심돈까스&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt;에서 세번째로 런칭한 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/24/&quot;&gt;돈까스&lt;/a&gt;를 구매해 주시는 분들을 보면서 &lt;em&gt;아.. 받은 만큼 나도 뭔가 베풀어야겠구나&lt;/em&gt; 라는 생각에 배송조회 서비스를 오픈소스로 공개하는 과정을 정리해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;이라는 소셜코딩 플랫폼이 등장하면서 오픈소스에 참여할 수 있는 장벽이 많이 낮아졌습니다. 사용하던 오픈소스에서 버그를 발견하면 이슈를 살펴보고 수정한 소스를 슬쩍 풀 리퀘스트 하면 됩니다. 내가 작성한 소스가 커미터 마음에 들면 머지가 될 것이고 그렇게 우리는 오픈소스 컨트리뷰터가 되고 인류에 조금이라도 공헌한 사람이 됩니다.&lt;/p&gt;

&lt;p&gt;이러한 활동은 실력도 늘고 이력도 쌓고 재미도 느낄수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 컨트리뷰터는 해봤으니 커미터가 되어봅시다. 아쉽게도 인기있는 오픈소스의 커미터는 꽤 많은 노력이 필요하고 고오급 개발자만 가능한 것 같습니다.
그럼 오픈소스 프로젝트를 직접 운영해보는건 어떨까요? 직접 오픈소스 프로젝트를 운영하면 커미터가 될 수 있고 리뷰어도 될 수 있고 프로젝트를 운영하면서 많은 노하우를 배울수도 있습니다. 아참, 오픈소스에 참여하면 IntelliJ IDE도 &lt;a href=&quot;https://www.jetbrains.com/buy/opensource/&quot;&gt;무료&lt;/a&gt;로 사용할 수 있고 JIRA도 &lt;a href=&quot;https://ko.atlassian.com/software/views/open-source-license-request&quot;&gt;무료&lt;/a&gt;로 쓸 수 있습니다.&lt;/p&gt;

&lt;div align=&quot;center&quot; class=&quot;googleads googleads-content&quot;&gt;
                &lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-2468713653725581&quot; data-ad-slot=&quot;8649023787&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;
                &lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push({});&lt;/script&gt;
            &lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;어떤걸 만들까?&lt;/h2&gt;

&lt;p&gt;커머스에서 상품이 배송되면 배송상태를 추적해야합니다. 배송이 완료되면 구매확정 버튼을 누르게 할수도 있고, 배송정보 화면을 커스터마이징 할 수도 있습니다. 많은 배송업체가 API를 제공하지 않기 때문에 자동화하기가 까다롭습니다.(대체 다른 서비스들은 어떻게 추적하는거지…?) 그래서 결국 HTML을 파싱하는 방법을 선택합니다. 택배사와 송장번호를 입력하면 택배 사이트에 접속하여 HTML을 읽고 DOM을 파싱하여 정리된 포멧으로 택배정보를 조회하는 서비스를 만듭니다&lt;/p&gt;

&lt;p&gt;혹시 누가 만들어 놓지 않았을까 검색을 해보니 무료에 오픈소스로 공개된 건 없는것 같습니다. 질문글도 많고 원하는 사람도 있는거 같으니 오픈소스로 하기 딱인 프로젝트인것 같습니다. 아무도 안쓰는 기능을 만들면 힘들게 오픈해도 반응이 없어서 슬픔 ㅠ&lt;/p&gt;

&lt;h2 id=&quot;go-&quot;&gt;왜 서비스를 따로 분리하여 오픈소스에 Go로 만드는가?&lt;/h2&gt;

&lt;p&gt;배송조회 서비스는 기존 웹서비스에 하나의 액션으로 구현하는게 아니라 완전히 독립적으로 구현합니다. 몇가지 검토끝에 오픈소스로 공개하기로 하였고 가벼운 프로젝트라 Go언어로 구현합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;왜 &lt;a href=&quot;http://martinfowler.com/articles/microservices.html&quot;&gt;마이크로서비스&lt;/a&gt;인가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/monolith-microservice.png&quot; alt=&quot;monoliths / microservices&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마이크로서비스와 비교되는 방식으로 모놀리식이라는 서비스 개발 방법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 기능을 하는 하나의 큰 프로그램을 만드는 것 (우리가 잘알고 있고 매우 전통적인 개발스타일)&lt;/li&gt;
  &lt;li&gt;하나의 웹서버를 띄우면 회원가입도 되고 정보조회도 되고 메일도 보낼 수 있고 푸시도 보낼 수 있고 통계도 보고 안되는게 없음&lt;/li&gt;
  &lt;li&gt;하나의 작은 기능을 수정해도 전체를 재배포해야하고 특정 기능에 트래픽이 몰려도 전체 서비스를 여러개 띄워야함&lt;/li&gt;
  &lt;li&gt;코드가 커질수록 유지보수가 어려워짐&lt;/li&gt;
  &lt;li&gt;새로운걸 추가하고 싶은데 기존 로직/데이터에 어떤 문제가 있을지 모름&lt;/li&gt;
  &lt;li&gt;기존 기술(버전, 언어, 프레임웍)외에 새로운 기술을 쓰기 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면, 마이크로서비스 방식은 어떤걸까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최근 많이 사용되는 마이크로서비스는 기능별로 서비스를 분리하고 독립적으로 동작하게 구성하는 방식&lt;/li&gt;
  &lt;li&gt;기존 웹서비스에 영향을 미치지 않고 독립적으로 개발/유지보수가 가능&lt;/li&gt;
  &lt;li&gt;서버 확장, 배포, 적절한 기술사용, 조직구성등이 유연해짐&lt;/li&gt;
  &lt;li&gt;물론, 관리할게 많아지고 테스트가 어려워지는 단점존재&lt;/li&gt;
  &lt;li&gt;쪼개는 범위와 전략은 서비스에 따라 다름. 무조건 잘게 쪼갠다고 좋지 않음&lt;/li&gt;
  &lt;li&gt;아.. 우리서비스도 이런식인데? 라는 분은 용어는 처음이라도 이미 마이크로 서비스방식으로 개발하고 있을 확률이 높음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배송조회 서비스는 SMS나 Email서비스를 호출하듯이 독립적으로 분리하고 싶었습니다. 별도의 서버로 띄우고 REST API를 요청하여 정보를 가져오는 방식으로 구성합니다. 분리되서 좋고 나중에 다른 서비스에서 사용할 수도 있을겁니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;왜 오픈소스 인가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;처음 얘기한 개발자 스스로에게 도움이 되는 장점외에 배송조회의 특성상 오픈소스가 어울린다고 생각합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;택배사가 너무 많음. 우리나라만 20개정도에 외국까지 포함하면 100개가 넘음 &amp;gt; 혼자 모든 택배사의 배송정보를 구현할 순 없지만, 각자 필요한 사람들이 구현한다면?!&lt;/li&gt;
  &lt;li&gt;공식 API가 아닌 비공식적인 방법이라 언제 막힐지 모름 &amp;gt; 누군가 수정사항을 발견하고 개선해 나간다면?!&lt;/li&gt;
  &lt;li&gt;우체국 택배만 필요한 사람도 있을거고 CJ대한통운만 필요한 사람이 있듯이 각자의 필요에 따라 조금씩 수정 보완하여 개발하면 서로 윈윈!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;왜 &lt;a href=&quot;https://golang.org/&quot;&gt;Go&lt;/a&gt;인가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/languages.png&quot; alt=&quot;languages&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구글이 개발한 가장 핫한 언어&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/GoUsers&quot;&gt;Go를 사용중인 회사들&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eng.uber.com/go-geofence/&quot;&gt;uber의 Go언어 사용사례&lt;/a&gt;, &lt;a href=&quot;http://blog.parse.com/learn/how-we-moved-our-api-from-ruby-to-go-and-saved-our-sanity/&quot;&gt;parse의 ruby에서 go로 전환사례&lt;/a&gt;(루비야 아프지마.. ㅠ)&lt;/li&gt;
  &lt;li&gt;코딩이 재밌고 속도도 괜찮음&lt;/li&gt;
  &lt;li&gt;정적언어지만 동적언어의 장점을 많이 가져옴&lt;/li&gt;
  &lt;li&gt;빠른 컴파일 빠른 실행&lt;/li&gt;
  &lt;li&gt;가비지컬랙션, 메모리 처리 안정성(nil 참조등), methods, interfaces, type assertions, reflection 지원&lt;/li&gt;
  &lt;li&gt;VM사용안함. 바로 실행가능한 바이너리 파일로 생성됨&lt;/li&gt;
  &lt;li&gt;심플하고 간결한 문법
    &lt;ul&gt;
      &lt;li&gt;클래스가 없고&lt;/li&gt;
      &lt;li&gt;상속이 없고&lt;/li&gt;
      &lt;li&gt;생성자가 없고&lt;/li&gt;
      &lt;li&gt;final이 없고&lt;/li&gt;
      &lt;li&gt;exception이 없고&lt;/li&gt;
      &lt;li&gt;annotation이 없고&lt;/li&gt;
      &lt;li&gt;generic이 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉽고 훌륭한 동시성 처리&lt;/li&gt;
  &lt;li&gt;code style을 강제하여 협업과 유지보수에 유리함&lt;/li&gt;
  &lt;li&gt;단점으로 검색이 어렵고 (구글에서 go를 입력해보자) 패키지관리 시스템이 npm, gem처럼 안정되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배송조회는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http요청&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;html조회&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;parsing&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;응답&lt;/code&gt;하는 과정을 가진 굉장히 단순한 서비스입니다. 새로운 언어를 적용하고 배우는데 가장 좋은 방법은 프로젝트를 한번 해보는 것이고 굉장히 적절한 사이즈의 프로젝트입니다.&lt;/p&gt;

&lt;h2 id=&quot;go--1&quot;&gt;Go로 개발하기&lt;/h2&gt;

&lt;p&gt;Go언어에 대해 설명하는 포스트는 아니지만 Go를 처음 접하는분들을 위해 몇가지 팁을 공유합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공부
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://tour.golang.org/welcome/1&quot;&gt;A Tour of go&lt;/a&gt; - golang에서 공식으로 제공하는 방법으로 실습위주의 방법. 지하철 출퇴근때 하기 딱 좋음&lt;/li&gt;
      &lt;li&gt;공식문서(&lt;a href=&quot;https://golang.org/doc/code.html&quot;&gt;How to Write Go Code&lt;/a&gt;, &lt;a href=&quot;https://golang.org/doc/effective_go.html&quot;&gt;Effective Go&lt;/a&gt;) - 역시 지하철 출퇴근때 보면 좋음&lt;/li&gt;
      &lt;li&gt;책 - 이미 한글로 된 책이 꽤 많이 출간되었고 번역서가 아닌 책도 많아 대부분 내용이 딱딱하지 않고 읽기 좋음(&lt;a href=&quot;http://pyrasis.com/go.html&quot;&gt;무료공개서적&lt;/a&gt;도 있음)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;배송조회 오픈소스&lt;/a&gt; 참여 고고 - 직접 만들어보는게 배우기 가장 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDE
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA Community&lt;/a&gt; 추천&lt;/li&gt;
      &lt;li&gt;무료고 일반적으로 사용하기 쉽고 기능이 강력함&lt;/li&gt;
      &lt;li&gt;GO, File watchers plugin 설치 필수&lt;/li&gt;
      &lt;li&gt;File watcher는 파일을 저장할때마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;goimports&lt;/code&gt;를 실행하여 코드스타일을 정리함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;개발&lt;/h2&gt;

&lt;p&gt;이제 본격적으로 개발을 해 봅니다. 전체 소스는 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;에 공개되어 있습니다. 상세한 내용은 따로 설명하지 않고 어떤점을 주의하면서 개발하였는지 고민했던 과정을 정리합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;웹서버선택&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 다른 언어와 마찬가지로 다양한 웹프레임워크/미들웨어 오픈소스가 존재합니다. Ruby는 &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;가 유명하고 Python은 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;가 유명하고 Node는 &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;가 유명하지만 Go는 대표적인게 없고 아직까지 춘추전국시대입니다. 아마 계속해서 대표적인게 없을수도 있습니다. 이는 Go언어의 특성에 기인을 하는데..&lt;/p&gt;

&lt;p&gt;배송조회 서비스에서 선택한 웹서버 미들웨어는 &lt;a href=&quot;https://github.com/urfave/negroni&quot;&gt;negroni&lt;/a&gt;입니다. negroni는 스스로 할 수 있는게 거의 없는 굉장히 라이트한 미들웨어입니다. 라우팅도 다른 라이브러리를 조합해야 하고 응답 렌더링도 여러 라이브러리중에 하나를 선택해야 합니다. 당연히 디비접속관련이나 ORM도 포함하고 있지 않습니다. 하지만 굉장히 유연하게 &lt;strong&gt;조합&lt;/strong&gt;할 수 있도록 설계되어 있습니다.&lt;/p&gt;

&lt;p&gt;물론, Go언어도 풀프레임워크가 존재합니다. &lt;a href=&quot;https://github.com/go-martini/martini&quot;&gt;martini&lt;/a&gt;(8,521 stars)라던가 &lt;a href=&quot;https://github.com/revel/revel&quot;&gt;revel&lt;/a&gt;(6,895 stars)이 엄청난 인기를 끌고 있습니다. 그런데, negroni는 martini를 개발했던 &lt;a href=&quot;https://github.com/codegangsta&quot;&gt;codegangsta&lt;/a&gt;가 &lt;a href=&quot;https://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/&quot;&gt;martini 디자인 설계는 잘못&lt;/a&gt;이라고 말하고 개발한 미들웨어입니다. 풀프레임워크는 Go언어에 맞는 디자인 설계가 아니라고 생각한겁니다.&lt;/p&gt;

&lt;p&gt;실제로 지금도 다양한 형태의 라우팅 라이브러리가 개발되고 있습니다. 서로 이런기능이 좋고 속도가 좋다고 주장하고 있는데 negroni를 사용하면 이를 적용하기가 굉장히 간단합니다. 이번 프로젝트는 아이디도 간지나고 star 8,000개 프로젝트 따위 맘에 안들면 버릴수도 있고 실력도 고오급인 codegangsta가 주장하는데로 negroni를 선택합니다. 라우팅은 &lt;a href=&quot;https://github.com/gorilla/mux&quot;&gt;gorilla/mux&lt;/a&gt;, 렌더링은 &lt;a href=&quot;https://github.com/unrolled/render&quot;&gt;unrolled/render&lt;/a&gt;를 선택했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 특별한 라이브러리를 설치하지 않아도 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;xxxx_test.go&lt;/code&gt;파일을 작성해서 테스트코드를 작성할 수 있습니다. 하지만 고오급 기능을 위해 &lt;a href=&quot;http://goconvey.co/&quot;&gt;goconvey&lt;/a&gt;를 사용합니다. UI도 이쁘고 코드도 간결합니다. Go언어는 나온지 얼마 되지도 않았는데 이런툴이 있다는게 놀랍..&lt;/p&gt;

&lt;p&gt;HTML을 파싱하는게 주임무이기 때문에 테스트코드는 직접 택배사 서버로 HTTP요청을 하지 않고 &lt;a href=&quot;https://github.com/jarcoal/httpmock&quot;&gt;HTTP mocking&lt;/a&gt;을 이용합니다. 목업을 사용하면 매번 실제서버로 요청을 날리지 않아도 되고 택배정보에 있는 개인 프라이버시도 숨길 수 있어 좋습니다. 샘플을 모으는게 관건!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주석&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 간단하게 주석을 작성하는걸 추천합니다. 구글이 개발해서 그런지 github에 소스를 공개하면 잽싸게 공식 문서 사이트에 소스와 주석을 추출하여 문서로 등록해버립니다.(ㄷㄷㄷ 크롤링하나?;) 배송조회서비스도 공식사이트(&lt;a href=&quot;https://godoc.org/&quot;&gt;godoc.org&lt;/a&gt;)에서 &lt;a href=&quot;https://godoc.org/github.com/purpleworks/delibird&quot;&gt;문서&lt;/a&gt;를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;코딩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹서버과 테스트 방법을 정했으니 본격적으로 코딩을 합니다. HTML DOM을 조회하기 위해 &lt;a href=&quot;https://github.com/PuerkitoBio/goquery&quot;&gt;goquery&lt;/a&gt;를 사용했습니다. jQuery처럼 체이닝메소드를 지원하고 비슷한 API를 제공합니다.&lt;/p&gt;

&lt;p&gt;홈쇼핑처럼은 CJ대한통운만 이용하지만 사용자수 1위인 우체국택배도 구현하였습니다. 뭔가 Go 초보티가 많이 나는 소스지만 동작은 합니다. 일단 완성! 버전 0.1.0으로 등록합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;오픈소스로&lt;/h2&gt;

&lt;p&gt;어떤 프로젝트를 오픈소스화 한다는건 코딩이외에 추가적인 작업들을 필요로 합니다. 단순히 코드를 정리하고 공개하는것 외에 다른 개발자들의 참여를 유도하고 지속가능한 개발을 하기 위해 소스 품질에 신경을 써야 합니다.&lt;/p&gt;

&lt;p&gt;github은 &lt;a href=&quot;https://github.com/explore&quot;&gt;explore&lt;/a&gt;메뉴와 &lt;a href=&quot;https://github.com/trending&quot;&gt;trending&lt;/a&gt;메뉴를 제공합니다. 여기서 인기있는 오픈소스들은 어떤식으로 프로젝트를 구성하고 있는지 참고하면 많은 도움이 됩니다. 몇가지 프로젝트를 참고하여 오픈소스에 필요한 작업들을 해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이름/로고만들기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;개발자들의 코딩시간 대부분을 잡아먹는다는 이름짓기 시간입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;shipment tracking library&lt;/code&gt;보다는 뭔가 그럴듯한 이름을 짓는것이 좋습니다. 개인적으로 생명체가 마스코드인것이 성공하는 오픈소스라고 생각되는데 (github의 &lt;a href=&quot;https://octodex.github.com/&quot;&gt;octocat&lt;/a&gt;, golang의 &lt;a href=&quot;https://blog.golang.org/gopher&quot;&gt;gopher&lt;/a&gt;, docker의 &lt;a href=&quot;https://blog.docker.com/2013/10/call-me-moby-dock/&quot;&gt;moby dock&lt;/a&gt;등..) 그에 따라 적당히 동물을 가지고 이름을 지었습니다. 배송이니까 새가 생각났고 delivery와 bird의 조합인 &lt;strong&gt;Delibird&lt;/strong&gt;가 탄생하였습니다.&lt;/p&gt;

&lt;p&gt;이제 이름을 지었으니 로고를 만듭니다. 직접 그릴순 없으니 심플한 무료 아이콘이 많은 &lt;a href=&quot;https://icons8.com/#/ios&quot;&gt;icons8.com&lt;/a&gt;에서 새 아이콘을 하나 고르고 이쁘장한 색샘플을 모아놓은 &lt;a href=&quot;http://flatuicolors.com/&quot;&gt;flatuicolors.com&lt;/a&gt;에서 보라색계열을 하나 선택합니다. 폰트도 밋밋하지 않게 &lt;a href=&quot;https://www.google.com/fonts&quot;&gt;구글웹폰트&lt;/a&gt;에서 하나 고릅니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/delibird.logo.png&quot; alt=&quot;Delibird Logo&quot; title=&quot;Delibird Logo&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;짠, 포샵을 쓱싹하여 그럴싸한 이름에 로고가 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;문서화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스 프로젝트는 문서가 중요합니다. 문서에 오픈소스를 소개하고 발전 의지를 잘 표현해야 다른 개발자를 참여하게 만들 수 있고 잘 운영되는 듯한 느낌을 줍니다.&lt;/p&gt;

&lt;p&gt;첫번째로 필요한 건 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/README.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;&lt;/a&gt;파일 입니다. 이 파일은 github 첫화면에 보여지기 때문에 매우 중요합니다. 다음과 같은 항목을 기본으로 넣어줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본소개 - 어떤 프로젝트인지 소개&lt;/li&gt;
  &lt;li&gt;설치방법 - 바로 사용해볼 수 있도록 설치방법 소개&lt;/li&gt;
  &lt;li&gt;사용방법 - 샘플을 포함한 사용방법 소개&lt;/li&gt;
  &lt;li&gt;테스트방법 - 전체 테스트를 하는 방법 소개&lt;/li&gt;
  &lt;li&gt;기여방법 - 기여에 대한 설명&lt;/li&gt;
  &lt;li&gt;라이센스 - 라이센스 소개&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째로 필요한 건 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/LICENSE&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LICENSE&lt;/code&gt;&lt;/a&gt;파일입니다. 라이센스는 &lt;a href=&quot;http://choosealicense.com/&quot;&gt;다양한것들&lt;/a&gt;중에 선택할 수 있는데 가장 심플한 MIT 라이센스를 선택합니다.&lt;/p&gt;

&lt;p&gt;추가적으로 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/CHANGELOG.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CHANGELOG.md&lt;/code&gt;&lt;/a&gt;파일등을 추가합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;웹페이지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github은 &lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages/&quot;&gt;page&lt;/a&gt;라는 기능으로 정적인(html, image, css, js) 페이지를 무료로 만들수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;$ git checkout --orphan gh-pages
# Creates our branch, without any parents (it&amp;#39;s an orphan!)
Switched to a new branch &amp;#39;gh-pages&amp;#39;

$ git rm -rf .
# Remove all files from the old working tree
rm &amp;#39;.gitignore&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/56599a77c63ea929f413a7ab8052c61e.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;프로젝트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;라는 브랜치를 만들고 html파일과 js,css파일등을 넣으면 끝입니다. 인터넷에서 무료 bootstrap landing 테마를 하나 다운받아 쓱싹 만들고 push합니다. github 조직이름이 purpleworks이고 프로젝트명이 delibird라면 &lt;a href=&quot;http://purpleworks.github.io/delibird/&quot;&gt;purpleworks.github.io/delibird&lt;/a&gt;라는 URL로 자동으로 연결됩니다. 이를 통해 README.md로는 부족한 내용을 보여줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;여기서는 배송조회 테스트를 해볼수 있으면 좋을것 같아 테스트 폼을 넣었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Github 외부서비스 연동&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github은 다양한 외부 서비스와 연동이 가능합니다. 보통 github 저장소에 소스를 푸시하면 연동된 서비스가 소스를 테스트하고 결과를 알려줍니다. 공개 저장소는 무료로 제공하고 비공개 저장소에 대해서만 과금을 취하는 경우가 일반적입니다.&lt;/p&gt;

&lt;p&gt;유용한 서비스를 연동해 놓으면 코드 품질과 테스트 결과를 자동으로 알 수 있어 매우 유용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://travis-ci.org&quot;&gt;travis-ci&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 Test and Deploy 서비스&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/.travis.yml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt;&lt;/a&gt; 파일을 만들고 빌드 정보 입력&lt;/li&gt;
      &lt;li&gt;매 빌드마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;go test&lt;/code&gt;를 수행하고 결과를 알려줌&lt;/li&gt;
      &lt;li&gt;매 빌드가 끝나면 커버리지 정보를 coveralls로 전송하게 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coveralls.io/&quot;&gt;coveralls&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 코드 커버리지 서비스&lt;/li&gt;
      &lt;li&gt;travis-ci에서 정보를 전달하도록 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://codeclimate.com&quot;&gt;codeclimate&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 코드품질 검사 서비스&lt;/li&gt;
      &lt;li&gt;다양한 항목으로 코드를 검사하여 학점처럼 점수를 매겨줌&lt;/li&gt;
      &lt;li&gt;Go는 아직 지원 안하는듯하여 다른 서비스 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goreportcard.com/&quot;&gt;goreportcard.com&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Go전용 코드품질 검사 서비스&lt;/li&gt;
      &lt;li&gt;go_vet, gocyclo, gofmt, golint, ineffassign, license, misspell등을 돌려 점수를 매겨줌&lt;/li&gt;
      &lt;li&gt;다행히 A+! (점수가 후한듯..)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;뱃지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/github-badge.png&quot; alt=&quot;github badge&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github은 상단에 각종 상태를 뱃지아이콘으로 보여주는 특별한 문화(?)가 있습니다. 라이센스라던가 문서링크, 코드 품질이나 커버리지, 빌드결과(테스트) 여부등이 있습니다. 이외에도 커뮤니티 게시판 링크라던가 채팅링크등 다양한 뱃지가 있습니다. &lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt;에서는 다양한 뱃지아이콘을 제공하고 있고 각 서비스마다 자체적으로 뱃지 링크를 제공하기도 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;license
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt; 라이센스 뱃지 사용&lt;/li&gt;
      &lt;li&gt;소스 저장소의 LICENSE파일을 보고 이미지 생성&lt;/li&gt;
      &lt;li&gt;https://img.shields.io/github/license/{id}/{project}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;godoc
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://godoc.org/&quot;&gt;godoc.org&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;Go프로젝트는 godoc이 자동으로 생성됨&lt;/li&gt;
      &lt;li&gt;https://godoc.org/github.com/{id}/{project}?status.svg&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드품질
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://goreportcard.com/&quot;&gt;goreportcard.com&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;소스 품질 결과를 A+, B, C등의 뱃지로 생성함&lt;/li&gt;
      &lt;li&gt;http://goreportcard.com/badge/{id}/{project}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커버리지
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt; coveralls 뱃지 사용&lt;/li&gt;
      &lt;li&gt;coveralls 결과를 뱃지로 생성함&lt;/li&gt;
      &lt;li&gt;http://img.shields.io/coveralls/{id}/{project}.svg&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빌드결과
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://travis-ci.org&quot;&gt;travis-ci&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;https://travis-ci.org/{id}/{project}.svg?branch=master&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;heroku&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.heroku.com/&quot;&gt;heroku&lt;/a&gt;는 소스빌드/배포/스케일이 자유로운 클라우드 서비스입니다. 다른 웹호스팅 서비스와 차별점은 소스를 업로드만 하면 알아서 웹서버를 띄워준다는 점입니다. 이게 무슨 말이냐면 Rails, Django, Express등은 고유한 파일 구조가 있습니다. 이러한 디렉토리구조나 파일의 확장자를 보고 &lt;a href=&quot;https://devcenter.heroku.com/articles/buildpacks&quot;&gt;알아서&lt;/a&gt; 서버를 띄운다는 신박한 서비스입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/heroku.png&quot; alt=&quot;heroku free plan&quot; title=&quot;heroku free plan&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;더 놀라운건 무료 플렌입니다. 30분간 요청이 없으면 자동으로 서버가 중지되고 그 이후 요청이 들어오면 다시 서버를 시작합니다. 예전에는 시간제한이 없었는데 이제 시간제한이 생겨서 아쉽긴 하지만 테스트로 배송조회 서비스를 켜놓기에는 부족함이 없습니다. heroku에 로그인을 하고 서버를 만든 후 github 소스를 연동하니 바로 서버가 뜹니다. 정말 뜹니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://heroku.com/deploy?template=https://github.com/purpleworks/delibird&quot;&gt;
&lt;img src=&quot;https://www.herokucdn.com/deploy/button.svg&quot; alt=&quot;Heroku button&quot; title=&quot;Heroku button&quot; /&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;게다가, 누구든 쉽게 오픈소스로 부터 서버를 만들 수 있게 &lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-button&quot;&gt;heroku button&lt;/a&gt; 기능을 제공합니다. 소스폴더에 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/app.json&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;app.json&lt;/code&gt;&lt;/a&gt; 파일만 만들어 놓으면 됩니다. 저 버튼을 클릭하면 바로 테스트 서버를 띄워볼 수 있습니다. 언제 이렇게 서버 띄우기 쉬운 세상이 되었나요? ㄷㄷ&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;커뮤니티&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스에서 중요한건 건전하고 활발한 커뮤니티를 만드는 것입니다. 기본적으로 github에서 제공하는 이슈기능을 사용하면 되지만, 포럼이나 IRC, 메일링리스트를 사용하면 더 효과적으로 관리할 수 있습니다. Delibird는 아직 작은 프로젝트이기 때문에 기본적인 이슈기능만 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;홍보&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스가 생명을 얻고 발전하려면 홍보가 필수 입니다. 아무리 유용한 프로젝트라고 해도 홍보가 없으면 사람들이 찾을수가 없습니다. 그래서 제가 지금 이렇게 블로그를 통해 홍보를 하고 있는거 아니겠습니까..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;오셔서 star한번씩 눌러주시고 관심갖어 주시면 감사하겠습니다. ㅠㅠ&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;내부적으로 사용하던 소스를 오픈하기위에 적절히 리팩토링을 하고 문서를 추가하여 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;에 공개하였습니다. Go에 관심있으신분이나 배송조회에 관심있으신분은 별 눌러주시고 참여해주세요. 열려있습니다!&lt;/p&gt;

&lt;p&gt;많은 사람들이 오픈소스에 참여하고 오픈소스 프로젝트를 하고 있습니다. 하지만, 어떻게 만드는지에 대해서는 정리된 글이 잘 없는 것 같아 포스트를 작성하였습니다.&lt;/p&gt;

&lt;p&gt;사실, 널리 사랑받는 프로젝트는 위에 나열한 겉치례(?)보다는 얼마나 유용하고 얼마나 잘 설계되어 얼마나 자아알 짜여졌는지가 중요합니다. 최신 트렌드를 아는것과 잘 개발하는 것이 정비례하지는 않지만 여러가지 최신 트렌드를 알면 지금보다 조금 더 나은 개발자가 되는데는 도움이 된다고 생각합니다.&lt;/p&gt;

&lt;p&gt;그리고 중요한점은 오픈소스는 생각보다 시간과 노력이 많이 필요한 작업이라는 점입니다. 지금 몇가지 공개 저장소를 관리하고 있는데 여간 손이 많이 가는게 아닙니다. 이슈가 올라오면 체크하고 확인하고 수정하고 버전업하고 npm이나 bower에 등록하고.. 겨우 star수 200개도 이정도인데 다른 프로젝트들은 상상도 못할 것 같습니다. 오픈소스 커미터분들에게 감사드립니다.&lt;/p&gt;

&lt;p&gt;배송조회 서비스를 만든 홈쇼핑처럼에서 지난번 고기덮밥에 이어 돈까스 메뉴도 추가되었으니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0900</pubDate>
        <link>https://subicura.com/2016/06/13/start-go-shipment-tracking-opensource.html</link>
        <guid isPermaLink="true">https://subicura.com/2016/06/13/start-go-shipment-tracking-opensource.html</guid>
        
        <category>BackEnd</category>
        
        <category>Go</category>
        
        <category>OpenSource</category>
        
        
        <category>Go</category>
        
      </item>
    
  </channel>
</rss>
