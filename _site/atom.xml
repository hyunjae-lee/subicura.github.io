<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>subicura</title>
 <link href="http://subicura.com/atom.xml" rel="self"/>
 <link href="http://subicura.com/"/>
 <updated>2017-01-20T03:20:49+09:00</updated>
 <id>http://subicura.com</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>초보를 위한 도커 안내서 - 설치부터 배포까지 2/3</title>
   <link href="http://subicura.com/2017/01/19/docker-guide-for-beginners-2.html"/>
   <updated>2017-01-19T00:00:00+09:00</updated>
   <id>http://subicura.com/2017/01/19/docker-guide-for-beginners-2</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;code class=&quot;highlighter-rouge&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지&lt;/code&gt; 2번째 글입니다. 이번엔 도커 설치부터 컨테이너를 실행하고 컨테이너를 둘러보는 방법에 대해 설명합니다. 도커에 대해 1도 모르는 분들을 위해 아주 가볍게 자주 쓰는 명령어만 다루었기 때문에 모든 명령어가 궁금하신 분은 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/&quot;&gt;여기&lt;/a&gt;를 참고해주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 1/3&lt;/a&gt; - 도커란 무엇인가?&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 2/3 ✓&lt;/strong&gt; - 도커 설치 및 컨테이너 실행하기&lt;/li&gt;
  &lt;li&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 3/3 (작성중) - 이미지 생성 및 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;도커 설치하기&lt;/h2&gt;

&lt;p&gt;도커는 리눅스 컨테이너 기술이므로 macOS나 windows에 설치할 경우 가상머신에 설치가 됩니다. 리눅스 컨테이너 말고 윈도우즈 컨테이너라는 것도 존재하지만 여기서는 다루지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;

&lt;p&gt;리눅스에 도커를 설치하는 방법은 자동 설치 스크립트를 이용하는 것이 가장 쉽습니다. 다음 명령어를 입력하면 root 권한을 요구하고 잠시 기다리면 설치가 완료됩니다. 음.. 참 쉽죠?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl -s https://get.docker.com/ | sudo sh&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-install-on-linux.json&quot; poster=&quot;data:text/plain,$ # Docker Install (ubuntu)&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;Docker Install (ubuntu)&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;sudo 없이 사용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;docker는 기본적으로 root권한이 필요합니다. root가 아닌 사용자가 sudo없이 사용하려면 해당 사용자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;그룹에 추가합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;sudo usermod -aG docker &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 현재 접속중인 사용자에게 권한주기&lt;/span&gt;
sudo usermod -aG docker your-user &lt;span class=&quot;c&quot;&gt;# your-user 사용자에게 권한주기&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;사용자가 로그인 중이라면 다시 로그인 후 권한이 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의사항&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도커를 실행하기 위한 kernel 버전은 3.10.x 이상입니다. ubuntu 14.04 이상을 사용하면 큰 문제가 없고 kernel의 버전이 낮을 경우 제대로 동작을 안하거나 문제가 생길 수 있습니다. 가급적 최신버전으로 업데이트 해주세요.&lt;/li&gt;
  &lt;li&gt;ubuntu나 centos가 아닌 경우는 다른 방법이 필요합니다. 다른 리눅스를 쓰시는 분은 대부분 고오오급 개발자 분이시니 따로 설명하지 않아도 될 것 같아 &lt;a href=&quot;https://docs.docker.com/engine/installation/&quot;&gt;링크&lt;/a&gt;로 대신하겠습니다. &lt;del&gt;절대 귀찮아서가 아님&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-for-mac--docker-for-windows&quot;&gt;Docker for Mac / Docker for Windows&lt;/h3&gt;

&lt;p&gt;도커를 맥이나 윈도우즈에 설치하려면 &lt;a href=&quot;https://docs.docker.com/docker-for-mac&quot;&gt;Docker for mac&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.docker.com/docker-for-windows&quot;&gt;Docker for windows&lt;/a&gt;를 설치하면 됩니다. 파일을 다운받고 설치하고 재부팅하면 대부분 문제없이 완료됩니다. 소소한 옵션들이 있는데 특별히 건드릴 부분은 없으나 한번 살펴보고 적절하게 설정하시면 됩니다. (windows는 공유 드라이브를 선택해주세요)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-for-mac.png&quot; alt=&quot;Docker for Mac&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마치 네이티브스럽게 설치된 것 같지만 도커는 리눅스 컨테이너이므로 실제로는 가상머신에 설치가 되었습니다. 사용자는 가상머신을 사용한다는 느낌이 전혀 안드는데 그런부분을 굉장히 신경써서 설계하였습니다. 예를 들면, 포트를 연결하기 위해 도커 컨테이너의 특정 포트를 가상머신에 연결하고 다시 mac이나 windows의 포트와 연결해야 합니다. 디렉토리를 연결한다면 디렉토리를 가상머신과 공유하고 그 디렉토리를 다시 컨테이너와 연결해야 합니다. 이런 한단계 추가적으로 거쳐야하는 부분을 자연스럽게 처리해줍니다.&lt;/p&gt;

&lt;p&gt;docker for mac은 &lt;a href=&quot;https://github.com/mist64/xhyve&quot;&gt;xhyve&lt;/a&gt;라는 macOS에서 제공하는 가상환경을 이용하고 docker for windows는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-V&quot;&gt;Hyper-V&lt;/a&gt;기능을 이용합니다. 따라서 OS가 최신버전이 아니면 동작하지 않을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;가상머신에 설치하기&lt;/h3&gt;

&lt;p&gt;이런저런 이유로 Docker for … 를 사용하지 못하는 경우 &lt;a href=&quot;https://docs.docker.com/machine/&quot;&gt;Docker machine&lt;/a&gt;을 이용할 수 있는데 처음 도커를 공부하는 경우에는 Virtual Box나 VMware같은 가상머신에 리눅스를 설치하고 리눅스에 접속하여 도커를 사용하는 방법을 권장합니다. 처음부터 Docker machine을 사용하면 환경이 약간 혼란스러울 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;설치확인하기&lt;/h3&gt;

&lt;p&gt;설치가 완료되었다면 정상적으로 설치되었는지 도커 명령어를 입력해 확인해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker version&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Client:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      darwin/amd64

Server:
 Version:      1.12.6
 API version:  1.24
 Go version:   go1.6.4
 Git commit:   78d1802
 Built:        Wed Jan 11 00:23:16 2017
 OS/Arch:      linux/amd64&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Client와 Server 정보가 정상적으로 출력되었다면 설치가 완료된 것 입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Server 정보가 안나오고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error response from daemon: Bad response from Docker engine&lt;/code&gt;이라는 메시지가 출력되는 경우는 보통 docker daemon이 정상적으로 실행되지 않았거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;를 입력하지 않은 경우입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;혹시, 특이한 부분을 찾으셨나요? 버전정보가 클라이언트와 서버로 나뉘어져 있습니다. 도커는 하나의 실행파일이지만 실제로 클라이언트와 서버역할을 각각 할 수 있습니다. 도커 커맨드를 입력하면 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력해 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-host.png&quot; alt=&quot;docker client-host&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본값이 도커 서버의 소켓을 바라보고 있기 때문에 사용자는 의식하지 않고 마치 바로 명령을 내리는 것 같은 느낌을 받습니다. 이러한 설계가 mac이나 windows의 터미널에서 명령어를 입력했을때 가상 서버에 설치된 도커가 동작하는 이유입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;컨테이너 실행하기&lt;/h2&gt;
&lt;p&gt;이제! 드디어! 컨테이너를 실행해 보려고 합니다. 손이 근질근질하고 컨테이너의 강려크함을 보여드리고 싶기 때문에 여러개의 프로그램을 마구잡이로 손쉽게 띄워보겠습니다.&lt;/p&gt;

&lt;p&gt;도커를 실행하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;다음은 자주 사용하는 옵션들입니다.&lt;/p&gt;

&lt;table class=&quot;table table-key-value-60&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;옵션&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;detached mode 흔히 말하는 백그라운드 모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 포트를 연결 (포워딩)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;호스트와 컨테이너의 디렉토리를 연결 (마운트)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;컨테이너 내에서 사용할 환경변수 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–name&lt;/td&gt;
      &lt;td&gt;컨테이너 이름 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–rm&lt;/td&gt;
      &lt;td&gt;프로세스 종료시 컨테이너 자동 제거&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-it&lt;/td&gt;
      &lt;td&gt;-i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–link&lt;/td&gt;
      &lt;td&gt;컨테이너 연결 [컨테이너명:별칭]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;엄청나게 직관적인 옵션으로 몇번 실행해보면 자연스럽게 익숙해집니다.&lt;/p&gt;

&lt;h3 id=&quot;ubuntu-1604-container&quot;&gt;ubuntu 16.04 container&lt;/h3&gt;

&lt;p&gt;시작은 가볍게 ubuntu 16.04 컨테이너를 생성하고 컨테이너 내부에 들어가 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run ubuntu:16.04&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu.json&quot; poster=&quot;data:text/plain,$ # run ubuntu 16.04 container&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 사용하면 사용할 이미지가 저장되어 있는지 확인하고 없다면 다운로드(&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;)를 한 후 컨테이너를 생성(&lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt;)하고 시작(&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;) 합니다.&lt;/p&gt;

&lt;p&gt;위 예제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 이미지를 다운받은 적이 없기 때문에 이미지를 다운로드 한 후 컨테이너가 실행되었습니다. 컨테이너는 정상적으로 실행됐지만 뭘 하라고 명령어를 전달하지 않았기 때문에 컨테이너는 생성되자마자 종료됩니다. 컨테이너는 프로세스이기 때문에 실행중인 프로세스가 없으면 컨테이너는 종료됩니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt; 명령어를 입력해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:16.04&lt;/code&gt; 컨테이너를 실행해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run --rm -it ubuntu:16.04 /bin/bash

&lt;span class=&quot;c&quot;&gt;# in container&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat /etc/issue
Ubuntu 16.04.1 LTS &lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\l&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-ubuntu-bash.json&quot; poster=&quot;data:text/plain,$ # run ubuntu 16.04 container with /bin/bash&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run ubuntu 16.04 container with /bin/bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너 내부에 들어가기 위해 bash 쉘을 실행하고 키보드 입력을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 줍니다. 추가적으로 프로세스가 종료되면 컨테이너가 자동으로 삭제되도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt; 옵션도 추가하였습니다.&lt;/p&gt;

&lt;p&gt;이번에는 바로 전에 이미지를 다운 받았기 때문에 이미지를 다운로드 하는 화면 없이 바로 실행되었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;cat /etc/issue&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;를 실행해보면 ubuntu 리눅스인걸 알 수 있습니다. 뭔가 가벼운 가상머신 같나요?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;로 bash 쉘을 종료하면 컨테이너도 같이 종료됩니다.&lt;/p&gt;

&lt;p&gt;도커를 이용하여 가장 기본적인 컨테이너를 순식간에 만들어 보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;redis-container&quot;&gt;redis container&lt;/h3&gt;

&lt;p&gt;2번째 컨테이너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt; 입니다. &lt;a href=&quot;https://redis.io/&quot;&gt;redis&lt;/a&gt;는 메모리기반의 다양한 기능을 가진 스토리지입니다. 6379 포트로 통신하며 telnet 명령어로 테스트해 볼 수 있습니다. redis 컨테이너는 detached mode(백그라운드 모드)로 실행하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 추가하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 추가하여 컨테이너의 포트를 호스트의 포트로 연결해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt;옵션이 없다면 프로세스가 foreground로 실행되어 아무키도 입력할 수 없게 됩니다. 컨테이너를 종료하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + c&lt;/code&gt;를 입력해 주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 1234:6379 redis

&lt;span class=&quot;c&quot;&gt;# redis test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;telnet localhost 1234
&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;mykey hello
+OK
get mykey
&lt;span class=&quot;nv&quot;&gt;$5&lt;/span&gt;
hello&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-redis.json&quot; poster=&quot;data:text/plain,$ # run redis container&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run redis container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 주었기 때문에 컨테이너를 실행하자마자 컨테이너의 ID(5dff91d2…)를 보여주고 바로 쉘로 돌아왔습니다. 컨테이너는 종료된 것이 아니라 백그라운드 모드로 동작하고 있고 컨테이너 ID를 이용하여 컨테이너를 제어할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 옵션을 이용하여 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;1234포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;6379포트&lt;/code&gt;로 연결하였고 localhost의 1234포트로 접속하면 하면 redis를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;테스트 결과 redis에 접속하여 새로운 키를 저장하고 불러오는데 성공했습니다. 실행이 간단한건 물론이고 호스트의 포트만 다르게 하면 하나의 서버에 여러개의 redis 서버를 띄우는 것도 매우 간단합니다.&lt;/p&gt;

&lt;h3 id=&quot;mysql-57-container&quot;&gt;MySQL 5.7 container&lt;/h3&gt;

&lt;p&gt;3번째 실행할 컨테이너는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL 서버&lt;/code&gt;입니다. 가장 흔하게 사용하는 데이터베이스인데 이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 옵션을 이용하여 환경변수를 설정하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt; 옵션을 이용하여 컨테이너에 읽기 어려운 ID 대신 쉬운 이름을 부여할 예정입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt;옵션을 생략하면 도커가 자동으로 이름을 지어 줍니다. 이름은 유명한 과학자나 해커의 이름과 수식어를 조합하여 랜덤으로 &lt;a href=&quot;https://github.com/docker/docker/blob/master/pkg/namesgenerator/names-generator.go&quot;&gt;생성&lt;/a&gt;합니다. (ex - boring_wozniak) 우리나라 과학자 &lt;a href=&quot;https://github.com/docker/docker/issues/8996&quot;&gt;장영실&lt;/a&gt;도 등록되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/mysql/&quot;&gt;MySQL Docker hub&lt;/a&gt; 페이지에 접속하면 간단한 사용법과 환경변수에 대한 설명이 있습니다. 여러가지 설정값이 있는데 패스워드 없이 root계정을 만들기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/code&gt; 환경변수를 설정합니다. 그리고 컨테이너의 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;로 할당하고 백그라운드 모드로 띄우기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 옵션을 줍니다. 포트는 &lt;code class=&quot;highlighter-rouge&quot;&gt;3306포트&lt;/code&gt;를 호스트에서 그대로 사용하겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -h127.0.0.1 -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-mysql.json&quot; poster=&quot;data:text/plain,$ # run mysql 5.7 container&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run mysql 5.7 container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 순식간에 MySQL서버가 실행되었습니다. 이번 테스트는 호스트 OS에 MySQL 클라이언트가 설치되어 있어야 합니다. 추후에 실행중인 MySQL 도커 컨테이너에 접속하여 클라이언트를 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;처음 접속 시도시 에러가 난 화면은 MySQL 서버가 최초로 실행되면서 준비작업을 하기 때문에 발생하는 에러입니다. 컨테이너를 실행하면 백그라운드에서 MySQL 서버를 띄우는 시간이 필요하기 때문에 잠시 후에 다시 시도 했을 때 정상적으로 접속된 걸 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;wordpress-container&quot;&gt;WordPress container&lt;/h3&gt;

&lt;p&gt;이번에는 블로그&lt;del&gt;보다 웹용으로 더 흔히 쓰이는&lt;/del&gt;엔진으로 유명한 &lt;a href=&quot;https://wordpress.com&quot;&gt;워드프레스&lt;/a&gt;를 실행합니다. 워드프레스는 데이터베이스가 필요하기 때문에 조금 복잡한 형태를 띄지만 크게 어렵지 않습니다. 바로 전에 생성했던 MySQL 컨테이너에 워드프레스 데이터베이스를 만들고 WordPress 컨테이너를 실행할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션을 이용하여 MySQL 컨테이너를 연결하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 환경변수와 IP정보를 공유하는데 링크한 컨테이너의 IP정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;에 자동으로 입력하므로 워드프레스 컨테이너가 MySQL 데이터베이스의 정보를 알 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;먼저, 워드프레스용 데이터베이스를 생성하고 워드프레스 컨테이너를 실행합니다. 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;8080포트&lt;/code&gt;를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;80포트&lt;/code&gt;로 연결하고 MySQL 컨테이너와 연결한 후 각종 데이터베이스 설정 정보를 환경변수로 입력합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# create mysql database&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -h127.0.0.1 -uroot
create database wp CHARACTER SET utf8;
grant all privileges on wp.&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; to wp@&lt;span class=&quot;s1&quot;&gt;'%'&lt;/span&gt; identified by &lt;span class=&quot;s1&quot;&gt;'wp'&lt;/span&gt;;
flush privileges;
quit

&lt;span class=&quot;c&quot;&gt;# run wordpress container&lt;/span&gt;
docker run -d -p 8080:80 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --link mysql:mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_NAME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;WORDPRESS_DB_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;wp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  wordpress&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-run-wp.json&quot; poster=&quot;data:text/plain,$ # run wordpress container&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;run wordpress container&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;컨테이너가 제대로 실행되었는지 웹 브라우저로 확인해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/wp.png&quot; alt=&quot;wordpress setup&quot; /&gt;&lt;/p&gt;

&lt;p&gt;워드프레스가 실행되었습니다! 단지 이미지를 다운받고 적절한 환경변수를 입력하여 컨테이너를 실행했을 뿐입니다. 워드프레스 컨테이너 내부는 apache2와 php가 설치되어 있지만 추상화되어 있어 실행과정에선 드러나지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 예제는 테스트용으로만 사용해야 합니다. 운영 환경에서 사용하려면 추가적인 셋팅이 필요합니다. 이부분은 밑에서 다시 다룹니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 옵션은 deprecated 되어 곧 사용할 수 없습니다. 대신 Docker network 기능을 이용해야 하지만 쉬운 이해를 돕기 위해 사용하였습니다. &lt;del&gt;참고만 하고 실제 사용은 ㄴㄴ&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제, 원하는 서비스가 있다면 이미지를 찾거나 직접 만들고, 어디서나 손쉽게 서비스를 실행할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;tensorflow&quot;&gt;tensorflow&lt;/h3&gt;

&lt;p&gt;마지막으로 이렇게 활용할 수 있다라는 예제로 tensorflow를 실행보도록 하겠습니다. &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;tensorflow&lt;/a&gt;는 손쉽게 머신러닝을 할 수 있는 툴입니다. tensorflow는 python으로 만들어져 python과 관련 패키지를 설치해야 합니다. 이번에 설치하는 이미지는 python과 함께 numpy, scipy, pandas, jupyter, scikit-learn, gensim, BeautifulSoup4, Tensorflow가 설치되어 있습니다. 뭔가 복잡해 보이지만 도커라면 손쉽게 실행해 볼 수 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker run -d -p 8888:8888 -p 6006:6006 teamlab/pydata-tensorflow:0.1&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;설치된 파일이 많아 다운로드 하는데 시간이 좀 걸립니다. 컨테이너가 실행되면 웹 브라우저에서 jupyter에 접속하여 머신러닝을 시작해 봅시다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/tensorflow.png&quot; alt=&quot;Hello, Tensorflow!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;와우! 성공적으로 tensorflow 테스트를 마쳤습니다. 이제 조금 있으면 A.I를 만들 수 있을 것 같습니다.(?!)&lt;/p&gt;

&lt;p&gt;여기까지 ubuntu, MySQL, redis, Wordpress, tensorflow를 실행해 보았습니다. 가상머신을 이용해서 동일한 작업을 했다면 컴퓨터가 엄청나게 버벅이기 시작했겠지만 컨테이너 기반의 도커를 이용하여 매우 가볍게 실행하고 있습니다. 내부 구조나 설치과정은 자세히 모르지만, 간단한 도커 명령어로 여러개의 서비스를 순식간에 실행하고 사용할 수 있다니 정말 짱짱맨입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;도커 기본 명령어&lt;/h2&gt;

&lt;p&gt;앞에서 도커의 &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어를 이용하여 여러개의 컨테이너를 실행했습니다. 이제 컨테이너의 상태를 살펴보고 어떤 이미지가 설치되어 있는지 확인하는 명령어를 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;ps&quot;&gt;컨테이너 목록 확인하기 (ps)&lt;/h3&gt;

&lt;p&gt;컨테이너 목록을 확인하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker ps [OPTIONS]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;일단 기본옵션과 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a, --all&lt;/code&gt; 옵션만 살펴봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED              STATUS              PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             About a minute ago   Up About a minute   0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   8 minutes ago        Up 8 minutes        0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   9 minutes ago        Up 9 minutes        0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   16 minutes ago       Up 9 minutes        0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt; 명령어는 실행중인 컨테이너 목록을 보여줍니다. detached mode로 실행중인 컨테이너들이 보입니다. 어떤 이미지를 기반으로 만들었는지 어떤 포트와 연결이 되어있는지 등 간단한 내용을 보여줍니다.&lt;/p&gt;

&lt;p&gt;이번에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; 옵션을 추가로 실행해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps -a&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS                      PORTS                                                    NAMES
6a1d027b604f        teamlab/pydata-tensorflow:0.1   &quot;/opt/start&quot;             2 minutes ago       Up 2 minutes                0.0.0.0:6006-&amp;gt;6006/tcp, 22/tcp, 0.0.0.0:8888-&amp;gt;8888/tcp   desperate_keller
52a516f87ceb        wordpress                       &quot;docker-entrypoint.sh&quot;   9 minutes ago       Up 9 minutes                0.0.0.0:8080-&amp;gt;80/tcp                                     happy_curran
2e2c569115b9        mysql:5.7                       &quot;docker-entrypoint.sh&quot;   10 minutes ago      Up 10 minutes               0.0.0.0:3306-&amp;gt;3306/tcp                                   mysql
56341072b515        redis                           &quot;docker-entrypoint.sh&quot;   18 minutes ago      Up 10 minutes               0.0.0.0:1234-&amp;gt;6379/tcp                                   furious_tesla
e1a00c5934a7        ubuntu:16.04                    &quot;/bin/bash&quot;              32 minutes ago      Exited (0) 32 minutes ago                                                            berserk_visvesvaraya&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;맨 처음 실행했다가 종료된 컨테이너(Exited (0))가 추가로 보입니다. 컨테이너는 종료되어도 삭제되지 않고 남아있습니다. 종료된 건 다시 시작할 수 있고 컨테이너의 읽기/쓰기 레이어는 그대로 존재합니다. 명시적으로 삭제를 하면 깔끔하게 컨테이너가 제거됩니다.&lt;/p&gt;

&lt;h3 id=&quot;stop&quot;&gt;컨테이너 중지하기 (stop)&lt;/h3&gt;

&lt;p&gt;실행중인 컨테이너를 중지하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker stop [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;옵션은 특별한게 없고 실행중인 컨테이너를 하나 또는 여러개 (띄어쓰기로 구분) 중지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;앞에서 실행한 tensorflow 컨테이너는 더이상 필요가 없으니 중지해 보겠습니다. 중지하려면 컨테이너의 ID 또는 이름을 입력하면 됩니다. tensorflow 컨테이너의 ID를 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;명령을 통해 확인하고 중지해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker stop &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps -a &lt;span class=&quot;c&quot;&gt;# show all containers&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커 ID의 전체 길이는 64자리 입니다. 하지만 명령어의 인자로 전달할 때는 전부 입력하지 않아도 됩니다. 예를 들어 ID가 &lt;code class=&quot;highlighter-rouge&quot;&gt;abcdefgh...&lt;/code&gt;라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;abcd&lt;/code&gt;만 입력해도 됩니다. 앞부분이 겹치지 않는다면 1-2자만 입력해도 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;잠시 기다리면 tensorflow 컨테이너가 종료됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ps -a&lt;/code&gt;명령어를 입력하여 종료되었는지 확인합니다.&lt;/p&gt;

&lt;h3 id=&quot;rm&quot;&gt;컨테이너 제거하기 (rm)&lt;/h3&gt;

&lt;p&gt;종료된 컨테이너를 완전히 제거하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rm [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;종료 명령어도 옵션은 특별한게 없습니다. 종료된 컨테이너를 하나 또는 여러개 삭제할 수 있습니다. 종료된 ubuntu 컨테이너와 tensorflow 컨테이너를 삭제해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps -a &lt;span class=&quot;c&quot;&gt;# get container ID&lt;/span&gt;
docker rm &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;UBUNTU_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
docker ps -a &lt;span class=&quot;c&quot;&gt;# check exist&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너가 말끔히 삭제되었습니다. 호스트 OS는 아무런 흔적도 남아있지 않고 컨테이너만 격리된 상태로 실행되었다가 삭제되었습니다. 시스템이 꼬일 걱정이 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;중지된 컨테이너를 일일이 삭제 하는 건 귀찮은 일입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;docker rm -v $(docker ps -a -q -f status=exited)&lt;/code&gt; 명령어를 입력하면 중지된 컨테이너 ID를 가져와서 한번에 삭제합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;images&quot;&gt;이미지 목록 확인하기 (images)&lt;/h3&gt;

&lt;p&gt;도커가 다운로드한 이미지 목록을 보는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker images [OPTIONS] [REPOSITORY[:TAG]]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;간단하게 도커 이미지 목록을 확인해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
wordpress                   latest              b1fe82b15de9        43 hours ago        400.2 MB
redis                       latest              45c3ea2cecac        44 hours ago        182.9 MB
mysql                       5.7                 f3694c67abdb        46 hours ago        400.1 MB
ubuntu                      16.04               104bec311bcd        4 weeks ago         129 MB
teamlab/pydata-tensorflow   0.1                 7bdf5d7e0191        6 months ago        3.081 GB&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지 주소와 태그, ID, 생성시점, 용량이 보입니다. 이미지가 너무 많이 쌓이면 용량을 차지하기 때문에 사용하지 않는 이미지는 지우는 것이 좋습니다.&lt;/p&gt;

&lt;h3 id=&quot;pull&quot;&gt;이미지 다운로드하기 (pull)&lt;/h3&gt;

&lt;p&gt;이미지를 다운로드하는 명령어는 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker pull [OPTIONS] NAME[:TAG|@DIGEST]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:14.04&lt;/code&gt;를 다운받아보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker pull ubuntu:14.04&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어를 입력하면 이미지가 없을 때 자동으로 다운받으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 언제 쓰는지 궁금할 수 있는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;은 최신버전으로 다시 다운 받습니다. 같은 태그지만 이미지가 업데이트 된 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;명령어를 통해 새로 다운받을 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;rmi&quot;&gt;이미지 삭제하기 (rmi)&lt;/h3&gt;

&lt;p&gt;이미지를 삭제하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker rmi [OPTIONS] IMAGE [IMAGE...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;images&lt;/code&gt;명령어를 통해 얻은 이미지 목록에서 이미지 ID를 입력하면 삭제가 됩니다. 단, 컨테이너가 실행중인 이미지는 삭제되지 않습니다. 컨테이너는 이미지들의 레이어를 기반으로 실행중이므로 당연히 삭제할 수 없습니다.&lt;/p&gt;

&lt;p&gt;tensorflow는 더 이상 사용하지 않으니 이미지를 제거해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker images &lt;span class=&quot;c&quot;&gt;# get image ID&lt;/span&gt;
docker rmi &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TENSORFLOW_IMAGE_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;Untagged: teamlab/pydata-tensorflow:0.1
Untagged: teamlab/pydata-tensorflow@sha256:cb5e036afc0aa647a6fe1f384475275aeed946c751de5209d84282c986589b7f
Deleted: sha256:7bdf5d7e0191a6133a385ac69ec6a07be46b08cf5b5e6b826a89b9b47aadabe5
Deleted: sha256:9d72165f240630813a39e2f802a75f45caa2bc230881fa73c2f620c4b04686b5
Deleted: sha256:5c90ba76fff96b155b8a9446f2fb42d2ae04566832f3929df41dc52c0ae462ae
Deleted: sha256:1e23db6b02673d34c54fe87ec958ae8f2e310ca4aa911c7f8488b6c7988bfba0
Deleted: sha256:759641367a6788b55361f9eeedcbc356f8e464ef794a883b5621fba6e23c6b18
Deleted: sha256:b5d017cd48c0d8461230b5ab0aed68e27a4018996344470db3c4b5adba10b49f
Deleted: sha256:470cdb158a12a416ffebde8d299fdbde28d56da062c701bf7a51d6484f777e97
Deleted: sha256:d136c3aea28597fadb667a084a6e5701e287fd36f03cc9555b0e5bca2e674f9b
Deleted: sha256:e62e6cce767baec3711dc1ec8cfcd76f68b88a6ca9ffcd2f3d22345048a0f8d7
Deleted: sha256:8e0761516c1c1ad792c9e67d1541d574905f067cb3b67e19a3af58ca7389eee9
Deleted: sha256:ad45f6539a6ce95216c9990d26b4b2e44c0b50637c1f0949b6965610b023fd97
Deleted: sha256:ebe200261801abef54e60699c098def3a4bd39a7b4833f164b99e23a88e8a98a
Deleted: sha256:698c310f0ec8a1f607a59f15a6affa7d9d21e21d9eaf6eb65b6ab6f33fcb62b4
Deleted: sha256:e5da0b4fd6d0143d7953e47a244a9be16919d1f4018e128e82fba6df967e790e
Deleted: sha256:7d8ffbfe2c1a55581e08b81f34506a746022e5beeb85f5848154b0b7d41208cf
Deleted: sha256:854cd556e616f5e5b21cd69f1e7c0d225c9b28eb5cf653aa4aa0937930298d72
Deleted: sha256:10e6f47febf1912a4d7a08b7652e360905a6ba8b76f188fd167c8d6afa09951a
Deleted: sha256:737ee41ad49072c9ba8301a17751e16d69c1045df74ac77f4ae05f849b08faec
Deleted: sha256:62b01cf4b1440085b0b9311372eb8acb509581faf655b2837a2e234c12fdfd24
Deleted: sha256:7dcdbe5fc9a2290d596e3bab8052c3141a69a451a29a98bd12678a7139891094
Deleted: sha256:8a9f069492b445dc889f9639572dc289f7c3fc1ac4d597a7468614fa2c624091
Deleted: sha256:34a63dcc0c5574597918a8e9df80e364f9fec88c0f4e25a0e5187acd241773ad
Deleted: sha256:af6fa43db2e379d3f0f3f36d61a0ece782133314c678d7223872eb7158f102ba
Deleted: sha256:efbafc7aa3a87241c10bf0c495672cf4a7b0cc2d23db06120ae1e13528316f82
Deleted: sha256:ea0c616be3659f71afce45eff2e28e51e04b25f1ae58b306521e6877f3adf2df
Deleted: sha256:f2dccb8902ea3d85aa9a954af894f59100fc00fa78c09b213c76dcf2727e3c3e
Deleted: sha256:3fe0adbd3614d696ded87bcb47aed81f49b113770a3778e276cd88abe9010b9f
Deleted: sha256:b88d260c0bcff3b4434a39ba33f58a2f9807400d664185057edd393133630242
Deleted: sha256:4de08f41d77237b2dbc0660036fe8352fdbacf6e079623d318003ed7e833a40a
Deleted: sha256:f32c8f02713c719181c2bf32be13dbd333932411d5fc3e0b6cfb780da8bb8124
Deleted: sha256:985d69571ed5d6d7e69bf58232fd8f30f8cd4ac77f41122a80fdab56347ec22d
Deleted: sha256:8509bc9969877f784fa6e704098cbcf77d694596644f389c5a2fefe5267878ab
Deleted: sha256:0ad5b9ed74fe2eee856b368d426cdd9335a6a6ecec0c4c705b5153c219a82692
Deleted: sha256:b159c847c5b9b899c23eba59395a4d7b7b275a8c686191ed6c4ef21ceadad8a2
Deleted: sha256:89e9f76552fd1a8d249c1e133e4c8964fe1f9104bb708db1e0ca6f6171ee4c22
Deleted: sha256:6d31e1827ca8f5037077314b2403eabd82590f9eae8baf956a2c2a819db68d4e
Deleted: sha256:7f4734de8e3dd402f10030f06bcb8781129b1eb6a25c58811a76d015f2a0982f&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;이미지가 삭제되었습니다. 이미지는 여러개의 레이어로 구성되어 있기 때문에 모든 레이어가 삭제된 것을 알 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;컨테이너 둘러보기&lt;/h2&gt;

&lt;p&gt;도커에 대한 아주아주아주 기본적인 명령어를 살펴보았습니다. 사실 저 명령어들과 이번에 살펴볼 &lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; 명령어를 익히면 도커에서 사용하는 명령어는 거의 다 익혔다고 할 수 있습니다. 다른 명령어는 필요에 따라 하나하나 살펴보면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;logs&quot;&gt;컨테이너 로그 보기 (logs)&lt;/h3&gt;

&lt;p&gt;컨테이너가 정상적으로 동작하는지 확인하는 좋은 방법은 로그를 확인하는 것 입니다. 로그를 확인하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker logs [OPTIONS] CONTAINER&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;기본 옵션과, &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--tail&lt;/code&gt; 옵션을 살펴봅니다.&lt;/p&gt;

&lt;p&gt;기존에 생성해 놓은 워드프레스 컨테이너 로그를 확인해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker ps
docker logs &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;WordPress not found in /var/www/html - copying now...
Complete! WordPress has been successfully copied to /var/www/html
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.4. Set the 'ServerName' directive globally to suppress this message
[Thu Jan 19 16:10:16.507735 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.29 configured -- resuming normal operations
[Thu Jan 19 16:10:16.507776 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET / HTTP/1.1&quot; 302 379 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:11:54 +0000] &quot;GET /wp-admin/install.php HTTP/1.1&quot; 200 2513 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/buttons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 1698 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/zxcvbn-async.min.js?ver=1.0 HTTP/1.1&quot; 200 582 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/css/install.min.css?ver=4.7.1 HTTP/1.1&quot; 200 2329 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery-migrate.min.js?ver=1.4.1 HTTP/1.1&quot; 200 4366 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/jquery/jquery.js?ver=1.12.4 HTTP/1.1&quot; 200 34120 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/password-strength-meter.min.js?ver=4.7.1 HTTP/1.1&quot; 200 825 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너에서 실행한 로그가 쭈욱 보입니다. 아무 옵션을 주지 않았을 때는 전체 로그를 &lt;del&gt;무식하게&lt;/del&gt; 전부 다 출력합니다. 너무 많으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;--tail&lt;/code&gt;옵션으로 마지막 10줄만 출력해 보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs --tail 10 &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/wp-util.min.js?ver=4.7.1 HTTP/1.1&quot; 200 924 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/js/user-profile.min.js?ver=4.7.1 HTTP/1.1&quot; 200 2590 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/js/underscore.min.js?ver=1.8.3 HTTP/1.1&quot; 200 6173 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-includes/css/dashicons.min.css?ver=4.7.1 HTTP/1.1&quot; 200 28951 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:01 +0000] &quot;GET /wp-admin/images/wordpress-logo.svg?ver=20131107 HTTP/1.1&quot; 200 1810 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /wp-includes/js/zxcvbn.min.js HTTP/1.1&quot; 200 330747 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
172.17.0.1 - - [19/Jan/2017:16:12:02 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 200 229 &quot;http://localhost:8080/wp-admin/install.php&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/602.3.12 (KHTML, like Gecko) Version/10.0.2 Safari/602.3.12&quot;
::1 - - [19/Jan/2017:16:12:08 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:09 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;
::1 - - [19/Jan/2017:16:12:10 +0000] &quot;OPTIONS * HTTP/1.0&quot; 200 126 &quot;-&quot; &quot;Apache/2.4.10 (Debian) PHP/5.6.29 (internal dummy connection)&quot;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;마지막 10줄만 보니 좀 나아 보입니다. 이제 실시간으로 로그가 생성되는 걸 확인해보겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 옵션으로 실행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker logs -f &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;WORDPRESS_CONTAINER_ID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-log-f.json&quot; poster=&quot;data:text/plain,$ # docker logs -f&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker logs -f&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;로그를 켜 놓은 상태에서 워드프레스 페이지를 새로고침하면 브라우저 접속 로그가 실시간으로 보입니다. 가장 흔하게 사용하는 옵션이고 로그 보기를 중지하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;를 입력하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로그에 대해 좀 더 자세히&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;프로그램마다 로그 파일은 제각각 생길텐데 어떻게 저 로그가 나올까 라는 의문이 생깁니다. 도커는 로그파일을 자동으로 알아채는게 아니라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams&quot;&gt;표준 스트림&lt;/a&gt;&lt;sub&gt;Standard streams&lt;/sub&gt; 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;를 수집합니다. 따라서 컨테이너에서 실행되는 프로그램의 로그 설정을 파일이 아닌 표준출력으로 바꾸어야 합니다. 단지 출력 방식만 바꾸는 것으로 모든 컨테이너는 로그에 대해 같은 방식으로 관리할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;또하나 중요한 점은 컨테이너의 로그파일은 json 방식으로 어딘가에 저장이 됩니다. 로그가 많으면 은근히 파일이 차지하는 용량이 커지므로 주의해야합니다. 도커는 다양한 플러그인을 지원하여 json이 아닌 특정 로그 서비스에 스트림을 전달할 수 있습니다. 어느 정도 앱의 규모가 커지면 기본적인 방식 대신 로그 서비스를 이용하는 걸 고려해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;exec&quot;&gt;컨테이너 명령어 실행하기 (exec)&lt;/h3&gt;

&lt;p&gt;컨테이너를 관리하다 보면 실행중인 컨테이너에 들어가보거나 컨테이너의 파일을 실행하고 싶을 때가 있습니다. 컨테이너에 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt;를 설치하면 되지 않을까? 라고 생각할 수 있지만 SSH는 권장하지 않습니다. &lt;del&gt;하지 말라고 하면 꼭 하는 분들이 있던데 제발..&lt;/del&gt; 예전에는 &lt;a href=&quot;https://github.com/jpetazzo/nsenter&quot;&gt;nsenter&lt;/a&gt;라는 프로그램을 이용하였는데 docker에 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;라는 명령어로 흡수되었습니다.&lt;/p&gt;

&lt;p&gt;컨테이너 명령어를 실행하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight usage&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-txt&quot; data-lang=&quot;txt&quot;&gt;docker exec [OPTIONS] CONTAINER COMMAND [ARG...]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt; 명령어와 유사해 보입니다. 차이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;은 새로 컨테이너를 만들어서 실행하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt;는 실행중인 컨테이너에 명령어를 내리는 정도입니다.&lt;/p&gt;

&lt;p&gt;일단, 가볍게 실행중인 &lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt; 컨테이너에 접속해보겠습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; -it mysql /bin/bash

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-bash.json&quot; poster=&quot;data:text/plain,$ # docker exec bash&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec bash&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;키보드 입력이 필요하니 run 명령어와 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션을 주었고 bash 쉘로 접속하여 마치 가상머신에 들어온 것 같은 느낌이 듭니다. 접속한 이후에는 어떤 작업도 할 수 있고 컨테이너를 마음껏 건드릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;쉘로 완전한 권한을 얻는 방법말고 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt;명령어를 실행 할 수도 있습니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker &lt;span class=&quot;nb&quot;&gt;exec&lt;/span&gt; -it mysql mysql -uroot

&lt;span class=&quot;c&quot;&gt;# MySQL test&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mysql -uroot

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wp                 |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;gp&quot;&gt;mysql&amp;gt; &lt;/span&gt;quit&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-exec-mysql.json&quot; poster=&quot;data:text/plain,$ # docker exec mysql&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker exec mysql&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;이제, 호스트 OS에 mysql을 설치하지 않아도 mysql 클라이언트를 사용할 수 있습니다. 굳이 복잡한 작업이 필요 없는 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt; 옵션없이 단순하게 명령을 실행하고 종료할 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;컨테이너 업데이트&lt;/h2&gt;

&lt;p&gt;이제 지금까지 배운 모든걸 정리해서 컨테이너를 새로운 버전으로 업데이트 하는 과정을 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/container-update.png&quot; alt=&quot;도커 컨테이너 업데이트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 컨테이너를 업데이트 하려면 새 버전의 이미지를 다운(&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;)받고 기존 컨테이너를 삭제(&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt;) 한 후 새 이미지를 기반으로 새 컨테이너를 실행(&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;)하면 됩니다. 배포와 관련된 자세한 사항은 다음글에서 이야기하고 여기선 그냥 그렇구나 하고 이해합시다.&lt;/p&gt;

&lt;p&gt;컨테이너를 삭제한다는 건 컨테이너에서 생성된 파일이 사라진다는 뜻입니다. 데이터베이스라면 그동안 쌓였던 데이터가 모두 사라진다는 것이고 웹 어플리케이션이라면 그동안 사용자가 업로드한 이미지가 모두 사라진다는 것입니다. ㄷㄷ&lt;/p&gt;

&lt;p&gt;이런 상황&lt;del&gt;도커 도입했다가 퇴사&lt;/del&gt;을 방지하기 위해 컨테이너 삭제시 유지해야하는 데이터는 반드시 컨테이너 내부가 아닌 외부 스토리지에 저장해야 합니다. 가장 좋은 방법은 &lt;a href=&quot;http://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html&quot;&gt;AWS S3&lt;/a&gt;같은 클라우드 서비스를 이용하는 것이고 그렇지 않으면 데이터 볼륨&lt;sub&gt;Data volumes&lt;/sub&gt;을 컨테이너에 추가해서 사용해야 합니다. 데이터 볼륨을 사용하면 해당 디렉토리는 컨테이너와 별도로 저장되고 컨테이너를 삭제해도 데이터가 지워지지 않습니다.&lt;/p&gt;

&lt;p&gt;데이터 볼륨을 사용하는 방법은 몇가지가 있는데 여기서는 호스트의 디렉토리를 마운트해서 사용하는 방법에 대해 알아봅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;명령어에서 소개한 옵션중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 옵션을 드디어 사용해 보겠습니다. MySQL이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리에 모든 데이터베이스 정보가 담기므로 호스트의 특정 디렉토리를 연결해주면 됩니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;# before&lt;/span&gt;
docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  mysql:5.7

&lt;span class=&quot;c&quot;&gt;# after&lt;/span&gt;
docker run -d -p 3306:3306 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -e &lt;span class=&quot;nv&quot;&gt;MYSQL_ALLOW_EMPTY_PASSWORD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  --name mysql &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  -v /my/own/datadir:/var/lib/mysql &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &amp;lt;- volume mount&lt;/span&gt;
  mysql:5.7&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;위 샘플은 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리를 컨테이너의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/mysql&lt;/code&gt;디렉토리로 마운트 하였습니다. 이제 데이터베이스 파일은 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/my/own/datadir&lt;/code&gt;디렉토리에 저장되고 컨테이너를 삭제해도 데이터는 사라지지 않습니다. 최신버전의 MySQL 이미지를 다운받고 다시 컨테이너를 실행할 때 동일한 디렉토리를 마운트 한다면 그대로 데이터를 사용할 수 있습니다. &lt;del&gt;만세!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-compose&quot;&gt;Docker Compose&lt;/h2&gt;

&lt;p&gt;지금까지 도커를 커맨드라인에서 명령어로 작업했습니다. 지금은 간단한 작업만 했기 때문에 명령이 길지 않지만 컨테이너 조합이 많아지고 여러가지 설정이 추가되면 명령어가 금방 복잡해집니다.&lt;/p&gt;

&lt;p&gt;도커는 복잡한 설정을 쉽게 관리하기 위해 &lt;a href=&quot;https://en.wikipedia.org/wiki/YAML&quot;&gt;YAML&lt;/a&gt;방식의 설정파일을 이용한 &lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;Docker Compose&lt;/a&gt;라는 툴을 제공합니다. 깊게 파고들면 은근 기능이 많고 복잡한데 이번에는 아주 가볍게 다루고 지나가도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;설치하기&lt;/h3&gt;

&lt;p&gt;Docker for Mac 또는 Docker for Windows를 설치했다면 자동으로 설치됩니다. 리눅스의 경우 다음 명령어를 입력하여 설치합니다. 그냥 설치파일 하나 다운받으면 됩니다. &lt;del&gt;Golang 짱&lt;/del&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;curl -L &lt;span class=&quot;s2&quot;&gt;&quot;https://github.com/docker/compose/releases/download/1.9.0/docker-compose-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;uname -s&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;uname -m&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
&lt;span class=&quot;c&quot;&gt;# test&lt;/span&gt;
docker-compose version&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;wordpress-&quot;&gt;wordpress 만들기&lt;/h3&gt;

&lt;p&gt;기존에 명령어로 만들었던 wordpress를 compose를 이용해 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 빈 디렉토리를 하나 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt;파일을 만들어 설정을 입력합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;version: &amp;#39;2&amp;#39;

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: wordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     volumes:
       - wp_data:/var/www/html
     ports:
       - &amp;quot;8000:80&amp;quot;
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_PASSWORD: wordpress
volumes:
    db_data:
    wp_data:&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/7c76c1a90e65606f5e5f55f83943eac2.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;몇몇 생소해보이는 설정이 눈에 보이지만, 일단 실행해 봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;docker-compose up&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;div class=&quot;asciinema-player-section&quot;&gt;&lt;asciinema-player src=&quot;http://subicura.com/assets/asciinema/2017-01-19-docker-guide-for-beginners-2/docker-compose.json&quot; poster=&quot;data:text/plain,$ # docker-compose&quot; speed=&quot;2&quot;&gt;&lt;/asciinema-player&gt;&lt;figcaption&gt;docker-compose&lt;/figcaption&gt;&lt;/div&gt;

&lt;p&gt;와우, 아주 손쉽게 워드프레스가 만들어 졌습니다. 단지 명령어를 설정파일로 바꾼거에 불과하지만 가독성과 편리성은 훨씬 향상되었습니다.&lt;/p&gt;

&lt;p&gt;Docker Compose의 다른 기능과 생소한 설정내용은 숙제로 남겨드립니다. 원래 개발공부라는게 왠만큼 했다고 생각하면 또 다른게 나오고 끊임없이 공부해야 하는 분야입니다. &lt;del&gt;화이팅!&lt;/del&gt; 도커에 대해 이해를 했다면 Docker Compose 또한 쉽게 사용할 수 있을 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;여기까지 도커에 대해 기본적인 내용부터 컨테이너를 실행하고 살펴보는 방법까지 알아보았습니다. 도커가 어떤건지, 컨테이너가 뭔지, 이미지가 뭔지 감이 좀 오시나요? 이제 남이 만든 이미지를 사용하는 것이 아니라 직접 이미지를 만들고 컨테이너를 여러 서버로 배포하는 방법을 알아봐야하는데… 다음글에서 알아보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-1.html&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 1/3&lt;/a&gt; - 도커란 무엇인가?&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 2/3 ✓&lt;/strong&gt; - 도커 설치 및 컨테이너 실행하기&lt;/li&gt;
  &lt;li&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 3/3 (작성중) - 이미지 생성 및 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>초보를 위한 도커 안내서 - 설치부터 배포까지 1/3</title>
   <link href="http://subicura.com/2017/01/19/docker-guide-for-beginners-1.html"/>
   <updated>2017-01-19T00:00:00+09:00</updated>
   <id>http://subicura.com/2017/01/19/docker-guide-for-beginners-1</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-logo.png&quot; alt=&quot;docker logo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느날 친구한테 메시지를 받았습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커 공부 좀 하려는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello world&lt;/code&gt; 문서 어떤 거 보면서 시작하는 게 좋음?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;구글에서 docker 검색ㄱㄱ&lt;/code&gt;라고 말하려다 인터넷에 있는 &lt;a href=&quot;https://github.com/remotty/documents.docker.co.kr&quot;&gt;도커 관련 글&lt;/a&gt;과 &lt;a href=&quot;http://youtube.opencontainer.co.kr&quot;&gt;동영상&lt;/a&gt; 중에 입문자용 링크를 몇 개 전달해 주었습니다. 이후에도 몇 번 비슷한 요청을 받으면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;도커에 대해 가볍게 정리해보자&lt;/code&gt;라는 생각이 들었고 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;예전 글(도커를 이용한 웹서비스 무중단 배포하기)&lt;/a&gt;과 밋업 때 발표했던 내용, 그리고 그동안의 사용경험을 모아 글을 작성하게 되었습니다.&lt;/p&gt;

&lt;p&gt;이 글은 도커에 대해 1도 모르는 시스템 관리자나 서버 개발자를 대상으로 도커 전반에 대해 얕고 넓은 지식을 담고 있습니다. 도커가 등장한 배경과 도커의 역사, 그리고 도커의 핵심개념인 컨테이너와 이미지에 대해 알아보고 실제로 도커를 설치하고 컨테이너를 실행해 보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 1/3 ✓&lt;/strong&gt; - 도커란 무엇인가?&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 2/3&lt;/a&gt; - 도커 설치 및 컨테이너 실행하기&lt;/li&gt;
  &lt;li&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 3/3 (작성중) - 이미지 생성 및 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;서버를 관리한다는 것&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/contraption-illustration.jpg&quot; alt=&quot;복잡하고 어려운 서버관리&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적으로 서버를 관리한다는 건 복잡하고 어려우며 고오급 개발자들의 섬세한 작업이 필요한 영역입니다.&lt;/p&gt;

&lt;p&gt;2006년 병역특례를 시작하고 맨 처음 했던 일은 매뉴얼을 보고 Redhat Enterprise Linux 4에 Oracle 10g을 설치하는 일이였습니다. 정확히 기억이 나지는 않지만 설치 메뉴얼은 길고 복잡했고 알 수 없는 이유로 자꾸 설치를 실패하였습니다. 제대로 설치가 되지 않으면 다시 OS를 설치하는 것부터 반복하여 몇 번을 재설치한 끝에 성공하곤 했습니다. 회사에서 사용하는 리눅스와 오라클 버전은 딱 정해져 있었고 버전을 업데이트 하는 건 엄청난 리스크였기 때문에 서버는 최대한 건드리지 않고 그대로 두는 게 최선의 방법이였습니다.&lt;/p&gt;

&lt;p&gt;새로운 서버를 셋팅하는 날은 밤을 새는 날이였고 몇 번 밤을 새다보니 &lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;의 달인이 되어 있었습니다. 어느 정도 익숙해졌다고 생각한 시점에도 리눅스 배포판이 바뀌거나 환경이 달라지면 꼭 문제가 생기곤 했습니다.&lt;/p&gt;

&lt;p&gt;하나의 서버에 여러개의 프로그램을 설치하는 것도 문제였는데 서로 사용하는 라이브러리의 버전이 다르거나 동일한 포트를 사용하는 경우는 설치가 굉장히 까다로웠습니다. 차라리 서로 다른 서버에 설치하는게 나았고 그렇게 조립PC는 늘어나고 자원은 낭비됩니다.&lt;/p&gt;

&lt;p&gt;시간이 흐르면서 서버 환경이 계속 바뀌는데 &lt;a href=&quot;https://www.centos.org/&quot;&gt;CentOS&lt;/a&gt;에 익숙해지면 &lt;a href=&quot;https://www.ubuntu.com/&quot;&gt;Ubuntu&lt;/a&gt;를 써야하는 일이 생기고 &lt;a href=&quot;https://aws.amazon.com&quot;&gt;AWS&lt;/a&gt;에 익숙해지면 &lt;a href=&quot;https://azure.microsoft.com&quot;&gt;Azure&lt;/a&gt;를 써야하는 일이 생깁니다. &lt;a href=&quot;https://www.chef.io/chef/&quot;&gt;Chef&lt;/a&gt;의 cookbook에 익숙해지면 &lt;a href=&quot;https://www.ansible.com/&quot;&gt;Ansible&lt;/a&gt;의 playbook을 작성해야 하는 일이 생깁니다. &lt;del&gt;야호&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/DevOps&quot;&gt;DevOps&lt;/a&gt;의 등장으로 개발주기가 짧아지면서 배포는 더 자주 이루어지고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Microservices&quot;&gt;마이크로서비스 아키텍쳐&lt;/a&gt;가 유행하면서 프로그램은 더 잘게 쪼개어져 관리는 더 복잡해집니다. 새로운 툴은 계속해서 나오고 클라우드의 발전으로 설치해야 할 서버가 수백, 수천대에 이르는 &lt;code class=&quot;highlighter-rouge&quot;&gt;1 나누기 0&lt;/code&gt; &lt;del&gt;답이 없는&lt;/del&gt; 같은 상황에서 &lt;a href=&quot;https://www.docker.com/&quot;&gt;도커(Docker)&lt;/a&gt; 가 등장하고 서버관리 방식이 완전히 바뀌게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;도커의 역사&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/the-future-of-linux-containers.png&quot; alt=&quot;The future of Linux Containers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 2013년 3월 산타클라라에서 열린 Pycon Conference에서 dotCloud의 창업자인 Solomon Hykes가 &lt;a href=&quot;https://youtu.be/wW9CAH9nSLs&quot;&gt;The future of Linux Containers&lt;/a&gt; 라는 세션을 발표하면서 처음 세상에 알려졌습니다.&lt;/p&gt;

&lt;p&gt;이 발표 이후 도커가 인기를 얻으면서 2013년 10월 아예 회사이름을 도커(Docker Inc.)로 바꾸고 2014년 6월 도커 1.0을 발표합니다. 2014년 8월 도커에 집중하기 위해 dotCloud 플랫폼을 매각하고 2015년 4월 $95M(약 1,100억원) 투자를 유치한 후 계속해서 빠르게 성장하고 있습니다. (현재까지 총 투자액은 $180M이며 2016년 6월 MS에서 $4B/₩4조에 인수하려 했다는 &lt;a href=&quot;https://www.sdxcentral.com/articles/news/sources-microsoft-tried-to-buy-docker-for-4b/2016/06/&quot;&gt;기사&lt;/a&gt;가 있습니다.) &lt;del&gt;누가 오픈소스는 돈이 되지 않는다고 했는가?!&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-survey.png&quot; alt=&quot;The Evolution of the Modern Software Supply Chain - The Docker Survey, 2016&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;도커에서한&lt;/del&gt; 2016년 설문조사에서 90%가 개발에 사용중이고 80%가 DevOps에 사용할 예정이며 58%가 운영환경에서 사용중이라고 합니다. 2014년 도커 서울 밋업을 시작할 때만 해도 대부분의 사람들이 도커를 잘 모르고 개념도 이해하지 못했는데 이제는 거의 모르는 사람이 없을 정도로 널리 쓰이고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;도커란?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-works.png&quot; alt=&quot;도커는 컨테이너를 관리하는 플랫폼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 &lt;strong&gt;컨테이너 기반의 오픈소스 가상화 플랫폼&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;컨테이너라 하면 배에 실는 네모난 화물 수송용 박스를 생각할 수 있는데 각각의 컨테이너 안에는 옷, 신발, 전자제품, 술, 과일등 다양한 화물을 넣을 수 있고 규격화되어 컨테이너선이나 트레일러등 다양한 운송수단으로 쉽게 옮길 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버에서 이야기하는 컨테이너도 이와 비슷한데 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줍니다. 백엔드 프로그램, 데이터베이스 서버, 메시지 큐등 어떤 프로그램도 컨테이너로 추상화할 수 있고 조립PC, AWS, Azure, Google cloud등 어디에서든 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;컨테이너를 가장 잘 사용하고 있는 기업은 구글인데 &lt;a href=&quot;https://speakerdeck.com/jbeda/containers-at-scale&quot;&gt;2014년 발표&lt;/a&gt; 에 따르면 구글은 모든 서비스들이 컨테이너로 동작하고 매주 20억 개의 컨테이너를 구동 한다고 합니다. &lt;del&gt;갓구글&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;컨테이너(Container)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-container.png&quot; alt=&quot;docker container&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다. 가상화 기술의 하나지만 기존방식과는 차이가 있습니다.&lt;/p&gt;

&lt;p&gt;기존의 가상화 방식은 주로 &lt;strong&gt;OS를 가상화&lt;/strong&gt;하였습니다.&lt;/p&gt;

&lt;p&gt;우리에게 익숙한 &lt;a href=&quot;http://www.vmware.com/&quot;&gt;VMware&lt;/a&gt;나  &lt;a href=&quot;https://www.virtualbox.org&quot;&gt;VirtualBox&lt;/a&gt;같은 가상머신은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Full_virtualization&quot;&gt;전가상화&lt;/a&gt;&lt;sub&gt;Full virtualization&lt;/sub&gt;방식이라고 하는데 호스트OS위에 게스트 OS 전체를 가상화하여 사용하는 방식입니다. 이 방식은 여러가지 OS를 가상화(리눅스에서 윈도우를 돌린다던가) 할 수 있고 비교적 사용법이 간단하지만 무겁고 느려서 운영환경에선 사용할 수 없었습니다.&lt;/p&gt;

&lt;p&gt;이러한 상황을 개선하기 위해 CPU에 가상화 기술이 들어가고 &lt;a href=&quot;http://www.linux-kvm.org/&quot;&gt;KVM&lt;/a&gt;&lt;sub&gt;Kernel-based Virtual Machine&lt;/sub&gt;과 &lt;a href=&quot;https://www.xenproject.org/&quot;&gt;Xen&lt;/a&gt;이라는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Paravirtualization&quot;&gt;반가상화&lt;/a&gt; &lt;sub&gt;Paravirtualization&lt;/sub&gt;방식이 등장합니다. 게스트 OS가 필요하긴 하지만 전체OS를 가상화하는 방식이 아니였기 때문에 전가상화 방식에 비해 성능이 향상되었습니다. 이러한 기술들은 AWS나 &lt;a href=&quot;https://www.rackspace.com/&quot;&gt;Rackspace&lt;/a&gt;같은 클라우드 서비스에서 가상 컴퓨팅 기술의 기반이 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/vm-vs-docker.png&quot; alt=&quot;가상머신과 도커&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전가상화든 반가상화든 추가적인 OS를 설치하여 가상화하는 방법은 어쨋든 성능문제가 있었고 이를 개선하기 위해 &lt;strong&gt;프로세스를 격리&lt;/strong&gt; 하는 방식이 등장합니다.&lt;/p&gt;

&lt;p&gt;리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작합니다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거어어어어의 손실이 없습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커의 기본 네트워크 모드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bridge&lt;/code&gt;모드로 약간의 성능 손실이 있습니다. 네트워크 성능이 중요한 프로그램의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt; 옵션을 고려해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하나의 서버에 여러개의 컨테이너를 실행하면 서로 영향을 미치지 않고 독립적으로 실행되어 마치 가벼운 VM&lt;sub&gt;Virtual Machine&lt;/sub&gt;을 사용하는 느낌을 줍니다. 실행중인 컨테이너에 접속하여 명령어를 입력할 수 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;으로 패키지를 설치할 수 있으며 사용자도 추가하고 여러개의 프로세스를 백그라운드로 실행할 수도 있습니다. CPU나 메모리 사용량을 제한할 수 있고 호스트의 특정 포트와 연결하거나 호스트의 특정 디렉토리를 내부 디렉토리인 것처럼 사용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;새로운 컨터이너를 만드는데 걸리는 시간은 겨우 1-2초&lt;del&gt;(체감 0.001초)&lt;/del&gt;로 가상머신과 비교도 할 수 없이 빠릅니다.&lt;/p&gt;

&lt;p&gt;이러한 컨테이너라는 개념은 도커가 처음 만든 것이 아닙니다. 도커가 등장하기 이전에, 프로세스를 격리하는 방법으로 리눅스에서는 cgroups&lt;sub&gt;control groups&lt;/sub&gt;와 namespace를 이용한 &lt;a href=&quot;https://linuxcontainers.org/lxc/&quot;&gt;LXC&lt;/a&gt;&lt;sub&gt;Linux container&lt;/sub&gt;가 있었고 FreeBSD에선 &lt;a href=&quot;https://www.freebsd.org/doc/handbook/jails.html&quot;&gt;Jail&lt;/a&gt;, Solaris에서는 &lt;a href=&quot;https://docs.oracle.com/cd/E18440_01/doc.111/e18415/chapter_zones.htm#OPCUG426&quot;&gt;Solaris Zones&lt;/a&gt;이라는 기술이 있었습니다. 구글에서는 고오오급 기술자들이 직접 컨테이너 기술을 만들어 사용하였고 &lt;a href=&quot;https://github.com/google/lmctfy&quot;&gt;lmctfy(Let Me Contain That For You)&lt;/a&gt;라는 &lt;del&gt;뭐라고 읽어야 할지 알 수 없는&lt;/del&gt; 오픈소스 컨테이너 기술을 공개했지만 성공하진 못했습니다.&lt;/p&gt;

&lt;p&gt;도커는 LXC를 기반으로 시작해서 0.9버전에서는 자체적인 &lt;a href=&quot;https://github.com/docker/libcontainer&quot;&gt;libcontainer&lt;/a&gt; 기술을 사용하였고 추후 &lt;a href=&quot;http://runc.io/&quot;&gt;runC&lt;/a&gt;기술에 합쳐졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미지(Image)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-image.png&quot; alt=&quot;Docker image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커에서 가장 중요한 개념은 컨테이너와 함께 이미지라는 개념입니다.&lt;/p&gt;

&lt;p&gt;이미지는 &lt;strong&gt;컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것&lt;/strong&gt;으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.&lt;/p&gt;

&lt;p&gt;ubuntu이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 MySQL이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보등을 가지고 있습니다. 좀 더 복잡한 예로 Gitlab 이미지는 centos를 기반으로 ruby, go, database, redis, gitlab source, nginx등을 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;말그대로 이미지는 컨테이너를 실행하기 위한 모오오오오든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다. 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다. 한 서버에 여러개의 컨테이너를 실행할 수 있고, 수십, 수백, 수천대의 서버도 문제없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-store.png&quot; alt=&quot;Docker Store&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지는 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker hub&lt;/a&gt;에 등록하거나 &lt;a href=&quot;https://docs.docker.com/registry/&quot;&gt;Docker Registry&lt;/a&gt; 저장소를 직접 만들어 관리할 수 있습니다. 현재 공개된 도커 이미지는 50만개가 넘고 Docker hub의 이미지 다운로드 수는 80억회에 이릅니다. 누구나 쉽게 이미지를 만들고 배포할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;왜 이렇게 핫한가?&lt;/h2&gt;

&lt;p&gt;도커는 완전히 새로운 기술이 아니며 이미 존재하는 기술을 잘 포장했다고 볼 수 있습니다. &lt;del&gt;(마치 최신기술을 잘 포장해서 만든 아이폰처럼)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;컨테이너, &lt;a href=&quot;https://en.wikipedia.org/wiki/Overlay_network&quot;&gt;오버레이 네트워크&lt;/a&gt;&lt;sub&gt;overlay network&lt;/sub&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/UnionFS&quot;&gt;유니온 파일 시스템&lt;/a&gt;&lt;sub&gt;union file systems&lt;/sub&gt;등 이미 존재하는 기술을 도커처럼 잘 조합하고 사용하기 쉽게 만든 것은 없었고 사용자들이 원하는 기능을 간단하지만 획기적인 아이디어로 구현하였습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;레이어 저장방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/image-layer.png&quot; alt=&quot;Docker Layer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백메가&lt;sub&gt;MB&lt;/sub&gt;에 이릅니다. 처음 이미지를 다운받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적일 수 밖에 없습니다.&lt;/p&gt;

&lt;p&gt;도커는 이런 문제를 해결하기 위해 &lt;strong&gt;레이어&lt;sub&gt;layer&lt;/sub&gt;&lt;/strong&gt;라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해줍니다. 이미지는 여러개의 읽기 전용&lt;sub&gt;read only&lt;/sub&gt; 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성됩니다. ubuntu 이미지가 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;가 됩니다. webapp 이미지를 nginx 이미지 기반으로 만들었다면 예상대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt; 레이어로 구성됩니다. webapp 소스를 수정하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt; 레이어를 제외한 새로운 &lt;code class=&quot;highlighter-rouge&quot;&gt;source(v2)&lt;/code&gt; 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있습니다. &lt;del&gt;(개이득)&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;컨테이너를 생성할 때도 레이어 방식을 사용하는데 기존의 이미지 레이어 위에 읽기/쓰기&lt;sub&gt;read-write&lt;/sub&gt; 레이어를 추가합니다. 이미지 레이어를 그대로 사용하면서 컨테이너가 실행중에 생성하는 파일이나 변경된 내용은 읽기/쓰기 레이어에 저장되므로 여러개의 컨테이너를 생성해도 최소한의 용량만 사용합니다.&lt;/p&gt;

&lt;p&gt;가상화의 특성상 이미지 용량이 크고 여러대의 서버에 배포하는걸 감안하면 단순하지만 엄청나게 영리한 설계입니다.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;이미지 경로&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/image-url.png&quot; alt=&quot;Docker image url&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지는 url 방식으로 관리하며 태그를 붙일 수 있습니다. ubuntu 14.04 이미지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library/ubuntu:14.04&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library/ubuntu:trusty&lt;/code&gt; 이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker.io/library&lt;/code&gt;는 생략가능하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu:14.04&lt;/code&gt; 로 사용할 수 있습니다. 이러한 방식은 이해하기 쉽고 편리하게 사용할 수 있으며 태그 기능을 잘 이용하면 테스트나 롤백도 쉽게 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;

&lt;noscript&gt;&lt;pre&gt;# vertx/vertx3 debian version
FROM subicura/vertx3:3.3.1
MAINTAINER chungsub.kim@purpleworks.co.kr

ADD build/distributions/app-3.3.1.tar /
ADD config.template.json /app-3.3.1/bin/config.json
ADD docker/script/start.sh /usr/local/bin/
RUN ln -s /usr/local/bin/start.sh /start.sh

EXPOSE 8080
EXPOSE 7000

CMD [&amp;quot;start.sh&amp;quot;]&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/7deda80268943f5f72750e08c37182fb.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;도커는 이미지를 만들기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;이라는 파일에 자체 DSL&lt;sub&gt;Domain-specific language&lt;/sub&gt;언어를 이용하여 이미지 생성 과정을 적습니다. 추후에 문법에 대해 자세히 다루겠지만 위 샘플을 보면 그렇게 복잡하지 않다는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;이것은 굉장히 간단하지만 유용한 아이디어인데, 서버에 어떤 프로그램을 설치하려고 이것저것 의존성 패키지를 설치하고 설정파일을 만들었던 경험이 있다면 더 이상 그 과정을 블로깅 하거나 메모장에 적지 말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;로 관리하면 됩니다. 이 파일은 소스와 함께 버전 관리 되고 원한다면 누구나 이미지 생성과정을 보고 수정할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-pull.png&quot; alt=&quot;Docker Hub Hits 5 Billion Pulls(2016/08)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 이미지의 용량은 보통 수백메가로 수기가가 넘는 경우도 흔합니다. 이렇게 큰 용량의 이미지를 서버에 저장하고 관리하는 것은 쉽지 않은데 도커는 Docker hub를 통해 공개 이미지를 무료로 관리해 줍니다. 하루에도 엄청난 용량의 이미지가 전세계에서 다운로드 되고 트래픽 비용만 해도 어마어마 할 것 같은데 그것이 다 무료!입니다.&lt;/p&gt;

&lt;h3 id=&quot;command-api&quot;&gt;Command와 API&lt;/h3&gt;

&lt;p&gt;도커 클라이언트의 커맨드 명령어는 정말 자아아알 만들어져 있습니다. 대부분의 명령어는 직관적이고 사용하기 쉬우며 컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있습니다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋고 훌륭한 3rd party 툴이 나오기 좋은 환경입니다.&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;유용한 새로운 기능들&lt;/h3&gt;

&lt;p&gt;도커는 발전속도가 아주 빠른 오픈소스입니다. 사용하면서 부족하다고 느꼈던 부분은 빠르게 개선되고 새로운 버전이 나오면 유용한 기능이 대폭 추가됩니다. 어떻게 보면 프로그램을 작은 조각으로 나누고 여러개의 프로그램을 조합하여 동작시키는 유닉스의 철학에는 맞지 않지만.. 너무 잘합니다. ㅠㅠ&lt;/p&gt;

&lt;p&gt;이번 1.13버전에서는 &lt;a href=&quot;https://github.com/docker/docker/blob/master/experimental/docker-stacks-and-bundles.md&quot;&gt;Docker stacks&lt;/a&gt;이라는 여러개의 컨테이너를 한번에 관리하는 기능이 정식으로 릴리즈 되었고 &lt;a href=&quot;https://github.com/docker/docker/pull/27794&quot;&gt;Secrets Management&lt;/a&gt;라는 비밀정보를 관리하는 기능이 추가됩니다.&lt;/p&gt;

&lt;p&gt;기능은 계속 추가되고 있고 점점 사용하기 편해집니다.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;훌륭한 생태계&lt;/h3&gt;

&lt;p&gt;도커는 굉장히 큰 생태계를 가지고 있고 커다란 기업과 협력하여 사실상 클라우드 컨테이너 세계의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%8B%A4%EC%83%81_%ED%91%9C%EC%A4%80&quot;&gt;de facto&lt;/a&gt;가 되었습니다. 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포등 다양한 분야에서 다양한 툴들이 존재하며 아예 &lt;a href=&quot;https://coreos.com/why/&quot;&gt;도커를 위한 OS(coreos-&amp;gt; container linux)&lt;/a&gt;도 존재합니다.&lt;/p&gt;

&lt;p&gt;현재 도커를 기반으로한 오픈소스 프로젝트는 10만개가 넘고 굉장히 활발하게 진행되고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;커뮤니티 지원&lt;/h3&gt;

&lt;p&gt;도커는 기술기업답지 않게 홍보와 커뮤니티 관리에 굉장히 신경쓰고 있습니다. 커뮤니티를 위한 스티커나 티셔츠를 무료로 제공하고 필요하면 연사요청도 할 수 있습니다. 홈페이지에서는 전세계에서 열리는 밋업 상황을 볼 수 있고 일주일마다 발송되는 &lt;a href=&quot;https://blog.docker.com/docker-weekly-archives/&quot;&gt;뉴스레터&lt;/a&gt;에는 다양한 개발자들의 글이 실려있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/docker-jpetazzo.jpg&quot; alt=&quot;Docker office에서 만난 Jérôme Petazzoni&quot; /&gt;&lt;/p&gt;

&lt;p&gt;운이 좋았지만 도커 오피스에 방문해서 사무실을 구경할 수도 있었고 고오오오급 개발자 &lt;a href=&quot;https://twitter.com/jpetazzo&quot;&gt;Jérôme Petazzoni&lt;/a&gt;와 직접 이야기를 나눌수 있었습니다! &lt;del&gt;아 또 가고 싶다&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;moby-dock&quot;&gt;moby dock&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/animals.jpg&quot; alt=&quot;Tux(linux) - Moby Dock(docker) - Gopher (golang)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커는 넘나 귀여운 고래를 로고로 하고 있습니다. 로고 스티커는 항상 인기가 넘치고 로고가 그려진 티셔츠는 입고 돌아다녀도 개발자처럼 보이지 않습니다. 도커가 성공한 가장 큰 이유는 귀여운 고래 덕분이라고 생각합니다.(엄근진) &lt;del&gt;오픈소스가 성공하려면 귀여운 동물 캐릭터를 사용하세요!&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;여기까지 도커에 대해 기본적인 내용을 아주 얕게 살펴보았습니다. 이제 실전으로 들어가봅시다!&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 1/3 ✓&lt;/strong&gt; - 도커란 무엇인가?&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/01/19/docker-guide-for-beginners-2.html&quot;&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 2/3&lt;/a&gt; - 도커 설치 및 컨테이너 실행하기&lt;/li&gt;
  &lt;li&gt;초보를 위한 도커 안내서 - 설치부터 배포까지 3/3 (작성중) - 이미지 생성 및 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</content>
 </entry>
 
 <entry>
   <title>2016년 블로그 회고</title>
   <link href="http://subicura.com/2016/12/31/remember-2016.html"/>
   <updated>2016-12-31T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/12/31/remember-2016</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-12-31-remember-2016/woozoo_read_the_book.jpg&quot; alt=&quot;김우주(19개월)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어느덧 2016년 마지막 날입니다. 올 한해 역시 정신없이 지나갔고 작년에 태어난 딸도 돌을 지나고 어느새 python 개발 서적을 읽을 정도의 나이가 되었습니다(&lt;del&gt;위 사진 참조&lt;/del&gt;). 회사는 6주년을 맞이했고 올해 처음으로 일반 고객을 대상으로한 서비스를 오픈했습니다. 서비스를 운영하면서 느낀 점도 많지만 일단은 블로그에 대해 한해를 마무리하는 회고를 하려고 합니다.&lt;/p&gt;

&lt;p&gt;10년 전쯤 블로그를 처음 시작하고 방치하고 삭제하고 다시 만들고 방치하고 삭제하고를 반복했습니다. 애초에 글을 쓸 실력이 안되었고 특별한 목적을 가지고 만들지 않았기 때문에 내용도 부실하고 방문자수도 없는 상황이였습니다. 그러다 2016년 5월 30일 다시 블로그를 만들었고 첫번째 글 “&lt;a href=&quot;/2016/05/30/likehs-develop-log.html&quot;&gt;홈쇼핑처럼 개발후기&lt;/a&gt;“가 반응을 타면서 몇 개 글을 더 썼고 7월 이후 다시 방치..되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;블로그 구성&lt;/h2&gt;

&lt;p&gt;현재 블로그는 &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt; 엔진을 이용하여 &lt;a href=&quot;https://github.com/subicura/subicura.github.io&quot;&gt;github&lt;/a&gt;에서 정적 문서로 제공되고 있습니다. 이 방식은 무료면서 디자인을 자유롭게 구성할 수 있고 마크다운 문서로 편리하게 글을 관리할 수 있습니다. 네이버 블로그나 티스토리, 브런치같은 무료 호스트 방식은 커스터마이징등 기능에 제한이 있고 &lt;a href=&quot;https://wordpress.com/&quot;&gt;wordpress&lt;/a&gt;나 &lt;a href=&quot;https://ghost.org/&quot;&gt;ghost&lt;/a&gt;와 같은 설치형은 자유롭게 수정할 수 있으나 서버 및 버전 관리가 귀찮은 점 때문에 최종적으로 jekyll+github 방식을 사용하였습니다.&lt;/p&gt;

&lt;p&gt;jekyll skin은 &lt;a href=&quot;https://github.com/dirkfabisch/mediator&quot;&gt;mediator&lt;/a&gt;를 fork한 후 폰트와 가로폭, 줄간격, 로고, 코멘트 방식, 이전/다음글 목록을 한땀한땀 수정하여 보는 사람이 편하게 볼 수 있도록 최대한 노력하였습니다. &lt;a href=&quot;https://medium.com/&quot;&gt;medium&lt;/a&gt;과 &lt;a href=&quot;https://brunch.co.kr/&quot;&gt;브런치&lt;/a&gt;가 워낙 이뻐서 많은 영향을 받았습니다. (&lt;del&gt;medium은 윈도우에서 한글폰트가 꽝입니다.&lt;/del&gt;)&lt;/p&gt;

&lt;p&gt;글 작성은 &lt;a href=&quot;https://atom.io/&quot;&gt;atom&lt;/a&gt;에디터에서 Markdown Preview 기능을 이용하여 작성하고 있고 코드는 &lt;a href=&quot;https://gist.github.com/&quot;&gt;gist&lt;/a&gt;를 사용하였습니다. gist는 코드관리가 편하고 다양한 언어의 syntax highlighting을 지원하여 아주 이쁘게 표현해 줍니다. 차트나 순서도는 &lt;a href=&quot;https://www.lucidchart.com/&quot;&gt;Lucidchart&lt;/a&gt;를 이용하고 있는데 단순하게 쓰기에 무료플랜도 전혀 문제없고 아주 쉽고 빠르게 그럴듯한 결과물을 만들 수 있습니다. 블로그뿐 아니라 시스템 구성도나 프로세스를 설명할 때도 자주 사용하고 있습니다. 특히 &lt;a href=&quot;https://fonts.google.com/specimen/Titillium+Web&quot;&gt;Titillium 폰트&lt;/a&gt;와 함께 사용하면 깔끔해 보입니다. 색을 선택하기 어렵다면 &lt;a href=&quot;http://flatuicolors.com/&quot;&gt;flatuicolors&lt;/a&gt;서비스를 추천합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;올 해 쓴글&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-12-31-remember-2016/pageview.png&quot; alt=&quot;2016년 쓴 글&quot; /&gt;&lt;/p&gt;

&lt;p&gt;처음 글을 쓸때는 1주일에 한개를 목표로 하였으나 최종적으로 5개밖에 쓰지 못했습니다. (…) 첫번째 글인 &lt;a href=&quot;/2016/05/30/likehs-develop-log.html&quot;&gt;홈쇼핑처럼 개발후기&lt;/a&gt;는 하루만에 페이지뷰가 10,000을 돌파하는 예상외의 폭발적인 반응&lt;del&gt;과 우려&lt;/del&gt;을 얻었고 파워블로거를 해볼까..라는 &lt;del&gt;헛된&lt;/del&gt; 생각과 블로그의 주제에 대해 많은 고민을 하게 해주었습니다.&lt;/p&gt;

&lt;p&gt;이후에 작성한 &lt;a href=&quot;/2016/06/07/zero-downtime-docker-deployment.html&quot;&gt;도커를 이용한 웹서비스 무중단 배포하기&lt;/a&gt;도 반응이 좋아 7월경에 “홈쇼핑처럼x개발자처럼_첫번째이야기”라는 오프라인 모임도 갖게 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-12-31-remember-2016/1st_off.jpg&quot; alt=&quot;홈쇼핑처럼x개발자처럼_첫번째이야기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 후기를 정리하여 6번째 글을 작성할 예정이였으나 결국 올해를 넘기게 되었습니다. ㅠㅠ 이부분은 아마 내년 초에 작성할 것 같습니다. 그 때 참여해 주셨던 분들 모두 감사드리고 좋은 말씀 나누어서 뜻깊은 시간이였습니다.&lt;/p&gt;

&lt;p&gt;3번째 글인 &lt;a href=&quot;/2016/06/13/start-go-shipment-tracking-opensource.html&quot;&gt;Go언어로 오픈소스 배송조회 서비스 만들기&lt;/a&gt;도 많은 분들이 읽어주셨고 관련하여 오픈한 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;delibird&lt;/a&gt; 소스는 아주 활성화 되지는 않았지만 좋아요는 100개를 넘겼습니다. ㅎㅎ 마성의 언어인 Go에 대해 요즘 사용이 뜸해져서 개인프로젝트에 다시 사용해 보려고 하고 있습니다.&lt;/p&gt;

&lt;p&gt;4번째 글인 &lt;a href=&quot;/2016/06/20/server-side-rendering-with-react.html&quot;&gt;왜 React와 서버 사이드 렌더링인가?&lt;/a&gt;는 React를 꽤 사용해보고 적었다고 생각했는데 그 이후로 React에 대해 몰랐던 부분을 많이 배웠고 글 쓴 당시보다는 React에 &lt;del&gt;꽤&lt;/del&gt; 실망하고 있습니다. React는 여전히 매력적이고 계속해서 한동안 사용할 것 같지만 3rd party 라이브러리들에서 은근 문제가 많이 발생하고 디렉토리 구조나 사용패턴등이 너무 다양하여 선택자체에 시간과 고민이 너무 많이 소요되었습니다. 많은 고민 끝에 어느정도 패턴을 정형화 하여 사용중이긴 하나 아직 확신이 들지 않습니다. 이 부분은 어느정도 더 정리가 되면 포스팅 하려고 합니다.&lt;/p&gt;

&lt;p&gt;5번째 글인 &lt;a href=&quot;/2016/07/11/coding-convention.html&quot;&gt;linter를 이용한 코딩스타일과 에러 체크하기&lt;/a&gt;는 다른글에 비해 급하게 작성하였는데 역시 페이지뷰에서 증명되었습니다. 오랫동안 생각하고 정리한 글이 확실히 반응이 좋았던 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;어려운점&lt;/h2&gt;

&lt;p&gt;개발자 중에서 글을 재밌고 논리정연하게 잘 작성하는 &lt;a href=&quot;https://github.com/sarojaba/awesome-devblog&quot;&gt;고오오급 개발자 분들&lt;/a&gt;도 많지만 저 같은 경우는 글쓰기 자체가 어려웠습니다. 글을 쓰는 것 보다 코드를 한 줄 더 작성하는게 좋고 잘 정리하고 이해하기 쉽게 쓰려면 시간이 꽤 많이 필요했습니다. 일이 먼저, 글은 나중이 되다보니 쓸 시간은 점점 더 없어지고 집에서도 아기와 함께하느라 시간내기가 어려웠습니다. 이부분은 부지런해지는 수밖에 없는 것 같습니다.&lt;/p&gt;

&lt;p&gt;그리고 주제를 정하는 것이 특히 어려웠습니다. 흔한 주제는 쓰기는 쉽지만 차별화가 어렵고, 좋은 외국 개발자의 글을 번역하는 것은 내용이나 의미가 바뀔까봐 쓰기가 어려웠습니다. 많이 하고 잘 아는 분야에 대해 글을 써야 하는데 알면 알수록 모르는게 많아지는 개발공부의 특성상 부정확한 정보를 작성하는 것에 대한 두려움이 글을 쓰기 어렵게 만드는 것 같습니다.&lt;/p&gt;

&lt;p&gt;내가 직접 경험한 내용과 남이 경험한 내용을 들은 것, 내가 직접 확인한 것과 거의 확실하다고 추측되는 것등을 적절하게 선택하여 글을 쓰려면 많은 고민이 필요하고 더더욱 글을 쓰기 어렵게 만듭니다.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;개발 관련 글을 쓰거나 발표를 하면 자칫 입으로 개발을 하는 사람(&lt;del&gt;입개발&lt;/del&gt;)이 되는 경우가 있습니다. 허세와 건방짐이 있는 것처럼 보이는데 이러한 부분이 무조건 나쁘다고 생각하지 않습니다. 문제는 무조건 내가 맞다고 주장하거나 피드백을 받아 들이지 못하는 경우라고 생각합니다.&lt;/p&gt;

&lt;p&gt;글을 쓰려면 틀릴걸 각오하는 용기가 필요합니다. 이러한 것이 없다면 모든 걸 다 알기 전까진 글을 쓰지 못할 것이고 “Done is better then perfect”라는 말처럼 어쨋든 무언가를 하는 것이 낫다고 생각합니다. 글을 쓰면서 생각을 정리하고 모호했던 부분을 다시 공부하고 많은 사람과 피드백 속에 더 좋은 결과가 나오는 것 같습니다.&lt;/p&gt;

&lt;p&gt;많은 글을 쓰진 못했지만.. 많은 분들이 글을 좋게 봐주셔서 감사한 한해였고, 내년에는 좀더 부지런하게 글을 쓰도록 해야겠습니다.&lt;/p&gt;

&lt;p&gt;새해 복 많이 받으세요.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linter를 이용한 코딩스타일과 에러 체크하기</title>
   <link href="http://subicura.com/2016/07/11/coding-convention.html"/>
   <updated>2016-07-11T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/07/11/coding-convention</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/carbo.jpg&quot; alt=&quot;돈까스먹는용만이x까르보돈까스&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt; 6번째 상품인 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/27/&quot;&gt;까르보돈까스&lt;/a&gt;는 부먹과 찍먹을 선택해야 합니다. 코딩도 둘중에 하나를 선택해야 하는 경우가 많은데 협업을 위해 코딩 스타일을 설정하고 규칙에 어긋난 코드를 한땀한땀 수정했던 순간이 떠올라 linter에 대해 이야기합니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/civil_war.jpg&quot; alt=&quot;시빌워&quot; title=&quot;시빌워&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Programming_style&quot;&gt;코딩스타일&lt;/a&gt;, 코딩 표준이라고도 불리는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Coding_conventions&quot;&gt;코딩 컨벤션&lt;/a&gt;은 코드를 작성할 때 추천하는 코딩 스타일, 괜찮은 사례등을 모아 놓은 가이드라인입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;에 중괄호({)는 다음 줄에 쓰는게 좋을까요, 같은 줄에 쓰는게 좋을까요? 띄어쓰기는 스페이스랑 탭중에 어떤걸 쓸까요? 스페이스를 사용한다면 2칸? 4칸? 8칸? 몇칸을 띄우는 나을까요? 정답은 없지만 어떤게 인기 있는지는 &lt;a href=&quot;http://sideeffect.kr/popularconvention/#java&quot;&gt;여기&lt;/a&gt;서 언어별 대세를 확인해 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;코딩 컨벤션은 표준이라고 하지만 꼭 지켜지 않아도 프로그램은 잘 동작하고 이 방식이 좋은지 저 방식이 좋은지 백날 싸워도 결론이 없는 딱히 신경 쓰지 않아도 크게 문제 없어 보이는 가이드라인입니다.&lt;/p&gt;

&lt;p&gt;이러한 코딩 컨벤션과 에러 체크를 도와주는 툴을 linter라고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;문제는 유지보수&lt;/h2&gt;

&lt;p&gt;과거의 많은 고오급 개발자들은 개발하는 시간의 반이상이 유지보수를 하는데 쓰인다는걸 알았습니다. 미래의 내가 현재의 나를 욕하지 않고 레거시가 내거시가 되어 나를 괴롭히지 않으려면 유지보수가 쉽도록 코드를 작성해야합니다.&lt;/p&gt;

&lt;p&gt;유지보수가 쉽고 버그가 없는 코드를 작성하려면 많은 경험과 노력이 필요합니다. 어떻게 하면 코드의 품질을 높일 수 있을까..라고 많은 개발자들이 고민했고 정량적으로 코드를 분석할 수 있는 정적분석과 동적분석용 툴을 만들고 테스트 코드를 작성하는 방법을 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_program_analysis&quot;&gt;정적분석&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정적분석은 프로그램을 실행하지 않고 코드를 분석하는 방법입니다.&lt;/p&gt;

&lt;p&gt;코드를 보면 띄어쓰기나 줄바꿈이 이상한 부분을 발견할 수 있고 메소드가 너무 길거나 변수명 형식이 어떤건 언더바(form_value) 어떤건 카멜케이스(formValue)로 오락가락하면 통일하는게 좋습니다. 상수로 사용하는 변수는 변경되지 않도록 하는게 버그를 예방할 수 있기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;로 선언하는게 낫고 사용하지 않는 변수나 함수는 지우는게 나중에 코드를 볼때 훨씬 편합니다. 한 클래스는 적절한 수의 메소드를 가지고 있어야 하고 if문을 사용할때는 너무 복잡하게 중첩하면 무슨 내용인지 이해하기가 어렵죠.&lt;/p&gt;

&lt;p&gt;이렇게 &lt;strong&gt;느낌적&lt;/strong&gt;으로 알고 있는 내용을 모아모아모아서 고급 개발자들이 코딩컨벤션, 예상결함방지, 코드복잡도 메트릭스등의 이름으로 정리하였고 다양한 툴들이 유/무료로 제공되고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_program_analysis&quot;&gt;동적분석&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;동적분석은 실제로 프로그램을 실행해보고 취약점을 분석합니다.&lt;/p&gt;

&lt;p&gt;메모리에 릭이 발생하거나 쓰레드가 꼬이는 문제는 실제로 프로그램을 실행하지 않으면 발견하기가 어렵습니다. 앱 개발자들은 한참 앱을 사용하다가 죽으면 아.. 어디선가 메모리가 세고 있다는걸 &lt;strong&gt;느낌적&lt;/strong&gt;으로 알고 있습니다. 이러한 때에 메모리누수 체크툴을 사용하면 실시간으로 메모리 사용량을 프로파일링해주고 어떤 변수가 문제가 있는지를 표로 정리해서 보여줍니다. &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode&lt;/a&gt;와 &lt;a href=&quot;http://developer.android.com/tools&quot;&gt;Android Studio&lt;/a&gt;에서 관련 기능을 제공하고 있기 때문에 릴리즈 하기전에 메모리 누수등을 체크해보면 예상치 못한 곳에서 결함을 발견할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Software_testing&quot;&gt;테스트&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;테스트는 다양한 방법이 존재하고 여러가지 방식으로 코드가 정상적으로 동작하는지 검사합니다.&lt;/p&gt;

&lt;p&gt;어떤 메소드를 아무리 잘 설계하고 코드를 잘 작성했다고 하더라도 해당 메소드에 대한 테스트 코드가 없다면 검증 및 유지보수가 어렵습니다. 대부분의 유명한 오픈소스들은 기능을 추가하는 코드를 풀 리퀘스트하게 되면 테스트 코드도 같이 작성해 달라고 요청을 합니다. 테스트 코드가 없으면 추가되는 기능을 검증하기 위해 일일이 수작업으로 체크를 해야하고 나중에 소스가 수정되었을 때 어떤 영향을 미치는지 알 수가 없게 됩니다. 운좋게 동작하는 라이브러리를 만드는게 아니라면 테스트코드는 필수 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://martinfowler.com/bliki/TechnicalDebt.html&quot;&gt;기술부채&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여러분석툴을 사용하고 테스트코드를 열심히 작성하면 분명 코드의 품질은 좋아집니다. 하지만, 실제로 분석툴을 돌려보면 어마어마한 경고를 받게 되고 그런 결함을 수정하다보면 이게 코드를 작성하는건지 하루종일 경고만 보고 리팩토링만 하는 건지 혼란스러울 수 있습니다.&lt;/p&gt;

&lt;p&gt;버그는 없고 코드는 단단하지만 느리게 개발하는 방식과 개발속도는 빠르지만 코드는 약간 지저분하게 작성하는 방식중에 많은 스타트업은 후자를 선택합니다.
코드는 복잡해지고 찝찝한 부분도 생기지만 일단 기능을 빠르게 구현하고 잘 동작하는 것 같으면 릴리즈합니다. 이렇게 알면서도 방치하는 몇몇 문제들을 기술부채&lt;sub&gt;technical debt&lt;/sub&gt;라고 하고 우리는 그렇게 빚이 쌓여가게 됩니다. &lt;del&gt;현실에서도 빚, 개발에서도 빚, 엉엉&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;쌓이고 쌓인 기술부채는 여러가지 방법으로 이자를 갚거나 주기적인 리팩토링을 통해 원금을 갚아야 하지만 개발자 한명 뽑기 어려운 스타트업에서는 사실상 개선하기 어려운 부분(&lt;del&gt;너 왜 개발안하고 노니?&lt;/del&gt;)이 많습니다. 큰 회사도 예외는 아니여서 그렇게 방치하고 땜질하다가 어느날 고도화라는 이름의 프로젝트를 시작하고 아예 새로 코드를 작성하기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;linter-&quot;&gt;Linter 적용해보기&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;유지보수는 어렵고 시간이 많이 걸린는 작업이다. 개선이 필요하다고 생각한다.&lt;/li&gt;
  &lt;li&gt;다양한 분석툴과 테스트코드를 작성하면 유지보수와 협업이 쉬워진다.&lt;/li&gt;
  &lt;li&gt;기술부채는 꾸준히 갚아가는게 중요하다.&lt;/li&gt;
  &lt;li&gt;코드의 품질이 높아지면 앱의 완성도가 높아지고 수익이 증가하여 결국 이득이다.&lt;/li&gt;
  &lt;li&gt;하지만, 시간과 인력이 부족하다. 뭔가 추가로 작업할 여력이 없다. ㅠ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 5가지에 동의를 하지만 아직 아무 조치도 취하지 않았다면 linter를 적용하기 좋은때입니다.&lt;/p&gt;

&lt;p&gt;linter는 코딩 컨벤션과 에러를 체크해주는 작은 프로그램입니다. 독립적으로 실행할 수도 있고 IDE의 플러그인으로도 존재합니다. Python, Ruby, Java, Swift, HTML, CSS, YAML, 심지어 Markdown까지 대부분의 문법을 지원하고 있기 때문에 어떤 프로그램 언어를 사용하든 바로 체크해 볼 수 있습니다. Atom 에디터에서 지원하는 &lt;a href=&quot;https://atomlinter.github.io/&quot;&gt;Linter 목록&lt;/a&gt;을 보면 대부분의 언어를 지원하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;구글(&lt;a href=&quot;https://github.com/google/styleguide&quot;&gt;구글스타일가이드&lt;/a&gt;), 마이크로소프트와 같은 고오오오급 개발회사들은 자체적인 코딩 컨벤션을 가지고 있고 기본적으로 소스를 제출하기전에 코딩 스타일을 맞추는 것은 기본입니다. 회사차원이 아닌 언어차원에서 스타일을 지정하기도 하는데 Python의 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot;&gt;PEP8&lt;/a&gt;이라던가 Golang의 gofmt등이 있고, wordpress(&lt;a href=&quot;https://codex.wordpress.org/WordPress_Coding_Standards&quot;&gt;wordpress coding standards&lt;/a&gt;), drupal 같은 유명한 툴들도 각각 스타일을 정의해서 가이드라인으로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;예전에는 코딩 스타일 가이드를 문서로 만들어 관리하기도 하였으나, 툴의 도움이 없다면 사실상 무의미한 작업입니다. 요즘은 다양한 툴이 존재하고 바로 적용하기 쉬우며 단계적으로 조금씩 적용하는 것도 가능합니다. 미적으로도 이쁘고 협업과 코드 리뷰를 할때도 좋고 심지어 더 나은 코드를 추천해주어 실력도 늘수 있는.. 이게 1석 몇조야… 바로 적용하지 않을 이유가 없습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;import React, { Component } from &amp;#39;react&amp;#39;;

//form
class Comment extends Component {
  constructor(props) {
    super(props);

    this.state = {
      msg:&amp;quot;&amp;quot;
    };
  }
  onSubmit() {
    if(this.props.useComment) {
      alert(this.state.name + &amp;quot;님이 댓글을 작성하였습니다.&amp;quot;);
    }
  }
  componentDidMount() {
    this.submitBtn = this.refs.submitBtn;
  }
  render() {
    var onChange = e =&amp;gt; this.setState({ msg: e.target.value });

    return (
      &amp;lt;form method=&amp;quot;post&amp;quot; className=&amp;quot;form-horizontal&amp;quot; onSubmit={this.onSubmit.bind(this)}&amp;gt;
        &amp;lt;input name=&amp;quot;msg&amp;quot; type=&amp;quot;text&amp;quot; class=&amp;quot;form-control&amp;quot; onChange={onChange.bind(this)} value={this.state.msg} /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; ref=&amp;quot;submitBtn&amp;quot;&amp;gt;{ this.props.useComment ? &amp;#39;글쓰기&amp;#39; : &amp;#39;댓글불가&amp;#39; }&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    )
  }
}

export default Comment;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/f98964692aed12ae1bab67005e4ecf27.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;ReactJS 샘플 코드입니다. 최신 es6 문법도 적용하고 최선을 다해 잘 작성했다고 보이는데.. 그 유명한 &lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&quot;&gt;airbnb의 eslint&lt;/a&gt;규칙을 체크해볼까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;3:1   Expected exception block, space or tab after ‘//’ in comment&lt;/li&gt;
  &lt;li&gt;9:11  Missing space before value for key ‘msg’&lt;/li&gt;
  &lt;li&gt;9:11  Strings must use singlequote&lt;/li&gt;
  &lt;li&gt;9:13  Missing trailing comma&lt;/li&gt;
  &lt;li&gt;12:3   onSubmit should be placed after componentDidMount&lt;/li&gt;
  &lt;li&gt;13:5   Expected space(s) after “if”&lt;/li&gt;
  &lt;li&gt;13:19  ‘useComment’ is missing in props validation&lt;/li&gt;
  &lt;li&gt;14:7   Unexpected alert&lt;/li&gt;
  &lt;li&gt;14:13  Unexpected string concatenation&lt;/li&gt;
  &lt;li&gt;14:31  Strings must use singlequote&lt;/li&gt;
  &lt;li&gt;21:5   Unexpected var, use let or const instead&lt;/li&gt;
  &lt;li&gt;25:39  Unknown property ‘class’ found, use ‘className’ instead&lt;/li&gt;
  &lt;li&gt;26:47  There should be no space after ‘{‘&lt;/li&gt;
  &lt;li&gt;26:60  ‘useComment’ is missing in props validation&lt;/li&gt;
  &lt;li&gt;26:88  There should be no space before ‘}’&lt;/li&gt;
  &lt;li&gt;28:6   Missing semicolon&lt;/li&gt;
  &lt;li&gt;32:2   Newline required at end of file but not found&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;헉, 무려 17개의 경고메시지가 발생합니다. 100% 완벽하진 않을꺼라 생각했지만 이 짧은 소스에 이렇게 많은 경고가 뜨다니 놀랍습니다. 이제 경고를 수정해 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;import React, { Component, PropTypes } from &amp;#39;react&amp;#39;;

// form
class Comment extends Component {
  constructor(props) {
    super(props);

    this.state = {
      msg: &amp;#39;&amp;#39;,
    };
  }
  componentDidMount() {
    this.submitBtn = this.refs.submitBtn;
  }
  onSubmit() {
    if (this.props.useComment) {
      alert(`${this.state.name}님이 댓글을 작성하였습니다.`);
    }
  }
  render() {
    const onChange = e =&amp;gt; this.setState({ msg: e.target.value });

    return (
      &amp;lt;form method=&amp;quot;post&amp;quot; className=&amp;quot;form-horizontal&amp;quot; onSubmit={this.onSubmit.bind(this)}&amp;gt;
        &amp;lt;input name=&amp;quot;msg&amp;quot; type=&amp;quot;text&amp;quot; className=&amp;quot;form-control&amp;quot; onChange={onChange.bind(this)} value={this.state.msg} /&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot; ref=&amp;quot;submitBtn&amp;quot;&amp;gt;{this.props.useComment ? &amp;#39;글쓰기&amp;#39; : &amp;#39;댓글불가&amp;#39;}&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    );
  }
}

Comment.propTypes = {
  useComment: PropTypes.bool.isRequired,
};

export default Comment;
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/e89afea3a71ec0151926e24a719d2f5f.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;수정해서보니 엄청나게 바뀐부분은 없지만 왠지 퀄리티가 높아보입니다. 코딩 컨벤션은 단순히 띄어쓰기를 가이드 하는 것 말고도 React의 props validation 코드가 빠졌다는 걸 알려주고 ES6에 추가된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;template string&lt;/a&gt;기능도 알려줍니다. 처음 React를 하면 많이 실수하는 className대신 class를 적은 것도 지적해줍니다.&lt;/p&gt;

&lt;p&gt;그럼 Javascript 코드가 눈에 잘 안들어오는 분들을 위해 아주 심플한 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;scss&lt;/a&gt; 코드도 살펴봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;.post {
  .name {
    color:#ffffff;

    &amp;amp;.admin {
      background-color:rgba(255,0,0,0.5);

      &amp;amp;.active {
        font-weight:bold;
      }
    }
  }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/2e70ea5d7972c7dd388b25f6f03a5608.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;이번 예제는 그리 길지도 않아서 크게 문제 없어보이는데… &lt;a href=&quot;https://github.com/brigade/scss-lint&quot;&gt;scss-lint&lt;/a&gt;를 돌려봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
  &lt;li&gt;ColorVariable: Color literals like ‘#ffffff’ should only be used in variable declarations; they should be referred to via variable everywhere else.&lt;/li&gt;
  &lt;li&gt;HexLength: Color ‘#ffffff’ should be written as ‘#fff’&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterComma: Commas in function arguments should be followed by a single space&lt;/li&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
  &lt;li&gt;ColorVariable: Color literals like ‘rgba(255, 0, 0, 0.5)’ should only be used in variable declarations; they should be referred to via variable everywhere else.&lt;/li&gt;
  &lt;li&gt;LeadingZero: ‘0.5’ should be written without a leading zero as ‘.5’&lt;/li&gt;
  &lt;li&gt;NestingDepth: Nesting should be no greater than 3, but was 4&lt;/li&gt;
  &lt;li&gt;SpaceAfterPropertyColon: Colon after property should be followed by one space&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11개의 경고메시지가 발생했습니다. -ㅁ-;; 내가 작성한 코드가 그렇게도 일반적인 표준과 거리가 멀단말인가…?! 라고 생각하면서 일단 수정해 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;$white-color: #fff;
$admin-red-bg-color: rgba(255, 0, 0, .5);

.post {
  .name {
    color: $white-color;

    &amp;amp;.admin {
      background-color: $admin-red-bg-color;
    }

    &amp;amp;.active {
      font-weight: bold;
    }
  }
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/a4f80ad19a443ed7cac29f7e3f6d32c1.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;전과 비교하여 소스가 깔끔해 보이나요? 스페이스 규칙은 물론 스타일의 순서와 내부 클래스의 깊이까지 제한해줍니다. sass/scss를 처음 사용하면 내부 클래스의 깊이가 마구 늘어나다가 나중에 범용적으로 적용하기 어려운 경우를 발견하곤 하는데 이러한 문제를 미리 방지해줍니다.&lt;/p&gt;

&lt;p&gt;사람마다 원하는 스타일이 다르고 이게 더 낫다고 생각하는 부분도 있지만, 정말 그런 스타일이 유지보수와 협업에 도움이 되는지 생각해봐야 합니다. 혼자 작성하는 코드가 아니라면 &lt;strong&gt;자신의 스타일&lt;/strong&gt; 보다는 대부분이 괜찮다고 하는 &lt;strong&gt;모두의 스타일&lt;/strong&gt;에 맞추는 것이 유지보수와 협업에 도움이 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;eslinthttpeslintorg-&quot;&gt;&lt;a href=&quot;http://eslint.org/&quot;&gt;eslint&lt;/a&gt; 적용하기&lt;/h2&gt;

&lt;p&gt;실제로 lint를 어떻게 적용하는지, 어떠한 옵션이 있는지 알아보기 위해 javascript lint툴인 eslint를 설치하고 사용하는 방법을 알아봅니다. 굳이 javascript lint툴을 가지고 예를 든 이유는 javascript가 개발자들 마다 가장 스타일 차이가 많이 나는 언어라고 생각하기 때문입니다. linter들의 사용법과 옵션은 비슷비슷하기 때문에 eslint를 살펴보면 다른 언어의 linter도 적용하기 쉬울거라 생각됩니다.&lt;/p&gt;

&lt;h3 id=&quot;eslint-&quot;&gt;eslint 설치&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;eslint는 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;로 작성된 프로그램입니다. 먼저, nodejs를 설치후에 eslint를 설치합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install -g eslint&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;초기설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;설치후엔 eslint 초기 설정을 진행합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm init
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint --init

? How would you like to configure ESLint? Answer questions about your style
? Are you using ECMAScript 6 features? Yes
? Are you using ES6 modules? Yes
? Where will your code run? Browser
? Do you use CommonJS? No
? Do you use JSX? Yes
? Do you use React Yes
? What style of indentation &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Spaces
? What quotes &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;strings? Single
? What line endings &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Unix
? Do you require semicolons? Yes
? What format &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you want your config file to be &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;? JavaScript&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;몇가지 옵션을 물어보면서 자동으로 필요한 plugin을 추가하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc.js&lt;/code&gt;라는 설정파일을 만들어줍니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;env&amp;quot;: {
        &amp;quot;browser&amp;quot;: true,
        &amp;quot;es6&amp;quot;: true
    },
    &amp;quot;extends&amp;quot;: &amp;quot;eslint:recommended&amp;quot;,
    &amp;quot;installedESLint&amp;quot;: true,
    &amp;quot;parserOptions&amp;quot;: {
        &amp;quot;ecmaFeatures&amp;quot;: {
            &amp;quot;experimentalObjectRestSpread&amp;quot;: true,
            &amp;quot;jsx&amp;quot;: true
        },
        &amp;quot;sourceType&amp;quot;: &amp;quot;module&amp;quot;
    },
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ],
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [
            &amp;quot;error&amp;quot;,
            4
        ],
        &amp;quot;linebreak-style&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;unix&amp;quot;
        ],
        &amp;quot;quotes&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;single&amp;quot;
        ],
        &amp;quot;semi&amp;quot;: [
            &amp;quot;error&amp;quot;,
            &amp;quot;always&amp;quot;
        ]
    }
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/29778c2ab4c2c4f94f29ceabe9416ae3.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;대부분의 linter는 위와 같이 세부적인 설정파일을 제공하고 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;sub&gt;dot&lt;/sub&gt;으로 시작하여 보이지 않는 파일로 관리합니다. linter에서 체크하는 규칙중에 현재 코드에 적용이 어려운 규칙등은 무시하게 설정할 수 있어 일단 툴을 돌려보고 수정하는데 무리가 있는 규칙은 제외하거나 바꾸면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Airbnb 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기본적인 옵션은 범용적으로 설정되기 때문에 회사마다 특성에 맞게 조금씩 규칙을 고쳐서 사용합니다. Airbnb 또한 자체적인 규칙을 설정하여 사용중인데 이를 &lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;오픈소스&lt;/a&gt;로 공개하였고 React와 ES6를 사용하는 프로젝트에 적절한 규칙을 제공합니다. Airbnb룰을 적용해봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev eslint-config-airbnb eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y eslint&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;,
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ]
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/57c7ba78118f3afab25dbbb9b3276d81.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;Airbnb에서 만든 플러그인을 추가하고 lint 설정파일을 바꿨습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;나만의 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Airbnb규칙중에 &lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md&quot;&gt;react/jsx-no-bind&lt;/a&gt;규칙은 빼는게 현재 상황에 적당할 것 같아 해당 규칙을 뺍니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;module.exports = {
    &amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;,
    &amp;quot;plugins&amp;quot;: [
        &amp;quot;react&amp;quot;
    ],
    &amp;quot;rules&amp;quot;: {
    	&amp;quot;react/jsx-no-bind&amp;quot;: &amp;quot;off&amp;quot;
    }
};&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/1b7f686371897d96823f743f1b22c496.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;inline 규칙적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가끔 특정 코드에서만 규칙을 따로 적용하고 싶을 수 있습니다. 이럴땐 주석을 이용한 inline 규칙을 적용하면 됩니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;/* eslint no-class-assign: &amp;quot;off&amp;quot; */
PostForm = reduxForm({
  form: &amp;#39;msg&amp;#39;,
})(PostForm);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/308dfda948a55be8e8534aa24a3b71b1.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;실행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이제 설정은 거의 끝났으니 실제로 lint를 돌려봅니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.jsx&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;주르륵주르륵 에러가 뜹니다. ㅠㅠ 이제 고치기만 하면 되겠네요…&lt;/p&gt;

&lt;h2 id=&quot;gulp-&quot;&gt;Gulp 설정&lt;/h2&gt;

&lt;p&gt;linter를 단독으로 사용하는 경우는 이런 샘플을 보여줄 때 빼고는 아마 거의 없을겁니다. 왜냐면 개발자들은 게을러서 파일을 저장하거나 수정할 때 자동으로 체크하게 해줘야 합니다. 테스크 자동화 툴인 &lt;a href=&quot;http://gulpjs.com/&quot;&gt;gulp&lt;/a&gt;의 watch 기능을 이용하여 자동으로 체크하도록 설정해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;설치&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --global gulp-cli
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev gulp
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;npm install --save-dev gulp-eslint&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;대부분의 linter는 &lt;a href=&quot;https://github.com/adametry/gulp-eslint&quot;&gt;gulp-eslint&lt;/a&gt;와 같이 gulp용 plugin을 제공합니다. 이제 gulpfile을 설정합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;var gulp = require(&amp;#39;gulp&amp;#39;);
var eslint = require(&amp;#39;gulp-eslint&amp;#39;);

gulp.task(&amp;#39;lint&amp;#39;, function() {
  return gulp.src([&amp;#39;**/*.{js,jsx}&amp;#39;,&amp;#39;!node_modules/**&amp;#39;])
    .pipe(eslint())
    .pipe(eslint.format())
    .pipe(eslint.failAfterError());
});

gulp.task(&amp;#39;watch&amp;#39;, function() {
	gulp.watch(&amp;#39;**/*.{js,jsx}&amp;#39;, [&amp;#39;lint&amp;#39;]);
});

gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;watch&amp;#39;], function () {
});
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/65a15aea86bc2582e3cca337491f5bbe.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;실행&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;gulp&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;node_modules 디렉토리를 제외하고 js와 jsx파일을 수정하면 자동으로 eslint를 실행하고 결과를 알려줍니다. 이런식으로 scss-lint등 원하는 linter를 추가할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ide-&quot;&gt;IDE 플러그인&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;SublimeText3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SublimeText3에 lint를 적용하려면 &lt;a href=&quot;http://www.sublimelinter.com/en/latest/&quot;&gt;SublimeLinter&lt;/a&gt;를 설치합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;커멘트창을 열고(cmd+shift+p on Mac OS X, ctrl+shift+p on Linux/Windows)&lt;/li&gt;
  &lt;li&gt;Package Control: Install Package 를 선택합니다.&lt;/li&gt;
  &lt;li&gt;SublimeLinter와 SublimeLinter-contrib-eslint를 설치합니다.&lt;/li&gt;
  &lt;li&gt;설치가 끝나면 재시작합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/sublimetext3.png&quot; alt=&quot;sublime text3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽에 빨간색점이 보이고 하단에 에러문구가 보입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WebStorm&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;IntelliJ의 WebStorm IDE에는 ESLint가 이미 내장되어 있습니다. 설정에서 활성화하면 바로 적용됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/webstorm_eslint.png&quot; alt=&quot;WebStorm ESLint&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Languages &amp;amp; Frameworks &amp;gt; Javascript &amp;gt; Code Quality Tools &amp;gt; ESLint&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/webstorm_eslint_view.png&quot; alt=&quot;WebStorm ESLint Check&quot; /&gt;&lt;/p&gt;

&lt;p&gt;활성화하면 editor 오른쪽에 빨간색 라인이 보이고 마우스 오버하면 에러문구가 보입니다.&lt;/p&gt;

&lt;h2 id=&quot;ci&quot;&gt;CI&lt;/h2&gt;

&lt;p&gt;linter를 사용하는 법은 거의 끝났고, 이제 CI에 적용할때입니다. 소스를 배포하고 빌드할 때마다 자동으로 lint를 체크하고 잘못된 점을 알려서 개발자를 압박해야겠죠. &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt;를 사용한다면 &lt;a href=&quot;https://github.com/jenkinsci/checkstyle-plugin&quot;&gt;checkstyle plugin&lt;/a&gt;을 사용할 수 있습니다. &lt;a href=&quot;http://checkstyle.sourceforge.net/&quot;&gt;Checkstyle&lt;/a&gt;은 원래 java파일을 체크할때 사용하던 포멧인데 다른 툴에서도 보통 같은 포멧을 제공합니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint -f checkstyle &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js &amp;gt; checkstyle.xml&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;eslint에서는 -f 옵션을 통해 output 포멧을 지정할 수 있는데 checkstyle을 내장하고 있습니다. Jenkins에서 checkstyle을 설정하면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-07-11-coding-convention/checkstyle.png&quot; alt=&quot;Jenkins Checkstyle&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;코딩 컨벤션을 문법단계까지 적용한 대표적인 언어가 &lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt;과 &lt;a href=&quot;https://golang.org/&quot;&gt;Go&lt;/a&gt;라고 생각합니다. 처음에 python이 블록 구분을 중괄호가 아닌 들여쓰기로 한다는 이야기를 들었을땐 엄청난 충격적이였습니다. &lt;em&gt;아니 python은 이제 블록 줄바꿈가지고 개발자들끼리 싸우지 않아도 되는건가?!&lt;/em&gt; 이후에 Go를 접했을때도 Go는 줄을 바꾸지 않고 중괄호를 같은 줄에 붙이는 걸 강제하였고 언어 스펙도 굉장히 간결하여 다시 한번 충격적이였습니다. Go는 더 나아가 gofmt라는 코드 스타일 검사툴을 기본 설치판에 포함하여 대부분의 코드 스타일을 비슷하게 만들어 버렸습니다. 이때문에 Go 개발자들은 다른 사람의 소스를 이해하는게 쉽다고 느껴져 좋은 소스를 참고하고 배우는게 편하다는 이야기를 자주 합니다.&lt;/p&gt;

&lt;p&gt;Linter를 적극적으로 사용할 수록 굉장히 빡빡한 느낌이 있습니다. Linter는 결국 코드를 잘 관리하여 최종적인 생산성을 높이자는 건데 오히려 방해가 되고 속도가 더뎌지는 느낌을 받을 수 있습니다. 따라서 가장 중요한 건 무조건적으로 철저하게 지키는 것이 아닌 &lt;strong&gt;언제 어길지를 아는 것&lt;/strong&gt;이라고 생각합니다. 코딩 컨벤션을 적용한 코드가 오히려 더 눈에 안 들어오고 해석이 어렵다거나 기존에 적용된 일관성을 코딩 컨벤션이 오히려 어기는 경우는 전부다 바꾸는 시간을 고려하여 프로젝트만의 규칙을 만들고 느슨하게 설정하는 것이 낫다고 생각합니다. 그리고 간단한 프로토타입을 만드는데 까지 무조건적으로 적용하는건 어렵겠죠.&lt;/p&gt;

&lt;p&gt;Linter를 시작으로 다양한 분석툴을 적용하고 테스트코드를 작성하다 보면 지금 당장 개발 속도가 느린 것 같지만 결국 미래의 나와 우리가 행복해지는 길이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;Linter를 적용하여 개발한 홈쇼핑처럼에서 이번에 출시한 까르보돈까스 절찬리 판매중이니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 갓 대학을 졸업한 의지넘치는 신입부터 고오급 경력 개발자까지 모두 환영합니다 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>왜 React와 서버 사이드 렌더링인가?</title>
   <link href="http://subicura.com/2016/06/20/server-side-rendering-with-react.html"/>
   <updated>2016-06-20T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/06/20/server-side-rendering-with-react</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;2016/12/29 수정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;AngularJS의 단점으로 적었던 IE8지원은 React 또한 15.0.0에서 지원 중단되었습니다. ;ㅁ;&lt;/li&gt;
  &lt;li&gt;AngularJS의 단점으로 적었던 비표준 태그는 data-* 형태로 대체 가능합니다.&lt;/li&gt;
  &lt;li&gt;Angular v2 등장에 따른 v1 지원 중단 우려는 큰 문제는 없어보입니다. (최근 12/23일 업데이트)&lt;/li&gt;
  &lt;li&gt;Angular2는 TypeScript가 메인이긴 하나 자바스크립트 또는 Dart로 작성가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/fried_things.jpg&quot; alt=&quot;튀김과불맛쌀떡볶이x홈쇼핑처럼&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt; 4번째 상품인 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/25/&quot;&gt;튀김&lt;/a&gt;을 기름에 튀기면서 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;를 적용하느라 고생했던 순간이 떠올라 React와 서버 사이드 렌더링 적용과정을 정리해봅니다. 여기서는 &lt;strong&gt;어떻게&lt;/strong&gt;보다는 &lt;strong&gt;왜&lt;/strong&gt;에 대해 설명합니다.&lt;/p&gt;

&lt;p&gt;현재 홈쇼핑처럼의 커머스 백엔드는 PHP로 만든 Magento를 사용하고 있고 프론트엔드는 일부 화면에서 React를 사용하고 있습니다. 웹서버에 v8js extention을 설치하여 서버 사이드 렌더링을 지원하고 있습니다. 그리고 홈쇼핑처럼에서 사용중인 채팅은 &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;로 만든 별도의 서비스로 분리하여 운영하고 있고 관리자 페이지 프론트엔드는 역시 React에 &lt;a href=&quot;https://github.com/cowboyd/therubyracer&quot;&gt;therubyracer&lt;/a&gt;라는 V8 javascript interpreter를 이용하여 서버 사이드 렌더링을 지원하고 있습니다. 이전에 작업했던 .NET 프로젝트에도 프론트엔드는 React에 &lt;a href=&quot;http://reactjs.net/&quot;&gt;ReactJS.NET&lt;/a&gt;를 이용하여 서버 사이드 렌더링을 지원하였습니다.&lt;/p&gt;

&lt;p&gt;백엔드는 프로젝트마다 달라도 프론트엔드는 React에 서버사이드 렌더링을 지원하는 방식으로 통일하고 있습니다. React가 뭐길래, 서버사이드 렌더링이 뭐가 좋길래 이런 결정을 한걸까요?&lt;/p&gt;

&lt;p&gt;먼저, 자바스크립트를 이용한 웹 개발의 발전방향을 살펴봅니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax--&quot;&gt;ajax가 없던 시절&lt;/h2&gt;

&lt;p&gt;지금은 Javascript를 이용하여 동적인 웹페이지를 자연스럽게 만들고 있지만 10년전 &lt;a href=&quot;https://en.wikipedia.org/wiki/Ajax_(programming)&quot;&gt;ajax&lt;/a&gt;가 등장하기 전에는 서버에서 전체 HTML을 만드는 방식이 일반적이였습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;?php
$servername = &amp;quot;localhost&amp;quot;;
$username = &amp;quot;username&amp;quot;;
$password = &amp;quot;password&amp;quot;;
$dbname = &amp;quot;myDB&amp;quot;;

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn-&amp;gt;connect_error) {
    die(&amp;quot;Connection failed: &amp;quot; . $conn-&amp;gt;connect_error);
} 

$sql = &amp;quot;SELECT id, firstname, lastname FROM MyGuests&amp;quot;;
$result = $conn-&amp;gt;query($sql);

if ($result-&amp;gt;num_rows &amp;gt; 0) {
    // output data of each row
    while($row = $result-&amp;gt;fetch_assoc()) {
        echo &amp;quot;id: &amp;quot; . $row[&amp;quot;id&amp;quot;]. &amp;quot; - Name: &amp;quot; . $row[&amp;quot;firstname&amp;quot;]. &amp;quot; &amp;quot; . $row[&amp;quot;lastname&amp;quot;]. &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
    }
} else {
    echo &amp;quot;0 results&amp;quot;;
}
$conn-&amp;gt;close();
?&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/427978fd79fa14e6cfd70644f6a5f4bd.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;조금 복잡해보이고 뷰에 여러가지 로직이 들어가 있지만 지금도 어디선가는 사용하고 있는 전통적인 개발 방식입니다. 이때까지만 해도 javascript는 일부 고오급 웹 개발자들이 사용하는 언어였고 웹페이지의 컨텐츠보다는 무언가를 꾸며주거나 화려한 느낌을 주는데 사용했습니다.&lt;/p&gt;

&lt;h2 id=&quot;ajax-&quot;&gt;ajax의 등장&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/google-auto-complete.png&quot; alt=&quot;Google 추천검색어&quot; title=&quot;Google 추천검색어&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;처음 ajax가 등장했을때 충격은 정말 엄청났습니다. Google의 추천 검색어 따라하기가 유행했는데 검색어 입력란에 &lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;을 입력하면 추천 검색어가 실시간으로 보였습니다. 이게 정말 웹에서 가능하다니?!&lt;/p&gt;

&lt;p&gt;그때는 Javascript의 J도 모르고 눈 내리는 소스를 복사 붙여넣기하며 좋아하던 시절이라 그 충격은 더 했습니다. 구글이 대중적으로 실시간 추천검색어 기능을 선보였고 곧 수많은 포털, 웹사이트에서 따라하기 시작합니다. 비슷한 시기에 &lt;a href=&quot;http://prototypejs.org/&quot;&gt;prototype.js&lt;/a&gt;와 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;가 나왔고 웹 세계는 대 Javascript 시대를 맞이하게 됩니다.&lt;/p&gt;

&lt;p&gt;Javascript 라이브러리를 안쓰는 페이지는 없었고 ajax를 이용한 동적인 컨텐츠 구성도 일반적으로 사용되기 시작했습니다. 하지만 제대로 된 표준이라던가 프레임워크는 없었고 이를 화면에서 표현하기 위해 다양한 방법이 등장합니다.&lt;/p&gt;

&lt;h2 id=&quot;javascript--&quot;&gt;Javascript 뷰 렌더링&lt;/h2&gt;

&lt;p&gt;예전에 뷰는 서버 프로그램에 찰싹 달라붙어 있었지만 이제 Javascript를 이용하여 동적으로 HTML을 만드는 시대가 왔습니다. 동적으로 HTML을 만드는 방법을 하나씩 알아봅니다.&lt;/p&gt;

&lt;h3 id=&quot;string-concatenation&quot;&gt;String concatenation&lt;/h3&gt;

&lt;noscript&gt;&lt;pre&gt;$(&amp;#39;#profile&amp;#39;).append(&amp;#39;&amp;lt;p&amp;gt;&amp;#39; + data.name + &amp;#39;님 안녕하세요.&amp;lt;/p&amp;gt;&amp;#39;);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/dc7630ef6346f5108e2c5fc789615387.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;가장 쉬운방법은 HTML을 string을 붙이고 붙이고 붙여서 특정 DOM에 넣는 것 입니다. 굉장히 심플하고 잘 동작합니다. 그런데 쓰다보니 몇가지 문제가 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;data.name&lt;/code&gt;에 태그(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;)가 들어갈 수 있어 XSS&lt;sub&gt;Cross-Site Scripting&lt;/sub&gt; Injection에 노출되어 있습니다. 이를 보완한 좀더 복잡해진 예를 봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;var htmlString = &amp;#39;&amp;#39;;
htmlString += &amp;#39;&amp;lt;div&amp;gt;&amp;#39;;
htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;#39; + data.name.replace(&amp;#39;&amp;lt;&amp;#39;, &amp;#39;&amp;amp;lt;&amp;#39;).replace(&amp;#39;&amp;gt;&amp;#39;, &amp;#39;&amp;amp;gt;&amp;#39;) + &amp;#39;&amp;lt;/p&amp;gt;&amp;#39;;
if (data.image) {
  htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;&amp;#39; + data.image.replace(&amp;#39;&amp;lt;&amp;#39;, &amp;#39;&amp;amp;lt;&amp;#39;).replace(&amp;#39;&amp;gt;&amp;#39;, &amp;#39;&amp;amp;gt;&amp;#39;) + &amp;#39;&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;#39;;
} else {
  htmlString += &amp;#39;  &amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;/images/avatar.jpg&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;#39;;
}
htmlString += &amp;#39;&amp;lt;/div&amp;gt;&amp;#39;;

$(&amp;#39;#profile&amp;#39;).append(htmlString);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/34bb24f334004572ddedc1b3162aaf56.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;음 점점 따옴표를 사용할때마다 신경이 곤두서고 동작은 하지만 뭐가 뭔지 모르게 되어 갑니다. 태그를 치환하는 부분을 실수로 빼먹기라도 하면 심각한 보안 문제가 발생할 수 있습니다. 뷰는 더 복잡해지고 상황은 더 심각해지고 HTML은 Javascript에 섞이며 퍼블리셔는 포기하고 우리는 더 많은 야근을 하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;template-engine&quot;&gt;Template engine&lt;/h3&gt;

&lt;p&gt;이러한 상황을 해결하기 위해 각종 템플릿 엔진이 등장하기 시작합니다. 제가 가장 오랜시간 애용했던 &lt;a href=&quot;http://olado.github.io/doT/index.html&quot;&gt;doT.js&lt;/a&gt;를 비롯해 twitter에서 만든 &lt;a href=&quot;http://twitter.github.io/hogan.js/&quot;&gt;hogan.js&lt;/a&gt;, &lt;a href=&quot;https://mustache.github.io/&quot;&gt;mustach&lt;/a&gt;, &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;handlebars&lt;/a&gt;등등등등 너무너무너무 다양한 템플릿 엔진이 (지금도 계속해서) 등장합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/template-engine.png&quot; alt=&quot;template engine compile&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각 라이브러리마다 파일 사이즈, 성능, 부가기능등의 차이가 있지만 하는 일은 동일합니다. 중괄호(&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;콧수염&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mustach&lt;/span&gt;&lt;/code&gt;)를 이용하여 반복문, 조건문 등을 넣은 템플릿파일을 만들고 Data를 연동하여 HTML을 생성합니다. 이러한 방법은 string을 붙이고 붙이고 붙이는 방법보다 훨씬 나은 환경을 보여줍니다.&lt;/p&gt;

&lt;p&gt;지금도 새로운 템플릿엔진이 계속해서 나오고 있고 동적으로 작은 view를 처리하거나 큰 프레임워크의 일부로 사용되고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;framework&quot;&gt;Framework&lt;/h2&gt;

&lt;p&gt;이러한 상황에서 javascript MVC(MV*?) framework들이 등장하게 됩니다. MVC? 왜???? 서버도 MVC로 짜기 바쁜데 왠 client side mvc?&lt;/p&gt;

&lt;p&gt;웹환경은 점점 더 리치해지고 고객들은 점점 더 편하게 웹 사이트를 이용하려고 합니다. 지메일이나 구글 캘린더와 같은 서비스는 일반적인 방식으로는 거의 짜기가 불가능할 정도로 복잡해졌습니다.&lt;/p&gt;

&lt;p&gt;이때, &lt;a href=&quot;http://backbonejs.org/&quot;&gt;Backbone.js&lt;/a&gt;가 엄청나게 히트합니다. 템플릿과 모델, 이벤트를 분리하여 작업할 수 있게 도와주었고 미니멀한 구조와 빠른 속도, 이해하기 쉬운 코드로 많은 인기를 얻습니다. 심플해서 좋았지만 심플하다는건 기능이 부족했다는 뜻이고 부족한 기능을 보완하기위해 marionette과 같은 Backbone 플러그인이 등장하여 같이 인기를 얻습니다. 이전보다는 많이 진일보했지만 아직 &lt;strong&gt;프레임워크&lt;/strong&gt;라고 부르기에는 기능이 조금 부족합니다.&lt;/p&gt;

&lt;p&gt;Backbone.js가 인기를 끌기 시작할때 &lt;strong&gt;제대로 된&lt;/strong&gt; 프론트엔드 프레임워크들이 등장합니다. &lt;a href=&quot;http://emberjs.com/&quot;&gt;Ember&lt;/a&gt;, &lt;a href=&quot;http://knockoutjs.com/&quot;&gt;Knockout&lt;/a&gt;등이 등장하였는데 예전부터 각자의 프로젝트에서 활용하고 있던 것들을 잘 정리하여 오픈소스로 공개하였습니다. 이러한 프레임워크들은 소스사이즈가 컸고 성능은 무겁고 기능은 복잡하고 러닝커브는 마구 올라갔습니다. 뭔가 좋아보이기는 하는데 쓰기엔 너무 무거워 보였고 굳이 프론트엔드를 MVC로 구성해야 하는 생각도 듭니다.&lt;/p&gt;

&lt;p&gt;그때 끝판왕 AngularJS가 나타납니다.&lt;/p&gt;

&lt;h2 id=&quot;angularjshttpsangularjsorg&quot;&gt;&lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;AngularJS는 React를 돋보이게 하기 위함이니 좀더 상세하게 설명합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/google-trend-angularjs.png&quot; alt=&quot;Google Trends&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AngularJS는 기존의 라이브러리나 프레임워크들과는 다르게 DOM을 조작하거나 제어하는 방식에 초점을 맞추지 않고 데이터의 변화에 초점을 맞추는 완전히 새로운 접근법을 사용합니다. 데이터에 초점을 맞추는 이러한 방식자체는 완전히 새로운게 아니였으나 정말 &lt;strong&gt;잘&lt;/strong&gt; 구현하여 사용하기 쉽게 공개한 겁니다. HTML에 작성해야 하는 코드는 조금 늘었지만 Javascript쪽 코드는 정말 놀라울정도로 단순해지고 저를 포함한 웹 프론트엔드 개발자들은 열광합니다.&lt;/p&gt;

&lt;p&gt;AngularJS의 장점을 구체적으로 살펴봅니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;div ng-controller=&amp;quot;myController&amp;quot;&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li ng-repeat=&amp;quot;talk in talks&amp;quot;&amp;gt;
      {{talk.name}}
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
angular.module(&amp;#39;myApp&amp;#39;, [])  
  .controller(&amp;#39;myController&amp;#39;, function($scope) {
    $scope.talks = [{name:&amp;#39;Kim&amp;#39;}, {name:&amp;#39;Lee&amp;#39;}, {name:&amp;#39;Jung&amp;#39;}]
  });
&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/1b2d30907d648357876834eddb205075.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;개발속도가 빠름&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특별한 추가 코드 없이 변수 할당만으로 양방향 데이터 바인딩 지원. get/set 함수 필요없음&lt;/li&gt;
  &lt;li&gt;별도의 템플릿 코드 분리 없이 뷰-데이터 연동. 기본 HTML이 곧 템플릿파일&lt;/li&gt;
  &lt;li&gt;DI&lt;sub&gt;Dependency Injection&lt;/sub&gt; 패턴사용. new같은 없고 그냥 인자로 넘기기만 하면됨&lt;/li&gt;
  &lt;li&gt;모듈화가 잘되어 있어 재사용이 용이함&lt;/li&gt;
  &lt;li&gt;플러그인이 엄청나게 많음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;유지보수가 쉬움&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Javascript 코드량이 적음&lt;/li&gt;
  &lt;li&gt;MVC 패턴이 잘 정리되어 있어 개발자간 코드가 비슷함&lt;/li&gt;
  &lt;li&gt;Controller, Directive, Filter, Service 모듈 구분이 명확&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;테스트 코드 작성 용이&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모듈별 테스트 작성이 쉬움. 튜토리얼도 테스트코드부터 시작함&lt;/li&gt;
  &lt;li&gt;데이터 로딩 시점이 비동기인 경우 E2E&lt;sub&gt;end-to-end&lt;/sub&gt; 테스트가 까다로운 경우가 있는데 &lt;a href=&quot;http://www.protractortest.org/&quot;&gt;Protractor&lt;/a&gt;를 사용하면 간단함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;프로젝트 분리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;백엔드를 API서버로 사용하여 프론트엔드와 완전히 분리할 수 있음&lt;/li&gt;
  &lt;li&gt;템플릿을 스크립트 태그나 Javascript에서 관리하지 않고 HTML을 그대로 사용하여 퍼블리셔 협업도 좋음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;구글이 관리함&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;오오, 구글에서 지메일, 캘린더 이런걸로 만드는건가??&lt;/li&gt;
  &lt;li&gt;망하진 않겠다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;장점이 어마어마 합니다. 그럼 단점을 알아볼까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AngularJS의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;속도가 느림. 특히 모바일&lt;/li&gt;
  &lt;li&gt;IE8지원안함 &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;러닝커브가 높음. 특히 Directive는 공부할수록 헬&lt;/li&gt;
  &lt;li&gt;비표준 태그 사용의 찝찝함. (대부분의 브라우져가 잘 처리하긴 하지만서도..)&lt;/li&gt;
  &lt;li&gt;페이지 깜빡임 이슈(&lt;a href=&quot;https://en.wikipedia.org/wiki/Flash_of_unstyled_content&quot;&gt;FOUC&lt;/a&gt;&lt;sub&gt;Flash of unstyled content&lt;/sub&gt;) &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;묘한 애니메이션 적용. 컨텐츠가 그려지는 시점을 정확하게 제어하기 어려워 애니메이션 적용이 쉽지 않음&lt;/li&gt;
  &lt;li&gt;SEO 이슈. 크롤링 봇은 컨텐츠 로딩전 빈페이지만 바라봄. title, meta tag도 처음 페이지것만 바라봄 &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;뒤로가기 하면 페이지 새로 로딩함. history API를 이용한 페이지 이동이 실제로는 페이지를 동적으로 로딩하는 구조. 스크롤도 최상단으로 이동 &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;외부 서비스 콜백처리
    &lt;ul&gt;
      &lt;li&gt;외부(페이스북, 구글, …) 로그인 후 돌아오는 페이지는 어떻게 처리하나?&lt;/li&gt;
      &lt;li&gt;이메일 회원가입 확인 페이지는 어떻게 하나?&lt;/li&gt;
      &lt;li&gt;결제 페이지 이동은 어떻게 하나?&lt;/li&gt;
      &lt;li&gt;결국 백엔드쪽에 뷰 페이지를 만들어야 하나?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt;와의 호환성
    &lt;ul&gt;
      &lt;li&gt;Angular 2는 완전히 다르다?!&lt;/li&gt;
      &lt;li&gt;기존 1버전은 곧 지원 중단?!&lt;/li&gt;
      &lt;li&gt;호환이 안된다? 업데이트가 안된다?!&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;만 지원한다? 그게 뭔데 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;del&gt;구글도 자기 서비스에 안씀&lt;/del&gt;
    &lt;ul&gt;
      &lt;li&gt;안쓰는 줄 알았는데 사용하고 있었네요 (강규현님 감사합니다)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.madewithangular.com/#/categories/google&quot;&gt;https://www.madewithangular.com/#/categories/google&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;엄청난 장점만큼 단점을 같이 보았는데 사실 대부분의 단점은 AngularJS의 단점이라기 보다는 &lt;strong&gt;웹앱&lt;/strong&gt;의 단점입니다. AngularJS는 앱용 웹에 적합한 프레임워크입니다. 가만보니 공식사이트 메인에 &lt;em&gt;HTML enhanced for web apps!&lt;/em&gt; 라고 적혀있습니다.&lt;/p&gt;

&lt;p&gt;이런 사실을 무시하고 일반적인 서비스에 쓴적이 있습니다. 속도가 느린건 핸드폰이 빠르게 발전하면서 해결될거라 믿었고 위에 나열한 단점은 열심히 꼼수(?)로 해결할 수 있을것 같았습니다.&lt;/p&gt;

&lt;p&gt;하지만, 결국 Angular 2가 공개되고 업데이트를 포기하게 됩니다. 여러가지 꼼수를 다시 적용하고 테스트하고 관리하기가 너무 힘들고 이미 이전 프로젝트도 꼼수로 인해 너덜너덜해진 상태입니다. 기술적으로 안되는건 없겠지만(&lt;del&gt;안되는 것도 있음&lt;/del&gt;) 결국 유지보수와 호환성에 문제가 생깁니다. 웹앱이 아니라면 브라우저가 알아서 해주는 것들을 웹앱이기 때문에 여러가지 추가적인 셋팅이 필요하게 됩니다.&lt;/p&gt;

&lt;p&gt;AngularJS는 좋지만, 웹앱용에 한정이고 성능이 크게 중요치 않은 어드민이나 내부서비스에 적합하다고 결론을 내립니다.&lt;/p&gt;

&lt;h2 id=&quot;reactjshttpsfacebookgithubioreact&quot;&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;ReactJS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;끝판왕(&lt;del&gt;인줄알았던&lt;/del&gt;) AngularJS말고 다른거 없나 찾고 있을때 거짓말처럼 페이스북에서 React를 발표합니다. React는 MVC프레임워크는 아니고 User Interface(View)를 만드는 라이브러리입니다. AngularJS처럼 MVC를 표방하는 것이 아니라 V(iew)에 집중하였고 훨씬 가벼웠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;React의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉽다. API가 몇개 없다. 일단 시작하긴 쉽다.&lt;/li&gt;
  &lt;li&gt;빠르다. 느린 DOM대신 Virtual DOM이라는 걸 이용.&lt;/li&gt;
  &lt;li&gt;단순하다. 2-way 바인딩 대신 1-way를 지원하고 Component 구성하기 쉬움.&lt;/li&gt;
  &lt;li&gt;서버 사이드 렌더링 지원이 좋음&lt;/li&gt;
  &lt;li&gt;ES6지원 좋음&lt;/li&gt;
  &lt;li&gt;일부페이지에 큰 수정없이 바로 적용할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 React는 갑자기 등장한 라이브러리가 아닙니다. 페이스북은 PHP를 사용하는 대표적인 회사로 PHP의 성능을 개선하기 위해 &lt;a href=&quot;http://hacklang.org/&quot;&gt;Hack&lt;/a&gt;이라는 언어를 자체적으로 만들고 &lt;a href=&quot;http://hhvm.com/&quot;&gt;HHVM&lt;/a&gt;이라는 가상머신도 만든 고오오오급 개발 회사입니다. 그리고 PHP의 문법을 변경하여 뷰 렌더링을 좀더 쉽게 한 &lt;a href=&quot;http://facebook.github.io/xhp-lib/&quot;&gt;XHP&lt;/a&gt;를 2010년에 발표하기도 하였습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;// php - string concatenation
$str = &amp;#39;&amp;lt;ul&amp;gt;&amp;#39;;
foreach($talks as $talk) {
  $str += &amp;#39;&amp;lt;li&amp;gt;&amp;#39; . $talk-&amp;gt;name . &amp;#39;&amp;lt;/li&amp;gt;&amp;#39;;
}
$str = &amp;#39;&amp;lt;/ul&amp;gt;&amp;#39;;

// xhp
$content = &amp;lt;ul /&amp;gt;;
foreach($talks as $talk) {
  $content-&amp;gt;appendChild(&amp;lt;li&amp;gt;{$talk-&amp;gt;name}&amp;lt;/li&amp;gt;);
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/85b3d6f54af7be72df149463f7b142bb.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;간단한 XHP 코드 샘플을 보면 PHP변수에 HTML태그를 바로 할당하여 사용하는 걸 볼 수 있습니다. XSS 이슈를 방지해주고 커스텀 태그를 쓸 수 있어 코딩이 더 단순해지고 쉬워집니다.&lt;/p&gt;

&lt;p&gt;태그를 바로 할당해서 사용할 수 있는 아이디어를 Javascript로 가져오기로 하고 2013년에 &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;를 만듭니다. 여기에 Virtual DOM이라는 걸 도입하여 DOM을 직접 계산하지 않고 내부적으로 빠르게 diff를 계산하는 알고리즘을 만들어냅니다. 마치 git을 사용하듯이 변경된 부분만 샤샤샤 찾아주어 빠르게 화면을 렌더링 할 수 있게 해줍니다. 첫 알고리즘은 O(n&lt;sup&gt;3&lt;/sup&gt;) 이였으나 결국 O(n)으로 완성합니다. ㄷㄷㄷ 게다가 React는 처음부터 서버 사이드 렌더링을 고려하여 설계합니다. 이런 짱짱맨..&lt;/p&gt;

&lt;p&gt;서버 사이드 렌더링을 지원하므로 웹앱때문에 생기는 단점이 거의 없고 컴포넌트를 이용한 구조는 개발속도를 빠르게 하고 유지보수를 용이하게 도와줍니다. 그리고 이미 facebook, instagram, airbnb, netflix, flipboard, dropbox등에서 사용하고 있습니다. 운영 환경에 사용할 수 있는 &lt;strong&gt;현실적인 끝판왕&lt;/strong&gt;이 등장했습니다.&lt;/p&gt;

&lt;p&gt;전체 구조를 바꾸지 않더라도 적용하기 쉽기 때문에 진행중인 서비스에서 일부 동적 로직이 필요한 페이지에 React를 사용하고 서버 사이드 렌더링을 적용하기로 합니다.&lt;/p&gt;

&lt;h2 id=&quot;isomorphic-javascript&quot;&gt;Isomorphic Javascript&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-javascript.png&quot; alt=&quot;Isomorphic Javascript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동형 자바스크립트라는 어색한 말로 해석되는 Isomorphic Javascript는 서버와 클라이언트가 같은 코드를 사용한다는 뜻입니다. 웹브라우져에서만 동작할 것 같았던 Javascript가 &lt;a href=&quot;https://developers.google.com/v8/&quot;&gt;V8엔진&lt;/a&gt;이 등장하고 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;가 나타나면서 서버에서도 Javascript를 사용하기 시작합니다. 클라이언트에서 동작하던 라이브러리를 서버에서 똑같이 돌릴수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/client-side-vs-server-side.png&quot; alt=&quot;Client vs Server rendering from airbnb&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;서버 사이드 렌더링의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;유저가 처음으로 컨텐츠를 보는 속도가 빨라짐&lt;/li&gt;
  &lt;li&gt;서버따로 클라이언트따로 작성하던 코드가 하나로 합쳐짐&lt;/li&gt;
  &lt;li&gt;SEO 적용도 OK&lt;/li&gt;
  &lt;li&gt;웹앱의 단점 대부분 없어짐!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react---&quot;&gt;React 서버 사이드 렌더링&lt;/h2&gt;

&lt;p&gt;React는 서버 사이드 렌더링을 염두에 두고 설계되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; 함수는 서버 사이드에서 사용하는 렌더링 함수입니다. 이 함수는 HTML을 생성하는데 클라이언트에서 동적으로 생성하는 것과 동일한 HTML을 생성합니다. 다른점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;data-react-checksum&lt;/code&gt;과 같은 attribute가 추가되었다는 점입니다.&lt;/p&gt;

&lt;p&gt;서버 사이드에서 생성된 HTML에는 이벤트 속성이 없기 때문에 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReactDOM.render()&lt;/code&gt;과 같은 클라이언트 사이드 렌더링을 다시 한번 수행해야 합니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;....&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;talkList&amp;quot;&amp;gt;&amp;lt;%= React.renderComponentToString(&amp;lt;TalkView /&amp;gt;); %&amp;gt;&amp;lt;/div&amp;gt;
  
  &amp;lt;script&amp;gt;
    // attach event
    React.renderComponent(&amp;lt;TalkView /&amp;gt;, document.getElementById(&amp;#39;talkList&amp;#39;));
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/6e9c87c3395f599a80da8e21ebbed822.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;&lt;strong&gt;두번 렌더링한다구요?&lt;/strong&gt; 네.&lt;/p&gt;

&lt;p&gt;두번째 렌더링을 할때 이미 서버 사이드 렌더링이 되어 있다면 attribute값을 보고 다시 렌더링 하지 않고 생성된 DOM에 오직 이벤트 속성만 추가합니다. checksum을 보고 판단하기 때문에 속도가 굉장히 빠릅니다.&lt;/p&gt;

&lt;p&gt;이러한 부분이 이미 React는 서버 사이드 렌더링을 염두에 두고 설계되었다는 점입니다.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;서버 사이드 렌더링 적용&lt;/h2&gt;

&lt;p&gt;그럼 실제로 서버 사이드 렌더링을 사용하려면 어떻게 해야 할까요?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 서버가 Node.js일때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-only.png&quot; alt=&quot;Node.js server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버가 Node.js일 경우 바로 React 코드를 실행할 수 있습니다. 그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;renderToString&lt;/code&gt; method를 실행하여 view에 그리면 됩니다. 와우!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. V8엔진 라이브러리를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-v8.png&quot; alt=&quot;Use V8 engine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서버가 Node.js가 아닐 경우 각 언어에서 제공하는 V8 engine을 사용할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;V8 engine을 만들고&lt;/li&gt;
  &lt;li&gt;React와 Component 소스를 전부 입력하여 컴파일을 한 뒤&lt;/li&gt;
  &lt;li&gt;Data를 인자로 실행하여 HTML 얻음&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;서버에 V8 engine만 설치되어 있다면 비교적 쉽게 구현할 수 있습니다. 특히 &lt;a href=&quot;https://github.com/reactjs/react-rails&quot;&gt;react-rails&lt;/a&gt;, &lt;a href=&quot;https://github.com/reactjs/react-php-v8js&quot;&gt;React-PHP-V8Js&lt;/a&gt;, &lt;a href=&quot;https://github.com/reactjs/React.NET&quot;&gt;React.NET&lt;/a&gt;는 React에서 직접 관리하는 라이브러리로 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 별도의 Node.js 서버 구축&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-backend.png&quot; alt=&quot;Node.js render server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;React 코드만 실행하고 렌더링하는 별도의 Node.js 서버를 띄우는 방법입니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;원래 웹서버로 요청이 들어오면&lt;/li&gt;
  &lt;li&gt;다시 Node.js 서버로 렌더링을 위한 정보(module, props JSON)를 HTTP request하고&lt;/li&gt;
  &lt;li&gt;Node.js 서버에서는 renderToString한 결과 string을 HTTP response&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;서버를 하나 더 관리해야 하는 번거로움과 HTTP 통신으로 인한 overhead가 발생하여 좋지 않은 방법이라고 생각하는데 의외로 사용하는 곳이 많은 것 같습니다. Airbnb에서 만든 &lt;a href=&quot;https://github.com/airbnb/hypernova&quot;&gt;hypernova&lt;/a&gt;를 이용하면  Express.js등을 사용할 필요 없이 렌더링 전용 서버를 구축할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 기존 서버가 API 구성하기 용이할때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-20-server-side-rendering-with-react/isomorphic-js-node-front.png&quot; alt=&quot;Node.js frontend server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존 서버가 API를 잘 제공하고 있다면 앞단에 Node.js를 두고 기존 서버를 API서버로 사용하는 방법이 있습니다. 이럴 경우 쿠키라던가 인증 토큰등을 추가로 관리하고 라우팅을 다시 셋팅해야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;현재 React를 즐겨 사용하고 있긴 하지만, 사실 언제 또 바뀔지 모릅니다. 최근에는 &lt;a href=&quot;https://www.meteor.com/&quot;&gt;meteor&lt;/a&gt;라는 걸출한 Javascript App Platform이 나와서 인기를 얻고 있습니다. 빠르게 변하는 웹환경만큼 새로운 라이브러리, 프레임워크도 계속해서 나옵니다. 왜 프론트엔드 개발자는 끊임없이 공부해야 하는가? 대체 언제 좀 편하게 예전에 배웠던거 슬렁슬렁 쓰면서 개발할 수 있을까? 라는 질문을 해보지만, 포기하고 적당히 하는 순간 빠르게 변하는 웹 세계에서 뒤쳐진다고 생각합니다.&lt;/p&gt;

&lt;p&gt;하지만, 공부하는 것과 운영환경에 적용하는 것은 다른 이야기로 React가 쉽고 간단한 라이브러리인 것처럼 묘사했지만 redux가 들어가고 좀 더 리치하게 사용하려고 하면 결코 쉽지 않다는걸 알게 됩니다. 그리고 많이 빨라졌다고 하지만 역시 라이브러리는 무겁고 아직 모바일 환경에서는 느릴 수 밖에 없습니다.&lt;/p&gt;

&lt;p&gt;결론적으로, 무조건 새로운 기술을 도입하는 것 보다는 정말 필요한지 고려해보고 도입하는 것이 중요합니다. 그리고 모든 페이지에 적용하려고 하지 말고 정말 필요한 일부 페이지에 적용하는 것이 속도면에서나 유지보수면에서나 호환성면에서 나은 결과를 보여줍니다. 1-2년이 지나면 결국 또 바뀌게 됩니다. 누가, 어떻게 업데이트 합니까?&lt;/p&gt;

&lt;p&gt;아무쪼록 React는 좀 오래가길 빌면서, 이번에 출시한 튀김 맛있으니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;주석&lt;/h3&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/fergaldoyle/angular.js-ie8-builds&quot;&gt;angular.js-ie8-build&lt;/a&gt;를 이용하면 IE8에서도 돌긴돔 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://docs.angularjs.org/api/ng/directive/ngCloak&quot;&gt;ng-cloak&lt;/a&gt;으로 어느정도 극복가능 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://prerender.io/&quot;&gt;prerender&lt;/a&gt;를 이용하면 어느정도 극복가능. meta tag 업데이트도 디렉티브를 만들면 됨 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;스크롤 위치를 기억했다가 뒤로가기라고 인지되면 다시 강제로 이동시켜주는 방법 있음 &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Go언어로 오픈소스 배송조회 서비스 만들기</title>
   <link href="http://subicura.com/2016/06/13/start-go-shipment-tracking-opensource.html"/>
   <updated>2016-06-13T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/06/13/start-go-shipment-tracking-opensource</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/yongman-pork.jpg&quot; alt=&quot;돈까스먹는용만이x칠리등심돈까스&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com&quot;&gt;홈쇼핑처럼&lt;/a&gt;에서 세번째로 런칭한 &lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/24/&quot;&gt;돈까스&lt;/a&gt;를 구매해 주시는 분들을 보면서 &lt;em&gt;아.. 받은 만큼 나도 뭔가 베풀어야겠구나&lt;/em&gt; 라는 생각에 배송조회 서비스를 오픈소스로 공개하는 과정을 정리해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;이라는 소셜코딩 플랫폼이 등장하면서 오픈소스에 참여할 수 있는 장벽이 많이 낮아졌습니다. 사용하던 오픈소스에서 버그를 발견하면 이슈를 살펴보고 수정한 소스를 슬쩍 풀 리퀘스트 하면 됩니다. 내가 작성한 소스가 커미터 마음에 들면 머지가 될 것이고 그렇게 우리는 오픈소스 컨트리뷰터가 되고 인류에 조금이라도 공헌한 사람이 됩니다.&lt;/p&gt;

&lt;p&gt;이러한 활동은 실력도 늘고 이력도 쌓고 재미도 느낄수 있습니다.&lt;/p&gt;

&lt;p&gt;이제 컨트리뷰터는 해봤으니 커미터가 되어봅시다. 아쉽게도 인기있는 오픈소스의 커미터는 꽤 많은 노력이 필요하고 고오급 개발자만 가능한 것 같습니다.
그럼 오픈소스 프로젝트를 직접 운영해보는건 어떨까요? 직접 오픈소스 프로젝트를 운영하면 커미터가 될 수 있고 리뷰어도 될 수 있고 프로젝트를 운영하면서 많은 노하우를 배울수도 있습니다. 아참, 오픈소스에 참여하면 IntelliJ IDE도 &lt;a href=&quot;https://www.jetbrains.com/buy/opensource/&quot;&gt;무료&lt;/a&gt;로 사용할 수 있고 JIRA도 &lt;a href=&quot;https://ko.atlassian.com/software/views/open-source-license-request&quot;&gt;무료&lt;/a&gt;로 쓸 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;어떤걸 만들까?&lt;/h2&gt;

&lt;p&gt;커머스에서 상품이 배송되면 배송상태를 추적해야합니다. 배송이 완료되면 구매확정 버튼을 누르게 할수도 있고, 배송정보 화면을 커스터마이징 할 수도 있습니다. 많은 배송업체가 API를 제공하지 않기 때문에 자동화하기가 까다롭습니다.(대체 다른 서비스들은 어떻게 추적하는거지…?) 그래서 결국 HTML을 파싱하는 방법을 선택합니다. 택배사와 송장번호를 입력하면 택배 사이트에 접속하여 HTML을 읽고 DOM을 파싱하여 정리된 포멧으로 택배정보를 조회하는 서비스를 만듭니다&lt;/p&gt;

&lt;p&gt;혹시 누가 만들어 놓지 않았을까 검색을 해보니 무료에 오픈소스로 공개된 건 없는것 같습니다. 질문글도 많고 원하는 사람도 있는거 같으니 오픈소스로 하기 딱인 프로젝트인것 같습니다. 아무도 안쓰는 기능을 만들면 힘들게 오픈해도 반응이 없어서 슬픔 ㅠ&lt;/p&gt;

&lt;h2 id=&quot;go-&quot;&gt;왜 서비스를 따로 분리하여 오픈소스에 Go로 만드는가?&lt;/h2&gt;

&lt;p&gt;배송조회 서비스는 기존 웹서비스에 하나의 액션으로 구현하는게 아니라 완전히 독립적으로 구현합니다. 몇가지 검토끝에 오픈소스로 공개하기로 하였고 가벼운 프로젝트라 Go언어로 구현합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;왜 &lt;a href=&quot;http://martinfowler.com/articles/microservices.html&quot;&gt;마이크로서비스&lt;/a&gt;인가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/monolith-microservice.png&quot; alt=&quot;monoliths / microservices&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마이크로서비스와 비교되는 방식으로 모놀리식이라는 서비스 개발 방법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 기능을 하는 하나의 큰 프로그램을 만드는 것 (우리가 잘알고 있고 매우 전통적인 개발스타일)&lt;/li&gt;
  &lt;li&gt;하나의 웹서버를 띄우면 회원가입도 되고 정보조회도 되고 메일도 보낼 수 있고 푸시도 보낼 수 있고 통계도 보고 안되는게 없음&lt;/li&gt;
  &lt;li&gt;하나의 작은 기능을 수정해도 전체를 재배포해야하고 특정 기능에 트래픽이 몰려도 전체 서비스를 여러개 띄워야함&lt;/li&gt;
  &lt;li&gt;코드가 커질수록 유지보수가 어려워짐&lt;/li&gt;
  &lt;li&gt;새로운걸 추가하고 싶은데 기존 로직/데이터에 어떤 문제가 있을지 모름&lt;/li&gt;
  &lt;li&gt;기존 기술(버전, 언어, 프레임웍)외에 새로운 기술을 쓰기 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그렇다면, 마이크로서비스 방식은 어떤걸까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최근 많이 사용되는 마이크로서비스는 기능별로 서비스를 분리하고 독립적으로 동작하게 구성하는 방식&lt;/li&gt;
  &lt;li&gt;기존 웹서비스에 영향을 미치지 않고 독립적으로 개발/유지보수가 가능&lt;/li&gt;
  &lt;li&gt;서버 확장, 배포, 적절한 기술사용, 조직구성등이 유연해짐&lt;/li&gt;
  &lt;li&gt;물론, 관리할게 많아지고 테스트가 어려워지는 단점존재&lt;/li&gt;
  &lt;li&gt;쪼개는 범위와 전략은 서비스에 따라 다름. 무조건 잘게 쪼갠다고 좋지 않음&lt;/li&gt;
  &lt;li&gt;아.. 우리서비스도 이런식인데? 라는 분은 용어는 처음이라도 이미 마이크로 서비스방식으로 개발하고 있을 확률이 높음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배송조회 서비스는 SMS나 Email서비스를 호출하듯이 독립적으로 분리하고 싶었습니다. 별도의 서버로 띄우고 REST API를 요청하여 정보를 가져오는 방식으로 구성합니다. 분리되서 좋고 나중에 다른 서비스에서 사용할 수도 있을겁니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;왜 오픈소스 인가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;처음 얘기한 개발자 스스로에게 도움이 되는 장점외에 배송조회의 특성상 오픈소스가 어울린다고 생각합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;택배사가 너무 많음. 우리나라만 20개정도에 외국까지 포함하면 100개가 넘음 &amp;gt; 혼자 모든 택배사의 배송정보를 구현할 순 없지만, 각자 필요한 사람들이 구현한다면?!&lt;/li&gt;
  &lt;li&gt;공식 API가 아닌 비공식적인 방법이라 언제 막힐지 모름 &amp;gt; 누군가 수정사항을 발견하고 개선해 나간다면?!&lt;/li&gt;
  &lt;li&gt;우체국 택배만 필요한 사람도 있을거고 CJ대한통운만 필요한 사람이 있듯이 각자의 필요에 따라 조금씩 수정 보완하여 개발하면 서로 윈윈!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;왜 &lt;a href=&quot;https://golang.org/&quot;&gt;Go&lt;/a&gt;인가&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/languages.png&quot; alt=&quot;languages&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구글이 개발한 가장 핫한 언어&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/GoUsers&quot;&gt;Go를 사용중인 회사들&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eng.uber.com/go-geofence/&quot;&gt;uber의 Go언어 사용사례&lt;/a&gt;, &lt;a href=&quot;http://blog.parse.com/learn/how-we-moved-our-api-from-ruby-to-go-and-saved-our-sanity/&quot;&gt;parse의 ruby에서 go로 전환사례&lt;/a&gt;(루비야 아프지마.. ㅠ)&lt;/li&gt;
  &lt;li&gt;코딩이 재밌고 속도도 괜찮음&lt;/li&gt;
  &lt;li&gt;정적언어지만 동적언어의 장점을 많이 가져옴&lt;/li&gt;
  &lt;li&gt;빠른 컴파일 빠른 실행&lt;/li&gt;
  &lt;li&gt;가비지컬랙션, 메모리 처리 안정성(nil 참조등), methods, interfaces, type assertions, reflection 지원&lt;/li&gt;
  &lt;li&gt;VM사용안함. 바로 실행가능한 바이너리 파일로 생성됨&lt;/li&gt;
  &lt;li&gt;심플하고 간결한 문법
    &lt;ul&gt;
      &lt;li&gt;클래스가 없고&lt;/li&gt;
      &lt;li&gt;상속이 없고&lt;/li&gt;
      &lt;li&gt;생성자가 없고&lt;/li&gt;
      &lt;li&gt;final이 없고&lt;/li&gt;
      &lt;li&gt;exception이 없고&lt;/li&gt;
      &lt;li&gt;annotation이 없고&lt;/li&gt;
      &lt;li&gt;generic이 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉽고 훌륭한 동시성 처리&lt;/li&gt;
  &lt;li&gt;code style을 강제하여 협업과 유지보수에 유리함&lt;/li&gt;
  &lt;li&gt;단점으로 검색이 어렵고 (구글에서 go를 입력해보자) 패키지관리 시스템이 npm, gem처럼 안정되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배송조회는 &lt;code class=&quot;highlighter-rouge&quot;&gt;http요청&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;html조회&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;parsing&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;응답&lt;/code&gt;하는 과정을 가진 굉장히 단순한 서비스입니다. 새로운 언어를 적용하고 배우는데 가장 좋은 방법은 프로젝트를 한번 해보는 것이고 굉장히 적절한 사이즈의 프로젝트입니다.&lt;/p&gt;

&lt;h2 id=&quot;go--1&quot;&gt;Go로 개발하기&lt;/h2&gt;

&lt;p&gt;Go언어에 대해 설명하는 포스트는 아니지만 Go를 처음 접하는분들을 위해 몇가지 팁을 공유합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공부
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://tour.golang.org/welcome/1&quot;&gt;A Tour of go&lt;/a&gt; - golang에서 공식으로 제공하는 방법으로 실습위주의 방법. 지하철 출퇴근때 하기 딱 좋음&lt;/li&gt;
      &lt;li&gt;공식문서(&lt;a href=&quot;https://golang.org/doc/code.html&quot;&gt;How to Write Go Code&lt;/a&gt;, &lt;a href=&quot;https://golang.org/doc/effective_go.html&quot;&gt;Effective Go&lt;/a&gt;) - 역시 지하철 출퇴근때 보면 좋음&lt;/li&gt;
      &lt;li&gt;책 - 이미 한글로 된 책이 꽤 많이 출간되었고 번역서가 아닌 책도 많아 대부분 내용이 딱딱하지 않고 읽기 좋음(&lt;a href=&quot;http://pyrasis.com/go.html&quot;&gt;무료공개서적&lt;/a&gt;도 있음)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;배송조회 오픈소스&lt;/a&gt; 참여 고고 - 직접 만들어보는게 배우기 가장 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDE
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA Community&lt;/a&gt; 추천&lt;/li&gt;
      &lt;li&gt;무료고 일반적으로 사용하기 쉽고 기능이 강력함&lt;/li&gt;
      &lt;li&gt;GO, File watchers plugin 설치 필수&lt;/li&gt;
      &lt;li&gt;File watcher는 파일을 저장할때마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;goimports&lt;/code&gt;를 실행하여 코드스타일을 정리함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;개발&lt;/h2&gt;

&lt;p&gt;이제 본격적으로 개발을 해 봅니다. 전체 소스는 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;에 공개되어 있습니다. 상세한 내용은 따로 설명하지 않고 어떤점을 주의하면서 개발하였는지 고민했던 과정을 정리합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;웹서버선택&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 다른 언어와 마찬가지로 다양한 웹프레임워크/미들웨어 오픈소스가 존재합니다. Ruby는 &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt;가 유명하고 Python은 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;가 유명하고 Node는 &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt;가 유명하지만 Go는 대표적인게 없고 아직까지 춘추전국시대입니다. 아마 계속해서 대표적인게 없을수도 있습니다. 이는 Go언어의 특성에 기인을 하는데..&lt;/p&gt;

&lt;p&gt;배송조회 서비스에서 선택한 웹서버 미들웨어는 &lt;a href=&quot;https://github.com/urfave/negroni&quot;&gt;negroni&lt;/a&gt;입니다. negroni는 스스로 할 수 있는게 거의 없는 굉장히 라이트한 미들웨어입니다. 라우팅도 다른 라이브러리를 조합해야 하고 응답 렌더링도 여러 라이브러리중에 하나를 선택해야 합니다. 당연히 디비접속관련이나 ORM도 포함하고 있지 않습니다. 하지만 굉장히 유연하게 &lt;strong&gt;조합&lt;/strong&gt;할 수 있도록 설계되어 있습니다.&lt;/p&gt;

&lt;p&gt;물론, Go언어도 풀프레임워크가 존재합니다. &lt;a href=&quot;https://github.com/go-martini/martini&quot;&gt;martini&lt;/a&gt;(8,521 stars)라던가 &lt;a href=&quot;https://github.com/revel/revel&quot;&gt;revel&lt;/a&gt;(6,895 stars)이 엄청난 인기를 끌고 있습니다. 그런데, negroni는 martini를 개발했던 &lt;a href=&quot;https://github.com/codegangsta&quot;&gt;codegangsta&lt;/a&gt;가 &lt;a href=&quot;https://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/&quot;&gt;martini 디자인 설계는 잘못&lt;/a&gt;이라고 말하고 개발한 미들웨어입니다. 풀프레임워크는 Go언어에 맞는 디자인 설계가 아니라고 생각한겁니다.&lt;/p&gt;

&lt;p&gt;실제로 지금도 다양한 형태의 라우팅 라이브러리가 개발되고 있습니다. 서로 이런기능이 좋고 속도가 좋다고 주장하고 있는데 negroni를 사용하면 이를 적용하기가 굉장히 간단합니다. 이번 프로젝트는 아이디도 간지나고 star 8,000개 프로젝트 따위 맘에 안들면 버릴수도 있고 실력도 고오급인 codegangsta가 주장하는데로 negroni를 선택합니다. 라우팅은 &lt;a href=&quot;https://github.com/gorilla/mux&quot;&gt;gorilla/mux&lt;/a&gt;, 렌더링은 &lt;a href=&quot;https://github.com/unrolled/render&quot;&gt;unrolled/render&lt;/a&gt;를 선택했습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 특별한 라이브러리를 설치하지 않아도 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;xxxx_test.go&lt;/code&gt;파일을 작성해서 테스트코드를 작성할 수 있습니다. 하지만 고오급 기능을 위해 &lt;a href=&quot;http://goconvey.co/&quot;&gt;goconvey&lt;/a&gt;를 사용합니다. UI도 이쁘고 코드도 간결합니다. Go언어는 나온지 얼마 되지도 않았는데 이런툴이 있다는게 놀랍..&lt;/p&gt;

&lt;p&gt;HTML을 파싱하는게 주임무이기 때문에 테스트코드는 직접 택배사 서버로 HTTP요청을 하지 않고 &lt;a href=&quot;https://github.com/jarcoal/httpmock&quot;&gt;HTTP mocking&lt;/a&gt;을 이용합니다. 목업을 사용하면 매번 실제서버로 요청을 날리지 않아도 되고 택배정보에 있는 개인 프라이버시도 숨길 수 있어 좋습니다. 샘플을 모으는게 관건!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주석&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go는 간단하게 주석을 작성하는걸 추천합니다. 구글이 개발해서 그런지 github에 소스를 공개하면 잽싸게 공식 문서 사이트에 소스와 주석을 추출하여 문서로 등록해버립니다.(ㄷㄷㄷ 크롤링하나?;) 배송조회서비스도 공식사이트(&lt;a href=&quot;https://godoc.org/&quot;&gt;godoc.org&lt;/a&gt;)에서 &lt;a href=&quot;https://godoc.org/github.com/purpleworks/delibird&quot;&gt;문서&lt;/a&gt;를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;코딩&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;웹서버과 테스트 방법을 정했으니 본격적으로 코딩을 합니다. HTML DOM을 조회하기 위해 &lt;a href=&quot;https://github.com/PuerkitoBio/goquery&quot;&gt;goquery&lt;/a&gt;를 사용했습니다. jQuery처럼 체이닝메소드를 지원하고 비슷한 API를 제공합니다.&lt;/p&gt;

&lt;p&gt;홈쇼핑처럼은 CJ대한통운만 이용하지만 사용자수 1위인 우체국택배도 구현하였습니다. 뭔가 Go 초보티가 많이 나는 소스지만 동작은 합니다. 일단 완성! 버전 0.1.0으로 등록합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;오픈소스로&lt;/h2&gt;

&lt;p&gt;어떤 프로젝트를 오픈소스화 한다는건 코딩이외에 추가적인 작업들을 필요로 합니다. 단순히 코드를 정리하고 공개하는것 외에 다른 개발자들의 참여를 유도하고 지속가능한 개발을 하기 위해 소스 품질에 신경을 써야 합니다.&lt;/p&gt;

&lt;p&gt;github은 &lt;a href=&quot;https://github.com/explore&quot;&gt;explore&lt;/a&gt;메뉴와 &lt;a href=&quot;https://github.com/trending&quot;&gt;trending&lt;/a&gt;메뉴를 제공합니다. 여기서 인기있는 오픈소스들은 어떤식으로 프로젝트를 구성하고 있는지 참고하면 많은 도움이 됩니다. 몇가지 프로젝트를 참고하여 오픈소스에 필요한 작업들을 해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이름/로고만들기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;개발자들의 코딩시간 대부분을 잡아먹는다는 이름짓기 시간입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;shipment tracking library&lt;/code&gt;보다는 뭔가 그럴듯한 이름을 짓는것이 좋습니다. 개인적으로 생명체가 마스코드인것이 성공하는 오픈소스라고 생각되는데 (github의 &lt;a href=&quot;https://octodex.github.com/&quot;&gt;octocat&lt;/a&gt;, golang의 &lt;a href=&quot;https://blog.golang.org/gopher&quot;&gt;gopher&lt;/a&gt;, docker의 &lt;a href=&quot;https://blog.docker.com/2013/10/call-me-moby-dock/&quot;&gt;moby dock&lt;/a&gt;등..) 그에 따라 적당히 동물을 가지고 이름을 지었습니다. 배송이니까 새가 생각났고 delivery와 bird의 조합인 &lt;strong&gt;Delibird&lt;/strong&gt;가 탄생하였습니다.&lt;/p&gt;

&lt;p&gt;이제 이름을 지었으니 로고를 만듭니다. 직접 그릴순 없으니 심플한 무료 아이콘이 많은 &lt;a href=&quot;https://icons8.com/#/ios&quot;&gt;icons8.com&lt;/a&gt;에서 새 아이콘을 하나 고르고 이쁘장한 색샘플을 모아놓은 &lt;a href=&quot;http://flatuicolors.com/&quot;&gt;flatuicolors.com&lt;/a&gt;에서 보라색계열을 하나 선택합니다. 폰트도 밋밋하지 않게 &lt;a href=&quot;https://www.google.com/fonts&quot;&gt;구글웹폰트&lt;/a&gt;에서 하나 고릅니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/delibird.logo.png&quot; alt=&quot;Delibird Logo&quot; title=&quot;Delibird Logo&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;짠, 포샵을 쓱싹하여 그럴싸한 이름에 로고가 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;문서화&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스 프로젝트는 문서가 중요합니다. 문서에 오픈소스를 소개하고 발전 의지를 잘 표현해야 다른 개발자를 참여하게 만들 수 있고 잘 운영되는 듯한 느낌을 줍니다.&lt;/p&gt;

&lt;p&gt;첫번째로 필요한 건 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/README.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt;&lt;/a&gt;파일 입니다. 이 파일은 github 첫화면에 보여지기 때문에 매우 중요합니다. 다음과 같은 항목을 기본으로 넣어줍니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본소개 - 어떤 프로젝트인지 소개&lt;/li&gt;
  &lt;li&gt;설치방법 - 바로 사용해볼 수 있도록 설치방법 소개&lt;/li&gt;
  &lt;li&gt;사용방법 - 샘플을 포함한 사용방법 소개&lt;/li&gt;
  &lt;li&gt;테스트방법 - 전체 테스트를 하는 방법 소개&lt;/li&gt;
  &lt;li&gt;기여방법 - 기여에 대한 설명&lt;/li&gt;
  &lt;li&gt;라이센스 - 라이센스 소개&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두번째로 필요한 건 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/LICENSE&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LICENSE&lt;/code&gt;&lt;/a&gt;파일입니다. 라이센스는 &lt;a href=&quot;http://choosealicense.com/&quot;&gt;다양한것들&lt;/a&gt;중에 선택할 수 있는데 가장 심플한 MIT 라이센스를 선택합니다.&lt;/p&gt;

&lt;p&gt;추가적으로 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/CHANGELOG.md&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CHANGELOG.md&lt;/code&gt;&lt;/a&gt;파일등을 추가합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;웹페이지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github은 &lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages/&quot;&gt;page&lt;/a&gt;라는 기능으로 정적인(html, image, css, js) 페이지를 무료로 만들수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;$ git checkout --orphan gh-pages
# Creates our branch, without any parents (it&amp;#39;s an orphan!)
Switched to a new branch &amp;#39;gh-pages&amp;#39;

$ git rm -rf .
# Remove all files from the old working tree
rm &amp;#39;.gitignore&amp;#39;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/56599a77c63ea929f413a7ab8052c61e.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;프로젝트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;gh-pages&lt;/code&gt;라는 브랜치를 만들고 html파일과 js,css파일등을 넣으면 끝입니다. 인터넷에서 무료 bootstrap landing 테마를 하나 다운받아 쓱싹 만들고 push합니다. github 조직이름이 purpleworks이고 프로젝트명이 delibird라면 &lt;a href=&quot;http://purpleworks.github.io/delibird/&quot;&gt;purpleworks.github.io/delibird&lt;/a&gt;라는 URL로 자동으로 연결됩니다. 이를 통해 README.md로는 부족한 내용을 보여줄 수 있습니다.&lt;/p&gt;

&lt;p&gt;여기서는 배송조회 테스트를 해볼수 있으면 좋을것 같아 테스트 폼을 넣었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Github 외부서비스 연동&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github은 다양한 외부 서비스와 연동이 가능합니다. 보통 github 저장소에 소스를 푸시하면 연동된 서비스가 소스를 테스트하고 결과를 알려줍니다. 공개 저장소는 무료로 제공하고 비공개 저장소에 대해서만 과금을 취하는 경우가 일반적입니다.&lt;/p&gt;

&lt;p&gt;유용한 서비스를 연동해 놓으면 코드 품질과 테스트 결과를 자동으로 알 수 있어 매우 유용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://travis-ci.org&quot;&gt;travis-ci&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 Test and Deploy 서비스&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/.travis.yml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.travis.yml&lt;/code&gt;&lt;/a&gt; 파일을 만들고 빌드 정보 입력&lt;/li&gt;
      &lt;li&gt;매 빌드마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;go test&lt;/code&gt;를 수행하고 결과를 알려줌&lt;/li&gt;
      &lt;li&gt;매 빌드가 끝나면 커버리지 정보를 coveralls로 전송하게 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coveralls.io/&quot;&gt;coveralls&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 코드 커버리지 서비스&lt;/li&gt;
      &lt;li&gt;travis-ci에서 정보를 전달하도록 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://codeclimate.com&quot;&gt;codeclimate&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;대표적인 코드품질 검사 서비스&lt;/li&gt;
      &lt;li&gt;다양한 항목으로 코드를 검사하여 학점처럼 점수를 매겨줌&lt;/li&gt;
      &lt;li&gt;Go는 아직 지원 안하는듯하여 다른 서비스 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goreportcard.com/&quot;&gt;goreportcard.com&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Go전용 코드품질 검사 서비스&lt;/li&gt;
      &lt;li&gt;go_vet, gocyclo, gofmt, golint, ineffassign, license, misspell등을 돌려 점수를 매겨줌&lt;/li&gt;
      &lt;li&gt;다행히 A+! (점수가 후한듯..)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;뱃지&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/github-badge.png&quot; alt=&quot;github badge&quot; /&gt;&lt;/p&gt;

&lt;p&gt;github은 상단에 각종 상태를 뱃지아이콘으로 보여주는 특별한 문화(?)가 있습니다. 라이센스라던가 문서링크, 코드 품질이나 커버리지, 빌드결과(테스트) 여부등이 있습니다. 이외에도 커뮤니티 게시판 링크라던가 채팅링크등 다양한 뱃지가 있습니다. &lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt;에서는 다양한 뱃지아이콘을 제공하고 있고 각 서비스마다 자체적으로 뱃지 링크를 제공하기도 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;license
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt; 라이센스 뱃지 사용&lt;/li&gt;
      &lt;li&gt;소스 저장소의 LICENSE파일을 보고 이미지 생성&lt;/li&gt;
      &lt;li&gt;https://img.shields.io/github/license/{id}/{project}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;godoc
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://godoc.org/&quot;&gt;godoc.org&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;Go프로젝트는 godoc이 자동으로 생성됨&lt;/li&gt;
      &lt;li&gt;https://godoc.org/github.com/{id}/{project}?status.svg&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드품질
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://goreportcard.com/&quot;&gt;goreportcard.com&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;소스 품질 결과를 A+, B, C등의 뱃지로 생성함&lt;/li&gt;
      &lt;li&gt;http://goreportcard.com/badge/{id}/{project}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커버리지
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://shields.io/&quot;&gt;shields.io&lt;/a&gt; coveralls 뱃지 사용&lt;/li&gt;
      &lt;li&gt;coveralls 결과를 뱃지로 생성함&lt;/li&gt;
      &lt;li&gt;http://img.shields.io/coveralls/{id}/{project}.svg&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빌드결과
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://travis-ci.org&quot;&gt;travis-ci&lt;/a&gt; 뱃지 사용&lt;/li&gt;
      &lt;li&gt;https://travis-ci.org/{id}/{project}.svg?branch=master&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;heroku&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.heroku.com/&quot;&gt;heroku&lt;/a&gt;는 소스빌드/배포/스케일이 자유로운 클라우드 서비스입니다. 다른 웹호스팅 서비스와 차별점은 소스를 업로드만 하면 알아서 웹서버를 띄워준다는 점입니다. 이게 무슨 말이냐면 Rails, Django, Express등은 고유한 파일 구조가 있습니다. 이러한 디렉토리구조나 파일의 확장자를 보고 &lt;a href=&quot;https://devcenter.heroku.com/articles/buildpacks&quot;&gt;알아서&lt;/a&gt; 서버를 띄운다는 신박한 서비스입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-13-start-go-shipment-tracking-opensource/heroku.png&quot; alt=&quot;heroku free plan&quot; title=&quot;heroku free plan&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;더 놀라운건 무료 플렌입니다. 30분간 요청이 없으면 자동으로 서버가 중지되고 그 이후 요청이 들어오면 다시 서버를 시작합니다. 예전에는 시간제한이 없었는데 이제 시간제한이 생겨서 아쉽긴 하지만 테스트로 배송조회 서비스를 켜놓기에는 부족함이 없습니다. heroku에 로그인을 하고 서버를 만든 후 github 소스를 연동하니 바로 서버가 뜹니다. 정말 뜹니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;a href=&quot;https://heroku.com/deploy?template=https://github.com/purpleworks/delibird&quot;&gt;
&lt;img src=&quot;https://www.herokucdn.com/deploy/button.svg&quot; alt=&quot;Heroku button&quot; title=&quot;Heroku button&quot; /&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;게다가, 누구든 쉽게 오픈소스로 부터 서버를 만들 수 있게 &lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-button&quot;&gt;heroku button&lt;/a&gt; 기능을 제공합니다. 소스폴더에 &lt;a href=&quot;https://github.com/purpleworks/delibird/blob/master/app.json&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;app.json&lt;/code&gt;&lt;/a&gt; 파일만 만들어 놓으면 됩니다. 저 버튼을 클릭하면 바로 테스트 서버를 띄워볼 수 있습니다. 언제 이렇게 서버 띄우기 쉬운 세상이 되었나요? ㄷㄷ&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;커뮤니티&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스에서 중요한건 건전하고 활발한 커뮤니티를 만드는 것입니다. 기본적으로 github에서 제공하는 이슈기능을 사용하면 되지만, 포럼이나 IRC, 메일링리스트를 사용하면 더 효과적으로 관리할 수 있습니다. Delibird는 아직 작은 프로젝트이기 때문에 기본적인 이슈기능만 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;홍보&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오픈소스가 생명을 얻고 발전하려면 홍보가 필수 입니다. 아무리 유용한 프로젝트라고 해도 홍보가 없으면 사람들이 찾을수가 없습니다. 그래서 제가 지금 이렇게 블로그를 통해 홍보를 하고 있는거 아니겠습니까..&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;오셔서 star한번씩 눌러주시고 관심갖어 주시면 감사하겠습니다. ㅠㅠ&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;내부적으로 사용하던 소스를 오픈하기위에 적절히 리팩토링을 하고 문서를 추가하여 &lt;a href=&quot;https://github.com/purpleworks/delibird&quot;&gt;https://github.com/purpleworks/delibird&lt;/a&gt;에 공개하였습니다. Go에 관심있으신분이나 배송조회에 관심있으신분은 별 눌러주시고 참여해주세요. 열려있습니다!&lt;/p&gt;

&lt;p&gt;많은 사람들이 오픈소스에 참여하고 오픈소스 프로젝트를 하고 있습니다. 하지만, 어떻게 만드는지에 대해서는 정리된 글이 잘 없는 것 같아 포스트를 작성하였습니다.&lt;/p&gt;

&lt;p&gt;사실, 널리 사랑받는 프로젝트는 위에 나열한 겉치례(?)보다는 얼마나 유용하고 얼마나 잘 설계되어 얼마나 자아알 짜여졌는지가 중요합니다. 최신 트렌드를 아는것과 잘 개발하는 것이 정비례하지는 않지만 여러가지 최신 트렌드를 알면 지금보다 조금 더 나은 개발자가 되는데는 도움이 된다고 생각합니다.&lt;/p&gt;

&lt;p&gt;그리고 중요한점은 오픈소스는 생각보다 시간과 노력이 많이 필요한 작업이라는 점입니다. 지금 몇가지 공개 저장소를 관리하고 있는데 여간 손이 많이 가는게 아닙니다. 이슈가 올라오면 체크하고 확인하고 수정하고 버전업하고 npm이나 bower에 등록하고.. 겨우 star수 200개도 이정도인데 다른 프로젝트들은 상상도 못할 것 같습니다. 오픈소스 커미터분들에게 감사드립니다.&lt;/p&gt;

&lt;p&gt;배송조회 서비스를 만든 홈쇼핑처럼에서 지난번 고기덮밥에 이어 돈까스 메뉴도 추가되었으니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.
개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>도커를 이용한 웹서비스 무중단 배포하기</title>
   <link href="http://subicura.com/2016/06/07/zero-downtime-docker-deployment.html"/>
   <updated>2016-06-07T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/06/07/zero-downtime-docker-deployment</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/milbon.jpg&quot; alt=&quot;밀본x고기덮밥&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.likehs.com/tvprogram/index/view/id/22/&quot;&gt;홈쇼핑처럼x밀본고기덮밥&lt;/a&gt;이 팔리는걸 관리자화면에서 보면서 하루에도 여러번 소스를 업데이트 하고 운영서버로 배포했던 내용이 떠올라 후기로 정리합니다.&lt;/p&gt;

&lt;p&gt;배포는 단순히 로컬의 소스를 운영 서버로 복사하는 것입니다. FTP로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 잘 동작합니다. 배포 중에 서비스가 잠깐 멈추는 문제가 있다면 새벽에 배포하면 되고 굳이 다른 개발할일도 많은데 배포에 신경을 써야 하는 생각도 듭니다.&lt;/p&gt;

&lt;p&gt;하지만, 오히려 배포가 탄탄해지면 서비스 개발에 집중할 수 있고 하루에 몇번이라도 배포를 자주, 더 빨리 하는 것이 서비스의 경쟁력이 되는 세상입니다. 서비스가 빠르게 발전하고 있고 서버를 확장하려면 미리미리 신경쓰는 것이 맞다고 생각합니다.&lt;/p&gt;

&lt;p&gt;현재 홈쇼핑처럼 운영서버는 크게 웹(+API), 마이크로서비스(배송조회, 우편번호검색), 영상, 채팅, 모니터링으로 구성되어 있습니다. 여기서는 웹 서비스 배포에 대해서 이야기 하려고 합니다.&lt;/p&gt;

&lt;p&gt;웹 서비스는 웹서버 1대(nginx + php)와 디비서버 1대(mysql + redis)로 가난하게 구성되어 있습니다. 서버 규모에 맞게 최대한 단순하게 배포 프로세스를 구성하려고 했지만, 추후 서비스가 잘 되었을때를 고려하여 확장가능성도 고려하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;어떻게 배포할까?&lt;/h2&gt;

&lt;p&gt;배포 프로세스를 만들면서 고민했던 내용입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉽고 관리하기 편한 방법을 선택하자&lt;/li&gt;
  &lt;li&gt;자동으로 배포하자&lt;/li&gt;
  &lt;li&gt;하루에도 여러번 배포하자&lt;/li&gt;
  &lt;li&gt;배포중 서비스가 중단되는 일이 없도록 하자&lt;/li&gt;
  &lt;li&gt;모든 서비스는 도커를 이용해서 컨테이너 형태로 표준화하여 배포하자&lt;/li&gt;
  &lt;li&gt;테스트 서버에 동일한 방법으로 배포하고 테스트하자&lt;/li&gt;
  &lt;li&gt;시작은 서버 한대지만 나중에 여러대(수백대?!)로 확장되었을때를 대비하여 설계를 고민하자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;왜 도커인가?&lt;/h2&gt;

&lt;p&gt;배포 프로세스를 고려하면서 가장 중요하게 생각한 개념이 &lt;a href=&quot;http://www.docker.com/&quot;&gt;도커&lt;/a&gt;입니다. 도커는 굉장히 빠르게 인기를 얻고 있는 기술이지만 생소하거나 잘 모르는 분들을 위해 간단하게 도커를 소개합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Container&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;새로운(깨끗한) 서버에 서비스를 동작시키려면 굉장히 많은 작업이 필요합니다.&lt;/p&gt;

&lt;p&gt;php로 만든 서비스를 동작시키려면 일단 php를 설치하고 관련 extention으로 php-mysql, php-curl, php-mcrypt, php-mbstring등등을 설치해야 합니다. nginx를 앞단에 두고 php를 연결하기 위해 php-fpm도 설치합니다.&lt;/p&gt;

&lt;p&gt;자, 서버가 한대 더 추가되었습니다. 똑같이 셋팅할 수 있을까요?&lt;/p&gt;

&lt;p&gt;물론입니다. 우리 서버 관리자는 굉장히 섬세하고 고오급 개발자여서 기존에 설치된 내용을 기억하고 정리해두었습니다.&lt;/p&gt;

&lt;p&gt;이 서버에 다른 php 서비스를 올려봅니다. 엇, 그런데 이 서비스는 php7에서 돌지 않습니다. php7이 속도도 빠르고 기능도 짱짱맨이라 사용하고 있었는데 이번에 올릴 서비스는 php7에서 동작하지 않는 모듈이 포함되어 있습니다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 서버 관리자가 굉장히 똑똑하여 슬기롭게 두개를 잘 돌리던가, 아니면 서버가 점점 지저분해 진다던가, 아니면 포기하고 다른 서버에 서비스를 띄우게 됩니다.&lt;/p&gt;

&lt;p&gt;그리고 3년후 서버 관리자가 퇴사하고 이 서버들은 레거시가 되고 가끔 오류가 발생하지만 아무도 왜 그런지 모르고 재부팅하면 운 좋게 동작하는 서버가 되버립니다.&lt;/p&gt;

&lt;p&gt;php를 예로 들었지만, ruby on rails나 nodejs, java기반의 프로젝트도 비슷한 문제를 가지고 있습니다.&lt;/p&gt;

&lt;p&gt;하지만, 도커라면?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/container-docker-blue-whale.jpg&quot; alt=&quot;Docker Container&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도커 컨테이너는 가상의 공간을 만들어서 호스트OS와는 전혀 별개의 환경에서 프로세스들이 동작하는 기술입니다.&lt;/p&gt;

&lt;p&gt;도커는 가상의 공간을 이미지로 만들어 저장한 후 하나의 이미지에서 여러개의 컨테이너를 생성할 수 있는데, 이 말은 한번 이미지를 만들어 놓으면 마구 컨테이너를 띄울 수 있다는 의미입니다. 그것도 완전히 독립된 가상의 공간에서 실행이 됩니다. 관리자는 컨테이너가 어떻게 구성되어 있는지 신경쓸 필요가 없습니다. 그냥 이 컨테이너는 (예를들어)80포트가 열려 있으니 호스트의 80포트를 컨테이너의 80포트로 연결만 하면 바로 동작하게 됩니다.&lt;/p&gt;

&lt;p&gt;도커 이미지를 만드는 방법은 Dockerfile이라는 파일로 관리하기 때문에 원한다면 이미지 생성 과정을 보거나 수정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;vmware 가상머신같은건가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마치 가상머신 같지만 분명 가상머신과는 다릅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;호스트OS 위에 또다른 OS를 가상화 하는 것이 아니라 같은 OS에서 프로세스를 격리 시켜 마치 독립적으로 실행한 것 처럼 사용&lt;/li&gt;
  &lt;li&gt;단지, 독립된 공간을 만들어 프로세스를 실행하기 때문에 실행속도가 빠르고(띄우는데 1초) 일반적으로 cpu, memory, network 성능저하가 거어어의 없음(호스트 대비 99% 성능 나옴)&lt;/li&gt;
  &lt;li&gt;도커를 도와주는 생태계가 엄청남. 편리한 툴과 다양한 문서들이 많고 커뮤니티가 활발함&lt;/li&gt;
  &lt;li&gt;이미지파일을 git처럼 변경분만 저장하기 때문에 컨테이너를 여러개 띄워도 추가적인 용량은 거의 0M임. 실제로 이미지를 원격 저장소에 저장할 때도 push, pull같은 명령어를 이용함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;왜 인기있을까?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커가 나오기 전에 가장 인기 있었던 가상화 시스템은 Xen, KVM등이 있습니다. 이러한 기술들은 일부 고오급 개발자들만 사용이 가능했고 가상화에 따른 성능이슈도 존재했습니다.&lt;/p&gt;

&lt;p&gt;도커는 프로세스 격리라는 개념을 적극 도입하여 성능 이슈를 줄이고, 일반 개발자들도 굉장히 사용하기 쉽게 개발하였습니다. 그리고 큰 용량의 이미지를 쉽게 다운받고 저장할 수 있게 &lt;a href=&quot;https://hub.docker.com/&quot;&gt;docker hub&lt;/a&gt;와 같은 서비스도 같이 오픈하였고 전세계적으로 커뮤니티 또한 적극적으로 지원하였습니다.(티셔츠랑 스티커!) 한국에서 온 처음만나는 개발자에게 회사의 &lt;a href=&quot;https://twitter.com/jpetazzo&quot;&gt;고오오오급 개발자&lt;/a&gt;가 직접 궁금증을 풀어주는 경우가 흔치는 않겠죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/docker-jpetazzo.jpg&quot; alt=&quot;Docker office에서 만난 Jérôme Petazzoni&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;단점이 있을테니 단점을 찾아봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(사실상)리눅스에서만 사용함&lt;/li&gt;
  &lt;li&gt;리눅스 커널에 따라 이슈가 약간 있음(최신 커널을 못 쓰는 클라우드에서 문제가 있을수 있음)&lt;/li&gt;
  &lt;li&gt;도커 버전업할때 컨테이너가 쥬금 ㅠ (단순하게 만드는 unix철학이 아닌 도커데몬이 모든걸 관리하고 제어하기때문..)&lt;/li&gt;
  &lt;li&gt;포트 포워딩에 iptable을 사용하면서 생기는 보안상 제약사항이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;도커를 이용한 배포&lt;/h2&gt;

&lt;p&gt;도커를 이용한 배포가 갖는 특징입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미지만 만들어 놓으면 컨테이너는 그냥 띄우기만 하면됨&lt;/li&gt;
  &lt;li&gt;다른 서버로 서비스를 옮기거나 새로운 서버에 서비스를 하나 더 띄우는건 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 명령어 하나로 끝&lt;/li&gt;
  &lt;li&gt;개발서버 띄우기도 편하고 테스트서버 띄우기도 간편&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;표준성&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도커를 사용하지 않는 경우 ruby, nodejs, go, php로 만든 서비스들의 배포 방식은 제각각 다름&lt;/li&gt;
  &lt;li&gt;컨테이너라는 표준으로 서버를 배포하므로 모든 서비스들의 배포과정이 동일해짐&lt;/li&gt;
  &lt;li&gt;capistrano? fabric? ftp? 바이바이~&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;이미지&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미지에서 컨테이너를 생성하기 때문에 반드시 이미지를 만드는 과정이 필요&lt;/li&gt;
  &lt;li&gt;이미지를 저장할 곳이 필요&lt;/li&gt;
  &lt;li&gt;빌드 서버에서 이미지를 만들면 해당 이미지를 &lt;a href=&quot;https://github.com/docker/distribution&quot;&gt;distribution&lt;/a&gt;에 저장하고 운영서버에서 이미지를 불러옴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;설정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;설정은 보통 환경변수로 제어함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MYSQL_PASS=password&lt;/code&gt;와 같이 컨테이너를 띄울때 환경변수를 같이 지정&lt;/li&gt;
  &lt;li&gt;하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어져야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;공유자원&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화됨&lt;/li&gt;
  &lt;li&gt;업로드 파일을 외부 스토리지와 링크하여 사용하거나 S3같은 별도의 저장소가 필요&lt;/li&gt;
  &lt;li&gt;세션이나 캐시를 파일로 사용하고 있다면 memcached나 redis와 같은 외부로 분리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;힙&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;왠지 최신기술을 쓰는 느낌을 갖음&lt;/li&gt;
  &lt;li&gt;힙한 개발자가 된 느낌을 갖음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;도커 이미지 만들기&lt;/h2&gt;

&lt;p&gt;이제 본격적으로 이미지를 만들어 봅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/likehs-docker-image.png&quot; alt=&quot;홈쇼핑처럼 도커 이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;likehs-nginx&lt;/strong&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM subicura/nginx:1.11.1
MAINTAINER Chungsub Kim &amp;lt;chungsub.kim@purpleworks.co.kr&amp;gt;

ADD /data/config/nginx/load_pagespeed_module.conf /usr/local/nginx/conf/conf.d/load_pagespeed_module.conf
ADD /data/config/nginx/production.conf /usr/local/nginx/conf/sites/production.conf

CMD /usr/local/sbin/nginx&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/8d50a2337e1e3bb6bc43a10e005c5709.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;Base Image
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/subicura/Dockerfiles/tree/master/nginx&quot;&gt;subicura/nginx&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;nginx 최신버전&lt;/li&gt;
      &lt;li&gt;ssl + http2 + stream + realip + ngx pagespeed와 같은 흔히 사용하는 모듈 컴파일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nginx pagespeed 모듈을 활성화하기 위한 설정파일 추가&lt;/li&gt;
  &lt;li&gt;php7-fpm 연동을 위한 설정파일 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;likehs-app&lt;/strong&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;FROM subicura/php7-fpm:latest
MAINTAINER Chungsub Kim &amp;lt;chungsub.kim@purpleworks.co.kr&amp;gt;

# Add source &amp;amp; config files
ADD src /var/www/magento
ADD data/config/php/99-custom.ini /etc/php/7.0/fpm/conf.d/99-custom.ini

# Volume
VOLUME /var/www/magento
VOLUME /var/run/php

# Run
COPY data/docker/start.sh /usr/local/bin/
RUN ln -s usr/local/bin/start.sh /start.sh
CMD [&amp;quot;start.sh&amp;quot;]&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/0ebe5370d8e52dd2a48aa9df53f66b00.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;Base Image
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/subicura/Dockerfiles/blob/master/php7-fpm&quot;&gt;subicura/php7-fpm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;php7-fpm 최신버전&lt;/li&gt;
      &lt;li&gt;mysql, curl, mcrypt, mbstring등 php 익스텐션 설치&lt;/li&gt;
      &lt;li&gt;v8, xdebug 선택적 사용가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;base 이미지에 소스파일과 php custom 설정파일을 추가함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start.sh&lt;/code&gt; 파일은 환경변수에 따라 데이터베이스 정보등을 설정하고 php7-fpm 프로세스를 실행함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;컨테이너 구성&lt;/h2&gt;

&lt;p&gt;이미지를 만들었으니 사실상 90% 작업은 완료되었습니다. 이제 생성된 이미지를 컨테이너로 실행만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/likehs-docker-container.png&quot; alt=&quot;홈쇼핑처럼 도커 컨테이너 구성&quot; /&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;version: &amp;#39;2&amp;#39;
services:
  nginx:
    image: xxx/likehs-nginx:latest
    network_mode: &amp;#39;bridge&amp;#39;
    depends_on:
      - app
    volumes_from:
      - app
    ports:
      - 8080:80
  app:
    image: xxx/likehs-app:latest
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: user
      MYSQL_PASSWORD: password
      MYSQL_DATABASE: database
      REDIS_HOST: redis
      REDIS_PORT: 6379
      ENABLE_PHP7_FPM_V8: 1
    volumes:
      - /data/likehs/magento_files:/var/www/magento/media
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/d888929d311a680e7d64a51b03e569ff.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;컨테이너를 실행할때 &lt;a href=&quot;https://github.com/docker/compose&quot;&gt;docker compose&lt;/a&gt;를 이용하면 힘들게 명령어를 기이일게 입력하지 않아도 되고 컨테이너간 의존성도 알아서 체크하여 순서대로 실행해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx container&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;likehs-app&lt;/code&gt;컨테이너에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/magento&lt;/code&gt;디렉토리와 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/run/php&lt;/code&gt;디렉토리가 볼륨으로 설정되어 있으므로 마치 내 컨테이너에 있는 디렉토리처럼 자동으로 마운트됨&lt;/li&gt;
  &lt;li&gt;nginx 설정파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;unix:/var/run/php/php7.0-fpm.sock&lt;/code&gt;여기를 바라보게 셋팅되어 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/magento&lt;/code&gt;디렉토리를 루트로 바라봄&lt;/li&gt;
  &lt;li&gt;컨테이너 내부의 &lt;code class=&quot;highlighter-rouge&quot;&gt;80포트&lt;/code&gt;를 호스트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;8080포트&lt;/code&gt;로 연결함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;app container&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스와 redis설정을 환경변수로 제어함&lt;/li&gt;
  &lt;li&gt;업로드 디렉토리를 호스트의 디렉토리로 연결하여 컨테이너를 새로 띄워도 파일을 유지할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 운영서버에 접속한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose up -d&lt;/code&gt;를 실행하면 원격에서 이미지를 다운받고 서비스가 실행됩니다. 이제 배포를 위한 모든 준비가 끝났습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;웹서비스 배포하기&lt;/h2&gt;

&lt;p&gt;도커생태계에서 배포는 뜨거운 이슈입니다. 그만큼 다양한 방법이 존재하고 다양한 툴들이 있습니다. 배포 프로세스를 설계하면서 고려해봤던 툴들입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://coreos.com/&quot;&gt;coreos/fleet&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;coreos는 컨테이너를 호율적으로 실행하기 위해 굉장히 가볍게 설계된 리눅스 배포판임&lt;/li&gt;
      &lt;li&gt;보안에 신경을써 기본적으로 OS가 자동으로 업데이트됨(자동 재부팅 ㄷㄷ)&lt;/li&gt;
      &lt;li&gt;애초에 여러대의 서버에 어플리케이션이 동적으로 배포되는걸 가정하고 만들어짐. 하나가 죽어도 다른 서버에서 살아남!&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://coreos.com/using-coreos/clustering/&quot;&gt;fleet&lt;/a&gt;은 systemd의 cluster버전으로 사용법이 쉽고 systemd의 장점을 그대로 가지고 있음&lt;/li&gt;
      &lt;li&gt;fleet을 운영하기 위해서는 &lt;a href=&quot;https://coreos.com/etcd/&quot;&gt;etcd&lt;/a&gt;가 필요하고 etcd는 최소 3대 이상의 서버가 필요함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/subicura/launching-containers-with-fleet&quot;&gt;테스트&lt;/a&gt;만 해보고 소규모에는 적합하지 않다고 생각하여 패스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mesos.apache.org/&quot;&gt;apache mesos&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;UC Berkeley에서 연구를 시작하여 Twitter, Facebook, Apple, Airbnb등 여러곳에서 안정적으로 사용중&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;zookeeper&lt;/a&gt;를 백엔드로 사용. 이거 관리어떻게 하지…&lt;/li&gt;
      &lt;li&gt;최근 도커 컨테이너를 적극 지원하고 있음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.slideshare.net/subicura/mesos-on-coreos&quot;&gt;테스트&lt;/a&gt;만 해보고 역시나 소규모에는 적합하지 않다고 생각하여 패스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://kubernetes.io/&quot;&gt;kubernetes&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;구글에서 개발하고 있는 컨테이너 배포, 확장, 운영 툴&lt;/li&gt;
      &lt;li&gt;fleet과 마찬가지로 etcd를 백엔드로 사용&lt;/li&gt;
      &lt;li&gt;예전에 테스트 해봤을때 아직 프로덕션에 사용은 어려워 보였음&lt;/li&gt;
      &lt;li&gt;역시나 소규모에는 적합하지 않음 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/swarm/&quot;&gt;docker swarm&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;docker에서 밀고 있는 컨테이너 배포 툴&lt;/li&gt;
      &lt;li&gt;호스트 OS에 Agent만 설치하면 간단하게 작동하고 빠름&lt;/li&gt;
      &lt;li&gt;소규모에 적합해보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결론적으로, 배포와 관련된 테스트와 스터디는 추후 대규모로 서버가 확장되었을때 사용하는 것으로..하고(언젠가 쓸모있겠지 ㅠ) 시작은 가볍게 갑니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker 원격 API&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;도커는 기본적으로 원격 API를 호출하기 쉬운 구조입니다. 도커 명령어를 실행할때 의식하고 있지는 않지만 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;unix:///var/run/docker.sock&lt;/code&gt; 여기를 바라보고 명령을 하고 있습니다. 도커 데몬을 실행할때 &lt;code class=&quot;highlighter-rouge&quot;&gt;-H tcp://0.0.0.0:2375&lt;/code&gt; 옵션을 주게 되면 원격에서 명령을 보낼 준비가 완료됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;쉽다는건 보안적으로 엄청난 구멍일 수 있다는 뜻입니다. 방화벽 정책은 필수!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;도커 원격명령 실행
    &lt;ul&gt;
      &lt;li&gt;DOCKER_HOST 환경변수를 셋팅합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DOCKER_HOST=tcp://192.168.0.100:2375 docker run&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker Compose 원격명령 실행
    &lt;ul&gt;
      &lt;li&gt;DOCKER_HOST 환경변수를 셋팅합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DOCKER_HOST=tcp://192.168.0.100:2375 docker-compose up -d&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;원격 API를 이용한 배포&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;원격으로 도커 명령어를 실행하는 방법을 이용해 간단하게 스크립트를 만듭니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#!/bin/sh

TARGET_DEPLOY_TCP=tcp://192.168.0.100:2375
DOCKER_APP_NAME=likehs
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml down
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml pull
DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME} -f docker-compose.yml up -d
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/f39d180842b2f3bd6323bb467dec75cb.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;기존에 실행중인 컨테이너를 멈추고(down) 최신버전을 내려 받고(pull) 실행하면(up) 끝입니다.&lt;/p&gt;

&lt;h2 id=&quot;blue-green-&quot;&gt;Blue-Green 배포&lt;/h2&gt;

&lt;p&gt;도커 이미지를 만들고 컨테이너를 배포하는데 성공했지만 배포할때마다 서비스가 잠시 중단(down하고 up하는 사이)되는 치명적인 단점이 있습니다. 이부분을 &lt;a href=&quot;http://martinfowler.com/bliki/BlueGreenDeployment.html&quot;&gt;blue-green 배포 방식&lt;/a&gt;을 이용하여 무중단으로 배포해봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx load balance 기능 이용하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/nginx-load-balance.png&quot; alt=&quot;nginx&quot; /&gt;&lt;/p&gt;

&lt;p&gt;nginx는 무료면서 훌륭한 성능을 자랑하는 로드밸런서입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;80포트&lt;/code&gt;로 들어온 요청을 &lt;code class=&quot;highlighter-rouge&quot;&gt;8080포트&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;8081포트&lt;/code&gt;로 분산할 수 있고 health check를 통해 포트가 죽어있다면 살아있는 포트로 요청을 보내게 됩니다.&lt;/p&gt;

&lt;p&gt;보통은 서로다른 IP의 서버를 로드밸런스 하기 위해 사용하지만 한 IP에서 서로 다른 포트를 지정하는 것도 가능합니다. 도커를 사용하지 않는다면 같은 서비스를 하나의 서버에 여러개 띄운다는 걸 상상하기 어렵지만 도커이기 때문에 쉽게 적용할 수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#!/bin/sh

TARGET_DEPLOY_TCP=tcp://192.168.0.100:2375
DOCKER_APP_NAME=likehs

EXIST_BLUE=$(DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml ps | grep Up)

if [ -z &amp;quot;$EXIST_BLUE&amp;quot; ]; then
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml pull
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml up -d

    sleep 10

    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml down
else
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml pull
    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-green -f docker-compose.green.yml up -d

    sleep 10

    DOCKER_HOST=${TARGET_DEPLOY_TCP} docker-compose -p ${DOCKER_APP_NAME}-blue -f docker-compose.blue.yml down
fi
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/fff289e766a73b0dfb498eadc0d2f9ec.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;작은 규모에 맞는 아주 적절한 스크립트를 만들었습니다. 포트를 다르게 설정한 compose 파일을 2개 만들고 어떤 compose가 떠있는지 확인합니다. 실행중이 아닌 compose를 실행하여 컨테이너를 띄운 후 다른 컨테이너를 멈춥니다.&lt;/p&gt;

&lt;p&gt;어떤 디펜던시도 필요 없고 어떤 에이전트도 없지만 확실하게 동작하는 스크립트 입니다.&lt;/p&gt;

&lt;h2 id=&quot;service-discovery&quot;&gt;Service Discovery&lt;/h2&gt;

&lt;p&gt;nginx를 이용해 2개의 포트를 바라보고 둘중에 동작하는 포트에 요청을 보내는 방법은 몇가지 단점이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버를 추가하거나 변경할 경우 설정파일을 수정하고 재시작하는 과정이 필요&lt;/li&gt;
  &lt;li&gt;프록시 대상 IP와 PORT가 항상 고정이여야 한다는 점&lt;/li&gt;
  &lt;li&gt;죽어 있는 포트가 살아 있는지 계속해서 체크하면서 생기는 (작지만 문제 있어보이는) 오버헤드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 문제를 해결하기 위해 Service Discovery라는 개념이 있습니다. 서버들의 정보(IP, Port등등)를 포함한 다양한 정보를 저장하고 가져오고 값의 변화가 일어날때 이벤트를 받아 자동으로 서비스의 설정 정보를 수정하고 재시작하는 개념입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-06-07-zero-downtime-docker-deployment/service-discovery.png&quot; alt=&quot;service discovery&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;새로운 서버가 추가되면 서버 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;key/value store&lt;/code&gt;에 추가함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;key/value store&lt;/code&gt;는 directory 형태로 값을 저장함. /services/web 하위를 읽으면 전체 web 서버 정보를 읽을 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;key/value store&lt;/code&gt;를 watch하고 있던 &lt;code class=&quot;highlighter-rouge&quot;&gt;configuration manager&lt;/code&gt;가 값이 추가되었다는 이벤트를 받음&lt;/li&gt;
  &lt;li&gt;이벤트를 받으면 템플릿 파일을 기반으로 새로운 설정파일을 생성&lt;/li&gt;
  &lt;li&gt;새로운 설정파일을 만들어 기존파일을 대체하고 서비스를 재시작함&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 개념을 구현한 다양한 서비스와 툴이 존재하고 각기 다른 특징을 갖습니다. 여러가지 서비스에 대해선 다음기회에.. 알아보고 여기서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-gen&lt;/code&gt;에 대해서 알아봅니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker-gen&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jwilder/docker-gen&quot;&gt;docker-gen&lt;/a&gt;은 docker의 기본 기능을 적극 활용한 service discovery 툴입니다. docker외에 디펜던시는 없기 때문에 구성이 간단하고 편리하지만 하나의 서버에 속한 컨테이너끼리만 동작한다는 단점이 있습니다. 홈쇼핑처럼은 아직 작은 서비스이기 때문에 적합하다고 할 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key/value store
    &lt;ul&gt;
      &lt;li&gt;도커 데몬이 가지고 있는 컨테이너의 정보를 그대로 이용&lt;/li&gt;
      &lt;li&gt;컨테이너를 실행할때 입력한 환경변수를 읽음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VIRTUAL_HOST=www.likehs.com&lt;/code&gt;과 같이 환경변수를 지정하면 이를 보고 nginx의 virtual host 설정파일들을 구성함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;configuration manager
    &lt;ul&gt;
      &lt;li&gt;도커 데몬은 컨테이너의 생성/삭제에 대한 이벤트를 발생시킴&lt;/li&gt;
      &lt;li&gt;docker-gen이 해당 이벤트를 받아서 처리함&lt;/li&gt;
      &lt;li&gt;template은 go의 &lt;a href=&quot;https://golang.org/pkg/text/template/&quot;&gt;text/template language&lt;/a&gt;을 그대로 사용하여 매우 자유롭게 구성가능&lt;/li&gt;
      &lt;li&gt;조건식/반복문등을 이용하여 template 파일 구성&lt;/li&gt;
      &lt;li&gt;template 파일을 가지고 설정파일을 만든 후 원하는 명령어를 수행&lt;/li&gt;
      &lt;li&gt;명령어는 보통 서비스 재시작 (&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx -s reload&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;적용&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;홈쇼핑처럼의 웹서비스는 컨테이너 앞단에 nginx를 두고 docker-gen을 이용하여 nginx의 설정파일을 변경하고 프로세스를 재시작하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;blue 컨테이너 실행&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-gen 이벤트 수신&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx 설정파일에 blue container 정보 추가&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx 재시작&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이어서,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;green 컨테이너 중지&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-gen 이벤트 수신&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx 설정파일에 green container 정보 제거&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;nginx 재시작&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;자동화&lt;/h2&gt;

&lt;p&gt;이제 무중단 배포까지 완료되었으니 배포를 자동화합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git branch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;현재 소스는 총 3가지 타입의 브랜치로 관리하고 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기능별 브랜치
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;send-sms-after-order&lt;/code&gt;와 같이 기능별로 브랜치를 만듬&lt;/li&gt;
      &lt;li&gt;master 브랜치로 머지 후 제거됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;master
    &lt;ul&gt;
      &lt;li&gt;메인 개발소스&lt;/li&gt;
      &lt;li&gt;바로 push할 수 없음&lt;/li&gt;
      &lt;li&gt;작업별 브랜치를 pull request 보내고 코드 리뷰 후 머지함&lt;/li&gt;
      &lt;li&gt;master 브랜치는 바로 스테이징서버로 배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;production
    &lt;ul&gt;
      &lt;li&gt;운영서버에서 사용중인 브랜치&lt;/li&gt;
      &lt;li&gt;master 브랜치가 스테이징서버로 배포되고 테스트가 끝나면 수동으로 master 브랜치를 production 브랜치로 머지&lt;/li&gt;
      &lt;li&gt;production 브랜치가 푸시되면 바로 운영서버로 배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;gitlab webhook&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gitlab에는 푸시가 될때마다 이벤트를 보낼 수 있는 &lt;a href=&quot;https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/web_hooks/web_hooks.md&quot;&gt;webhook&lt;/a&gt;기능이 있고 jenkins는 webhook이 호출되면 자동으로 빌드를 시작하는 &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Gitlab+Hook+Plugin&quot;&gt;plugin&lt;/a&gt;이 존재합니다. gitlab은 모든 푸시 이벤트마다 jenkins를 호출하게 되고 jenkins는 branch를 보고 master일 경우는 staging 배포, production일 경우는 운영서버에 배포하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jenkins&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jenkins에 &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/Slack+Plugin&quot;&gt;slack플러그인&lt;/a&gt;을 설치하면 시작, 배포 후 성공/실패 여부를 슬랙 메시지로 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;jenkins는 &lt;code class=&quot;highlighter-rouge&quot;&gt;테스트&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;이미지 빌드&lt;/code&gt; &amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;배포&lt;/code&gt; 과정을 수행합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;롤백&lt;/h2&gt;

&lt;p&gt;배포된 이미지에 문제가 심각할 경우 이전 이미지로 되돌릴 수 있어야 합니다. 도커를 이용하면 이미지에 태그를 걸 수 있어, 손쉽게 구현할 수 있습니다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;#!/bin/sh

DOCKER_REGISTRY_NAME=xxxx/likehs
COMMIT_HASH=&amp;quot;$(git show-ref --head | grep -h HEAD | cut -d&amp;#39;:&amp;#39; -f2 | head -n 1 | head -c 10)&amp;quot;
docker build --force-rm=true -f Dockerfile -t ${DOCKER_REGISTRY_NAME}-app:$COMMIT_HASH .
docker tag -f ${DOCKER_REGISTRY_NAME}-app:$COMMIT_HASH ${DOCKER_REGISTRY_NAME}-app:latest&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/subicura/bd3b275d5330b9eef983ce4e626b6edd.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;jenkins에서 이미지를 빌드할때 현재 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit hash&lt;/code&gt;로 태그로 만듭니다. 그리고 해당 이미지를 다시 배포하려면 해당 git commit hash를 latest로 태그한 후 다시 배포하면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;도커를 이용한 배포에 대해 전반적인 내용을 살펴보았습니다. 어쩌다보니 도커에 대한 내용이 더 많아진 느낌입니다. 이미 도커를 알고 계신분은 심심한 포스트일지도.. 하지만, 도커를 몰랐던 분들은 꼭 써보세요. 좋습니다! 도커에 대한 내용은 &lt;a href=&quot;http://documents.docker.co.kr/&quot;&gt;여기&lt;/a&gt;에서 더 많이 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;배포는 다양한 기술이 존재하고 서버 규모나 개발팀의 규모에 따라 여러가지 방법이 있으니 자신의 팀에 딱 맞는 방법을 찾아 적용하는 것이 중요한 것 같습니다. 더 쉽거나 나은 방법 있으면 추천해주세요.&lt;/p&gt;

&lt;p&gt;지난번 떡볶이에 이어 &lt;strong&gt;고기덮밥&lt;/strong&gt; 메뉴도 추가되었으니 서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com/&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요.&lt;/p&gt;

&lt;p&gt;개발자 상시 모집중입니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>홈쇼핑처럼 개발후기</title>
   <link href="http://subicura.com/2016/05/30/likehs-develop-log.html"/>
   <updated>2016-05-30T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/05/30/likehs-develop-log</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-05-30-likehs-develop-log/dduk.png&quot; alt=&quot;서울스낵x불맛쌀떡볶이&quot; /&gt;&lt;/p&gt;

&lt;p&gt;홈쇼핑처럼x불맛쌀떡볶이를 배송받으면서 그동안 “&lt;a href=&quot;https://www.likehs.com/&quot;&gt;홈쇼핑처럼&lt;/a&gt;“을 개발했던 내용이 떠올라 후기로 정리합니다.&lt;/p&gt;

&lt;p&gt;그동안 주로 SI관련일을 하다가 이번에 처음으로 일반 고객을 대상으로 서비스를 만들게 되었습니다. 처음부터 끝까지 만들어야 하다보니 정말 일이 많고 힘드네요. 모든 대한민국의 스타트업에게 존경을…&lt;/p&gt;

&lt;p&gt;밑에 내용은 서비스를 만들면서 기술적으로 고민했던 것과 어떤 기술들을 사용했는지를 중점으로 정리해 보았습니다. “아, 이 스타트업은 이렇게 일을 하고 이런식으로 서비스를 개발했구나” 하고 봐주시면 감사할 것 같습니다. 더 나은 대안이 있다면 추천해주셔도 좋습니다.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;어떤걸 만들까?&lt;/h2&gt;

&lt;p&gt;대략적인 서비스 개요입니다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;맛집음식을 집에서 간편하게 먹자&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입소문이 난 맛집과 협력하여 처음부터 함께 간편식을 개발하자&lt;/li&gt;
  &lt;li&gt;개발부터 패키징, 냉장보관, 배송까지 관리하여 빠르고 편리하게 제품을 전달하자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BJ가 실시간 동영상을 통해 제품을 알리자&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BJ를 섭외하고 일주일에 한번씩 실시간으로 제품을 홍보하고 소통하자&lt;/li&gt;
  &lt;li&gt;그외에 맛집정보와 조리법등을 영상으로 편집하여 볼 수 있게 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;채팅을 넣자&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실시간 채팅이 가장 편한 커뮤니케이션 도구다&lt;/li&gt;
  &lt;li&gt;질문/답변 및 제품에 대한 이야기를 게시판이나 댓글이 아닌 채팅으로 얘기하자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;단순하게 만들자&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제품을 보고 구매하고 확인 하는 단순한 과정에 집중하자&lt;/li&gt;
  &lt;li&gt;구매자가 최대한 편하고 짧은 시간에 구매할 수 있도록 하자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;어떻게 개발해야 할까?&lt;/h2&gt;

&lt;p&gt;기술 스택 소개입니다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안드로이드와 아이폰 - 한국은 안드로이드 사용자가 압도적이지만 아이폰 사용자를 포기할 수 없음. 우리 회사도 한명 빼곤 전부 아이폰이라.. 같이 런칭하기로 결정&lt;/li&gt;
  &lt;li&gt;안드로이드는 Android Studio에 Java를 이용하고 아이폰은 Xcode에 swift를 이용&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/&quot;&gt;RxAndroid&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;뭔가 좋아보이니 도입&lt;/li&gt;
      &lt;li&gt;timeout, loading 상황이라던가 채팅 메시지를 받는 부분에 적용 =&amp;gt; 생각보다 쓰기가 어려웠음&lt;/li&gt;
      &lt;li&gt;뭐하나 할때마다 문서를 찾아봐야하고 이렇게 쓰는게 맞나 싶은 상황이 많음&lt;/li&gt;
      &lt;li&gt;좋은 샘플이 많이 나오고 베스트 프렉티스라던가 문서들이 더 성숙해져야 할 것 같음&lt;/li&gt;
      &lt;li&gt;조금 더 지나면 좋아질 것 같은데 아직 좀 이른느낌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/swift/&quot;&gt;swift&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;플러그인들 개발이 많이 되어서 몇년 전에 비해 실제 제품을 개발하는데 무리가 없어짐&lt;/li&gt;
      &lt;li&gt;Objective-C 안녕&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.xamarin.com/&quot;&gt;xamarin&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/react-native/&quot;&gt;react native&lt;/a&gt;, &lt;a href=&quot;http://ionicframework.com/&quot;&gt;ionic&lt;/a&gt;, &lt;a href=&quot;http://www.rubymotion.com/&quot;&gt;rubymotion&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;한번 소스 작성으로 아이폰과 안드로이드 앱을 가능하게 하는 녀석들&lt;/li&gt;
      &lt;li&gt;비지니스용 앱에는 적합해 보이나 고객용 앱으로는 적용이 어렵다고 판단&lt;/li&gt;
      &lt;li&gt;개발자들이 기본 언어에 기본 SDK 선호&lt;/li&gt;
      &lt;li&gt;고려해봤지만 결국 안쓰는것으로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cocoapods.org/&quot;&gt;cocoapods&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;iOS 라이브러리는 cocoapod 사용중&lt;/li&gt;
      &lt;li&gt;내부 private 라이브러리가 있어 따로 pod 리파지터리 구성&lt;/li&gt;
      &lt;li&gt;pod 리파지터리는 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html&quot;&gt;podpsec&lt;/a&gt;만 구현하면 손쉽게 구현가능함
        &lt;ul&gt;
          &lt;li&gt;버전과 라이브러리 정보를 xxx.podspec으로 해서 git 저장소에 저장하면 끝&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;WEB / Backend&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제품관리부터 배송, 환불, 재고, 이벤트, 쿠폰등 일련의 커머스 시스템을 전부 만들수는 없으니 유명한 프레임워크를 찾아보고 커스터마이징 하기로함&lt;/li&gt;
  &lt;li&gt;오픈 소스 커머스 후보
    &lt;ul&gt;
      &lt;li&gt;.net 기반의 &lt;a href=&quot;http://www.nopcommerce.com/&quot;&gt;nopCommerce&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;좋은 설계&lt;/li&gt;
          &lt;li&gt;개발환경이 좀 느림&lt;/li&gt;
          &lt;li&gt;윈도우 visual studio 필수 =&amp;gt; 다들 mac을 사용해서 가상환경에서 해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;rails기반의 &lt;a href=&quot;https://spreecommerce.com/&quot;&gt;spree&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;가벼움&lt;/li&gt;
          &lt;li&gt;커스터마이징 방식이 맘에 들지 않음&lt;/li&gt;
          &lt;li&gt;생각보다 기능이 부실함&lt;/li&gt;
          &lt;li&gt;유/무료 플러그인이 적음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;php기반의 &lt;a href=&quot;https://magento.com/&quot;&gt;magento&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;php지만 자체 프레임웍을 잘 구성해 놓음 =&amp;gt; 프레임웍 꽤 공부해야함&lt;/li&gt;
          &lt;li&gt;(프레임웍을 잘 이해하고 있다면) 기존 기능 확장과 커스터마이징이 쉬움&lt;/li&gt;
          &lt;li&gt;유/무료 플러그인 많음 =&amp;gt; 맘에 쏙드는 플러그인은 없고 결국 커스터마이징 해야함&lt;/li&gt;
          &lt;li&gt;ebay에서 인수하고 세계적으로 널리 쓰임&lt;/li&gt;
          &lt;li&gt;최종 선택&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;magento
    &lt;ul&gt;
      &lt;li&gt;한국 페이먼트 솔루션이 잘 안되어 있어서 이니시스를 사용했는데 결제, 환불, 부분환불을 전부 구현해야했음. (플러그인으로 오픈하면 좀 팔릴까?)&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://xdebug.org/&quot;&gt;xdebug&lt;/a&gt;, &lt;a href=&quot;https://github.com/squizlabs/PHP_CodeSniffer&quot;&gt;code sniffer&lt;/a&gt;, &lt;a href=&quot;https://phpunit.de/&quot;&gt;phpunit&lt;/a&gt;을 이용해서 잘 케어해줘야 오류가 안나고 신중하게 코드를 관리해야 유지보수가 수월함&lt;/li&gt;
      &lt;li&gt;개발환경 셋팅하는데 애먹음
        &lt;ul&gt;
          &lt;li&gt;magento는 왜 &lt;a href=&quot;https://rubygems.org/&quot;&gt;gem&lt;/a&gt;이나 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;같은 방식으로 제공하지 않는가?&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://rubyonrails.org/&quot;&gt;rails&lt;/a&gt;나 &lt;a href=&quot;http://expressjs.com/&quot;&gt;express&lt;/a&gt;같은 경우는 core소스가 개발소스와 완전히 분리되어 개발 가능한데 마젠토는 전체 소스를 가지고 있어야 했음&lt;/li&gt;
          &lt;li&gt;결국 코어랑 커스터마이징을 분리하기는 했는데 맞는 방법인지 모르겠음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Web / Frontend&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gulpjs.com/&quot;&gt;gulp&lt;/a&gt;+&lt;a href=&quot;https://webpack.github.io/&quot;&gt;webpack&lt;/a&gt;+&lt;a href=&quot;http://babeljs.io/&quot;&gt;babel&lt;/a&gt;+&lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;react&lt;/a&gt;+&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;+&lt;a href=&quot;https://jquery.com/&quot;&gt;jquery&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/phpv8/v8js&quot;&gt;PHP v8js&lt;/a&gt;를 설치하여 &lt;a href=&quot;http://blog.remotty.com/blog/2015/08/30/react-server-rendering-on-rails/&quot;&gt;react 서버 사이드 렌더링&lt;/a&gt; 사용&lt;/li&gt;
  &lt;li&gt;redux 생각보다 공부하기 어려웠음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sass-lang.com/&quot;&gt;SCSS&lt;/a&gt; / &lt;a href=&quot;http://getbootstrap.com/&quot;&gt;bootstrap 3&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;bootstrap은 style중 base와 일부분만 사용&lt;/li&gt;
      &lt;li&gt;javascript plugin은 제외함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;앱 기반이라 웹은 아직 많이 사용하지 않는데.. 구성이 과해졌음;;&lt;/li&gt;
  &lt;li&gt;나중에 웹 개발 들어가면 감사하겠지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;개발환경&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vagrantup.com/&quot;&gt;vagrant&lt;/a&gt;와 &lt;a href=&quot;https://www.docker.com/&quot;&gt;docker&lt;/a&gt;를 이용하여 구성&lt;/li&gt;
  &lt;li&gt;vagrant안에 nginx, php7, mysql, redis docker container를 띄워서 개발&lt;/li&gt;
  &lt;li&gt;배포도 도커를 사용하기때문에 배포환경이랑 99% 일치하는 장점&lt;/li&gt;
  &lt;li&gt;매번 힘들게 개발환경 구성할 필요 없음 &lt;code class=&quot;highlighter-rouge&quot;&gt;vagrant up&lt;/code&gt;하고 커피한잔 마시면 됨&lt;/li&gt;
  &lt;li&gt;빨리 &lt;a href=&quot;https://blog.docker.com/2016/03/docker-for-mac-windows-beta/&quot;&gt;docker for mac&lt;/a&gt;이 안정화되길 기다리는중
    &lt;ul&gt;
      &lt;li&gt;docker때문에 리눅스를 개발환경으로 써볼까 까지도 생각했지만 IDE와 한글궁합, 폰트 구성이 너무 힘듬 ㅠㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;채팅&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.google.co.kr/?#newwindow=1&amp;amp;q=chat+sdk&quot;&gt;여러가지 솔루션&lt;/a&gt; 검토 후 최종결정은 자체 개발
    &lt;ul&gt;
      &lt;li&gt;주문 상황을 채팅창에 공유하거나, 바로 구매하기 링크 버튼등 채팅창에 넣을 요소를 고려&lt;/li&gt;
      &lt;li&gt;커스터마이징이 필요한데 기존 솔류션들은 자유도가 떨어져 보였음&lt;/li&gt;
      &lt;li&gt;만드는김에 별개의 서비스로 개발하고 홈쇼핑처럼이 해당 서비스를 사용하는 방식으로 구현 =&amp;gt; 여유 생기면 채팅 솔루션 개발업체로 변신&lt;/li&gt;
      &lt;li&gt;덕분에 프로젝트가 하나 더 생긴 느낌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;채팅같은 개발은 처음이라 안전성보다는 좋아보이는 최신 기술스택을 대거 채용함&lt;/li&gt;
  &lt;li&gt;기본적인 관리자 페이지와 API
    &lt;ul&gt;
      &lt;li&gt;rails / react+redux조합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;채팅 스트림 소켓 접속
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://vertx.io/&quot;&gt;Vert.x&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Java기반에 netty사용으로 믿음직함&lt;/li&gt;
      &lt;li&gt;stream과 확장성에 최적화됨&lt;/li&gt;
      &lt;li&gt;TCP/websocket등을 쉽게 처리해줘서 코어만 단순하고 심플하게 개발할 수 있음&lt;/li&gt;
      &lt;li&gt;자잘한 버그가 있음 ㅠ 3.3이 빨리 나오길 기다리는 중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메시지 파싱 및 큐, 디비 전송
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://golang.org/&quot;&gt;go&lt;/a&gt;로 구현한 워커&lt;/li&gt;
      &lt;li&gt;큐에서 메시지를 받고 검증 후 채팅창에 돌려주고 디비에 저장함&lt;/li&gt;
      &lt;li&gt;처음 go를 써봤는데 굉장히 만족스러움&lt;/li&gt;
      &lt;li&gt;개발속도도 빠르고 버그도 많이 없고 속도 빠른 ruby 쓰는 느낌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디비
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;mysql&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;mongo&lt;/a&gt;나 nosql류를 쓰면 좋을것 같긴한데 익숙하지 않아 관리할 자신이 없어서 포기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;큐
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://kafka.apache.org/&quot;&gt;kafka&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.rabbitmq.com/&quot;&gt;rabbitmq&lt;/a&gt;를 썼다가 퍼포먼스 이슈가 발생해서 옮김&lt;/li&gt;
      &lt;li&gt;kafka는 &lt;a href=&quot;https://linkedin.com/&quot;&gt;linkedin&lt;/a&gt;에서 만들었고 메모리 방식이 아닌 하드 저장 방식임 =&amp;gt; 메모리가 아니다! 메시지 유실걱정이 없음!&lt;/li&gt;
      &lt;li&gt;하드를 백엔드로 하지만 캐시와 random access를 제한하여 굉장히 빠름&lt;/li&gt;
      &lt;li&gt;기능은 굉장히 부실하지만 속도가 극강임&lt;/li&gt;
      &lt;li&gt;버전별 호환성이 너무 안좋아서 특정 라이브러리에 같은 버전을 지원하도록 잘 써야함
        &lt;ul&gt;
          &lt;li&gt;java, ruby, go 라이브러리가 찰싹 붙어야하는 상황&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;빨리 버전 안정화 되길&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;실시간 동영상&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실시간으로 영상을 전송하는게 우리 서비스의 핵심&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.wowza.com/&quot;&gt;wowza&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;적극 고려했으나 그냥 이쁜 UI에 유료로 &lt;a href=&quot;https://www.ffmpeg.org/&quot;&gt;ffmpeg&lt;/a&gt; 쓰는 느낌&lt;/li&gt;
      &lt;li&gt;결국 테스트할때만 사용하고 ffmpeg 사용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol&quot;&gt;RTMP&lt;/a&gt;/&lt;a href=&quot;https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol&quot;&gt;RTSP&lt;/a&gt;/&lt;a href=&quot;https://developer.apple.com/streaming/&quot;&gt;HLS&lt;/a&gt; 프로토콜만 지원하면  대부분 문제 해결됨&lt;/li&gt;
  &lt;li&gt;오리진 서버와 엣지 서버를 어떻게 구성하는지가 중요&lt;/li&gt;
  &lt;li&gt;트래픽이 어마어마하여 속도와 비용을 고려하여 클라우드 선택. 아직도 여러 클라우드 테스트중
    &lt;ul&gt;
      &lt;li&gt;트래픽을 무제한으로 주는 어떤 클라우드의 경우 속도도 빨라서 최종결정했었으나 방송직전 속도가 떨어짐 =&amp;gt; 트래픽이 많다는 이유로 강제로 제한당함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/&quot;&gt;유튜브&lt;/a&gt;와 &lt;a href=&quot;https://live.fb.com/&quot;&gt;페이스북 라이브&lt;/a&gt;, &lt;a href=&quot;https://vimeo.com/&quot;&gt;비메오&lt;/a&gt; 사용중&lt;/li&gt;
  &lt;li&gt;비메오 유료계정은 광고 없이 자체 플레이어를 쓸수 있고 트래픽이 무제한임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;배송조회&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.doortodoor.co.kr/main/&quot;&gt;CJ대한통운&lt;/a&gt; 이용
    &lt;ul&gt;
      &lt;li&gt;api을 제공하지 않음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://sweettracker.github.io/&quot;&gt;sweettracker&lt;/a&gt;와 &lt;a href=&quot;https://www.aftership.com/&quot;&gt;aftership&lt;/a&gt;은 유료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오픈소스
    &lt;ul&gt;
      &lt;li&gt;go로 그냥 만듬&lt;/li&gt;
      &lt;li&gt;다른 택배사도 지원가능한 구조&lt;/li&gt;
      &lt;li&gt;곧, 오픈소스 공개할 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;우편번호검색&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://postcode.map.daum.net/guide&quot;&gt;daum API&lt;/a&gt;가 최고
    &lt;ul&gt;
      &lt;li&gt;키 발급도 없고 무제한 트래픽에 속도도 빠름!&lt;/li&gt;
      &lt;li&gt;하지만, 웹만 제공하고 커스터마이징이 어려운 단점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://postcodify.poesis.kr/&quot;&gt;postcodify&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;php기반의 오픈소스 프로젝트&lt;/li&gt;
      &lt;li&gt;구주소, 신주소 동시 검색 지원&lt;/li&gt;
      &lt;li&gt;상세한 결과 API&lt;/li&gt;
      &lt;li&gt;굉장히 유연한 검색을 지원&lt;/li&gt;
      &lt;li&gt;대신 좀 느림 ㅠ 맴캐시 걸어도 새로운 주소는 느림 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;API Gateway&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://subicura.com/assets/article_images/2016-05-30-likehs-develop-log/api-gateway.png&quot; alt=&quot;API Gateway란?&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배송조회 및 우편번호검색에서 사용&lt;/li&gt;
  &lt;li&gt;배송조회와 우편번호검색이 따로 인증 기능이 없기 때문에 앞단에 gateway를 둠&lt;/li&gt;
  &lt;li&gt;위 사진처럼, 호출개수 제한, 키등록, 캐싱, 로깅, 분석등을 해줌&lt;/li&gt;
  &lt;li&gt;tyk
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://getkong.org/&quot;&gt;kong&lt;/a&gt;을 고려해봤으나 gui가 유료임&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://tyk.io/&quot;&gt;tyk&lt;/a&gt;는 go 기반의 gateway로 전직 구글러들이 만듬&lt;/li&gt;
      &lt;li&gt;서버 한대까지 무료고 GUI도 제공&lt;/li&gt;
      &lt;li&gt;설치가 간단하고 사용법도 쉬움&lt;/li&gt;
      &lt;li&gt;tyk에 api를 호출하면 tyk가 다시 원래 api를 호출하는 방식임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;푸시&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pushbots.com/&quot;&gt;pushbot&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;다른 솔루션들은 기기등록 제한이 있는 경우가 많은데, pushbot은 기기등록 수 제한없음&lt;/li&gt;
      &lt;li&gt;무료 발송 건수가 엄청나게 많음&lt;/li&gt;
      &lt;li&gt;푸시는 광고성 푸시가 대부분일거라 생각해 대량의 기기에 소량의 건수라 우리한테 딱임&lt;/li&gt;
      &lt;li&gt;문서가 조금 부실함 =&amp;gt; 안드로이드 상태바 아이콘 바꾸는 법 문서에 없는데 기능은 있음;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;메일&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mailgun.com/&quot;&gt;mailgun&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;발송용으로 사용&lt;/li&gt;
      &lt;li&gt;비슷한 서비스들 사이에 딱히 장점/단점은 모르겠음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.worksmobile.com/kr/&quot;&gt;네이버웍스&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;메일 수신/발송용으로 사용&lt;/li&gt;
      &lt;li&gt;구글웍스가 유료화되어 아쉬움 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;템플릿
    &lt;ul&gt;
      &lt;li&gt;데스크탑, 모바일, 앱에서 이메일이 깨지지 않는지 확인함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://litmus.com/&quot;&gt;litmus&lt;/a&gt; =&amp;gt; 최대 테스트 개수가 제한되어 있긴 한데 쓸만함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/leemunroe/grunt-email-workflow&quot;&gt;Grunt Email Design Workflow&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;이메일은 css class를 지원하지 않아 전부 inline으로 넣어야함 그런걸 자동으로 해줌&lt;/li&gt;
          &lt;li&gt;class 지원과 scss지원, 미리보기등을 지원함&lt;/li&gt;
          &lt;li&gt;express 기반이라 변수설정등도 가능함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;SMS&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.apistore.co.kr/api/apiView.do?service_seq=151&quot;&gt;olleh API Store&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;타사 대비 저렴함
        &lt;ul&gt;
          &lt;li&gt;SMS 9.9원 / LMS 28원 / MMS 110원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;REST API 사용 간단함&lt;/li&gt;
      &lt;li&gt;서비스 신청시 계약서를 등기로 보내야하는 번거로움. 원래 다 이런식으로 계약하는건가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CS&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://yellowid.kakao.com/&quot;&gt;카카오톡 옐로우아이디&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;상담은 채팅으로 유도&lt;/li&gt;
      &lt;li&gt;한 아이디에 여려명 관리자 등록 가능하고 데스크탑에서도 잘 동작함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SK 브로드밴드 1670-xxxx
    &lt;ul&gt;
      &lt;li&gt;02번호 대신 대표 번호로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;이슈관리/코드검수&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://phabricator.org/&quot;&gt;phabricator&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;facebook의 오픈소스 코드리뷰, 테스크 관리, 프로젝트 관리툴&lt;/li&gt;
      &lt;li&gt;기능은 짱짱 많고 좋은듯 하지만 세부적으로 꼭 필요한 몇몇 기능은 부족한 느낌임&lt;/li&gt;
      &lt;li&gt;일반 이슈 관리시스템 대비 기능이 부족하여 무조건 추천하지는 못하겠음&lt;/li&gt;
      &lt;li&gt;기능이 부족한 부분은 phabricator 방식에 맞춰야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gitlab.com/&quot;&gt;gitlab&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;gitlab에 &lt;a href=&quot;https://guides.github.com/introduction/flow/&quot;&gt;github flow&lt;/a&gt; 방식을 사용
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;http://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html&quot;&gt;git flow&lt;/a&gt;와는 다르고 &lt;a href=&quot;https://code.google.com/p/gerrit/&quot;&gt;gerrit&lt;/a&gt;과는 다르다!&lt;/li&gt;
          &lt;li&gt;gitlab이 master push를 제한할수 있기때문에 쉽게 적용가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기능단위로 브랜치를 따고 pull request를 보내면 팀장이 코드 검수 후 auto merge&lt;/li&gt;
      &lt;li&gt;팀장이 부지런해야 빨리빨리 동작&lt;/li&gt;
      &lt;li&gt;안드로이드, 아이폰은 개발자가 각각 한명이라 코드 검수 없이 진행함 / 간혹 특이하거나 괜찮은 부분은 따로 공유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;서버&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회사자체서버
    &lt;ul&gt;
      &lt;li&gt;IBM System x3650 M4
        &lt;ul&gt;
          &lt;li&gt;Intel(R) Xeon(R) CPU E5-2640 0 @ 2.50GHz * 2 / Memory - 96G&lt;/li&gt;
          &lt;li&gt;각종 내부 툴들과 gitlab, 모니터링등이 돌고 있음&lt;/li&gt;
          &lt;li&gt;채팅 서비스도 여기서 도는중&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ucloudbiz.olleh.com/&quot;&gt;KT 클라우드&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;클라우드는 아마존은 생각보다 너무 비쌌고 KT가 저렴하고 속도도 빨랐음&lt;/li&gt;
      &lt;li&gt;커머스와 영상은 KT 클라우드에서 운영중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chef.io/chef/&quot;&gt;chef&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;ruby에 익숙하고 웹 GUI를 무료로 제공하여 선택했고 &lt;a href=&quot;https://puppet.com/&quot;&gt;puppet&lt;/a&gt;이나 &lt;a href=&quot;https://saltstack.com/&quot;&gt;saltstack&lt;/a&gt;, &lt;a href=&quot;https://www.ansible.com/&quot;&gt;ansible&lt;/a&gt;같은 다른 툴들도 기능은 비슷비슷한듯함&lt;/li&gt;
      &lt;li&gt;기본적인 방화벽 설정과 도커, sensu monitoring client를 설치하는게 주된 용도&lt;/li&gt;
      &lt;li&gt;방화벽은 &lt;a href=&quot;https://help.ubuntu.com/community/UFW&quot;&gt;ufw&lt;/a&gt;사용중. iptables 너무 어렵 ㅠ&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker
    &lt;ul&gt;
      &lt;li&gt;web application&lt;/li&gt;
      &lt;li&gt;nginx&lt;/li&gt;
      &lt;li&gt;mysql&lt;/li&gt;
      &lt;li&gt;sensu&lt;/li&gt;
      &lt;li&gt;… 모든건 컨테이너로.. 짱짱맨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;웹서버&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;http/tcp/websocket reverse proxy용도&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://developers.google.com/speed/pagespeed/module/&quot;&gt;nginx pagespeed module&lt;/a&gt; 적용하여 정적 파일 최적화
        &lt;ul&gt;
          &lt;li&gt;단순히 &lt;code class=&quot;highlighter-rouge&quot;&gt;pagespeed on;&lt;/code&gt;만 해주면 이미지를 알아서 압축해서 내려보내줌&lt;/li&gt;
          &lt;li&gt;chrome은 &lt;a href=&quot;https://developers.google.com/speed/webp/&quot;&gt;webp&lt;/a&gt;로 jpeg보다 더 좋은 압축률에 좋은화질임&lt;/li&gt;
          &lt;li&gt;그외에 최적화에 대한 많은 기능들 포함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/&quot;&gt;cloudflare&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;앞단에 적용하여 cdn과 방화벽 용도로 사용&lt;/li&gt;
      &lt;li&gt;단점을 모르겠음&lt;/li&gt;
      &lt;li&gt;dns server 설정도 엄청나게 편하고 cdn cache도 엄청나게 간단함&lt;/li&gt;
      &lt;li&gt;땅파서 장사하는건지.. 그래서 유료 플랜 가입함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;모니터링&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://sensuapp.org/&quot;&gt;sensu&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;한곳에서 서버상황과 자원을 모니터링함&lt;/li&gt;
      &lt;li&gt;슬랙 플러그인을 사용하여 서버가 죽거나 자원을 많이 사용하면 경고메시지 날라옴&lt;/li&gt;
      &lt;li&gt;확장성이 좋고 &lt;a href=&quot;https://github.com/sensu-plugins&quot;&gt;플러그인&lt;/a&gt;이 다양하고 ruby기반에 수정하기도 편함. 게다가 구조도 간단해서 선택함&lt;/li&gt;
      &lt;li&gt;rabbitmq 통신을 암호화하고 방화벽을 적용하면 설정 끝&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grafana.org/&quot;&gt;grafana&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;sensu가 influxdb에 서버 모니터링 정보를 저장&lt;/li&gt;
      &lt;li&gt;데이터를 그래프로 보여주고 있음. 한눈에 보기 좋고 다양한 커스터마이징이 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전통의 강호 &lt;a href=&quot;https://analytics.google.com/&quot;&gt;구글 애널리틱스&lt;/a&gt; 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;배포&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/web_hooks/web_hooks.md&quot;&gt;gitlab&lt;/a&gt;+&lt;a href=&quot;https://jenkins.io/&quot;&gt;jenkins&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;gitlab에 push하면 webhook을 통해 jenkins 자동 배포&lt;/li&gt;
      &lt;li&gt;빌드 / 테스트 / 도커라이징 / 배포&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/compose/&quot;&gt;docker compose&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;서버쪽은 전부 도커! docker compose를 적극 활용함 도커 만세&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://martinfowler.com/bliki/BlueGreenDeployment.html&quot;&gt;blue green deployment&lt;/a&gt; 방식사용
    &lt;ul&gt;
      &lt;li&gt;한서버에 8090, 8091 포트를 사용중&lt;/li&gt;
      &lt;li&gt;8090이 떠있을때 배포를 하면 8091로 배포를 하고 nginx가 8091을 바라보게 한 후 8090을 죽임 =&amp;gt; 8090, 8091 왔다갔다 하는 방식임&lt;/li&gt;
      &lt;li&gt;덕분에, 하루에도 수십번 이상없이 배포중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://fabric.io/home&quot;&gt;fabric&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;아이폰/안드로이드 앱 테스트 배포&lt;/li&gt;
      &lt;li&gt;사용법이 쉽고 오류로깅도 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://seoulappcenter.co.kr/&quot;&gt;서울앱비지니스센터&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;다양한 안드로이드 및 iOS 기기를 빌려줌&lt;/li&gt;
      &lt;li&gt;이전한지 얼마 안되서 정식 오픈은 안했고 무료에 쾌적함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;디자인&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sketchapp.com/&quot;&gt;sketch&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;디자인은 이제 거의다 sketch로 하고 포토샵은 일부만 사용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zeplin.io/&quot;&gt;zeplin&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;sketch와 찰떡 궁합인 zaplin을 사용하여 웹/앱 디자인 공유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;커뮤니케이션은 어떻게?&lt;/h2&gt;

&lt;p&gt;개발자와 기획자 / 디자이너&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://slack.com/&quot;&gt;slack&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요즘 대부분 사용하고 있는 슬랙&lt;/li&gt;
  &lt;li&gt;주제별로 채널을 만들어서 사용중
    &lt;ul&gt;
      &lt;li&gt;app, web, marketing, cs, video, ci, bug, bot 등으로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://airtable.com/&quot;&gt;airtable&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹/앱 기반 스프리드시트 서비스&lt;/li&gt;
  &lt;li&gt;자유도가 높고 간단한 내용은 데이터베이스를 대체하여 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;자료성 정보 공유는 여기서 이루어짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;그래서&lt;/h2&gt;

&lt;p&gt;이번 프로젝트에서 기획/디자인/영업을 제외한 순수 개발파트는 4명이 풀로 투입되고 2명이 다른 일과 병행하면서 진행하였습니다. 다들 기술적인 부분을 좋아하다보니 여러가지 기술이 사용되면서 단순할 수 있는 부분도 복잡해진 느낌이 있습니다.&lt;/p&gt;

&lt;p&gt;결국 집에서 &lt;strong&gt;떡볶이 하나&lt;/strong&gt;를 먹기 위해 생각보다 많은 작업을 한것 같습니다. 개발과 관련된 내용만 정리했지만 BJ를 섭외하고 영상을 촬영하고 편집하고 상품을 기획하고 영업하고 만들고 배송하고 CS를 운영하고 마케팅을 하는 부분도 엄청난 노력이 필요했습니다.&lt;/p&gt;

&lt;p&gt;서비스에 관심있으신분은 &lt;a href=&quot;https://www.likehs.com&quot;&gt;https://www.likehs.com/&lt;/a&gt; 에 방문해 주시구요. (현재 서울스낵x불맛쌀떡볶이 &lt;strong&gt;무료 구매 이벤트&lt;/strong&gt;중!)&lt;/p&gt;

&lt;p&gt;아참, 개발자도 모집합니다. 연락주세요 ㅎㅎ (&lt;a href=&quot;http://www.purpleworks.co.kr/recruit&quot;&gt;http://www.purpleworks.co.kr/recruit&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;홈쇼핑처럼팀 다들 수고하셨어요. 모두 화이팅! 앱도 화이팅 ㅋㅋ&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hello</title>
   <link href="http://subicura.com/2016/03/23/hello.html"/>
   <updated>2016-03-23T00:00:00+09:00</updated>
   <id>http://subicura.com/2016/03/23/hello</id>
   <content type="html">&lt;h3 id=&quot;section&quot;&gt;2016/12/31 수정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;tinypress.co는 더이상 사용하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;blog 시작하기 좋은날입니다. ghost설치했다가 실수로 서버를 지우는 바람에 이전 블로그가 사라졌습니다. 글이 별로 많지는 않았지만.. 아쉽네요 ㅠ&lt;/p&gt;

&lt;p&gt;역시 설치형보다는 서비스형이 나은것 같습니다. &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll&lt;/a&gt; 명령어가 너무 어려웠는데 &lt;a href=&quot;http://tinypress.co&quot;&gt;tinypress.co&lt;/a&gt;라는 웹 에디터를 발견했습니다. 단순한게 맘에 드네요.&lt;/p&gt;

&lt;p&gt;간단한 개발팀은 &lt;a href=&quot;https://github.com/subicura/til&quot;&gt;til&lt;/a&gt;에 올리고 있습니다. 블로그는 그외에 소소한 얘기나 블로깅할만한 주제가 있을때 작성할 예정입니다.&lt;/p&gt;
</content>
 </entry>
 

</feed>
